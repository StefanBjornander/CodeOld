1:	

atoi:	; call header integral zero 0 stack zero 0
3:	

atoi$1:	; parameter s, offset 6
4:		mov a1524, [bp + 6]
5:		mov [bp + 14], a1524
7:	

atoi$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atoi$3:	; parameter 10, offset 10
11:		mov word [bp + 18], 10
13:	

atoi$4:	; call function noellipse-noellipse strtol
14:		mov word [bp + 8], atoi$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp strtol
19:	

atoi$5:	; post call
21:	

atoi$6:	; £temporary2376 = return_value
26:	

atoi$7:	; £temporary2377 = int_to_int £temporary2376 (Signed_Long_Int -> Signed_Int)
29:		cmp t1526, 0
30:		jge atoi$8
31:		neg t1526
33:		neg t1526
35:	

atoi$8:	; return_value = £temporary2377
37:	

atoi$9:	; return
38:		mov t1527, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp t1527
43:	

atoi$10:	; function end atoi
1:	

atol:	; call header integral zero 0 stack zero 0
3:	

atol$1:	; parameter s, offset 6
4:		mov a1528, [bp + 6]
5:		mov [bp + 14], a1528
7:	

atol$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atol$3:	; parameter 10, offset 10
11:		mov word [bp + 18], 10
13:	

atol$4:	; call function noellipse-noellipse strtol
14:		mov word [bp + 8], atol$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp strtol
19:	

atol$5:	; post call
21:	

atol$6:	; £temporary2381 = return_value
26:	

atol$7:	; return_value = £temporary2381
28:	

atol$8:	; return
29:		mov t1531, [bp]
30:		mov di, [bp + 4]
31:		mov bp, [bp + 2]
32:		jmp t1531
34:	

atol$9:	; function end atol
1:	

strtol:	; chars = 0
2:		mov word [bp + 12], 0
4:	

strtol$1:	; value = 0
5:		mov dword [bp + 14], 0
7:	

strtol$2:	; call header integral zero 0 stack zero 0
9:	

strtol$3:	; parameter s, offset 6
10:		mov a1532, [bp + 6]
11:		mov [bp + 24], a1532
13:	

strtol$4:	; parameter string_25li25n#, offset 8
14:		mov word [bp + 26], string_25li25n#
16:	

strtol$5:	; £temporary2385 = &value
17:		mov t1533, bp
18:		add t1533, 14
20:	

strtol$6:	; parameter £temporary2385, offset 10
21:		mov [bp + 28], t1533
23:	

strtol$7:	; £temporary2386 = &chars
24:		mov t1534, bp
25:		add t1534, 12
27:	

strtol$8:	; parameter £temporary2386, offset 12
28:		mov [bp + 30], t1534
30:	

strtol$9:	; call function noellipse-ellipse sscanf, extra 0
31:		mov word [bp + 18], strtol$10
32:		mov [bp + 20], bp
33:		add bp, 18
34:		mov di, bp
35:		add di, 4
36:		jmp sscanf
38:	

strtol$10:	; post call
40:	

strtol$11:	; if endp == 0 goto 14
41:		cmp word [bp + 8], 0
42:		je strtol$14
44:	

strtol$12:	; £temporary2389 -> endp = *endp
45:		mov a1535, [bp + 8]
47:	

strtol$13:	; £temporary2389 -> endp = s + chars
48:		mov a1536, [bp + 6]
49:		add a1536, [bp + 12]
50:		mov [a1535], a1536
52:	

strtol$14:	; return_value = value
53:		mov a1537, [bp + 14]
55:	

strtol$15:	; return
56:		mov t1538, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp t1538
61:	

strtol$16:	; function end strtol
1:	

strtoul:	; chars = 0
2:		mov word [bp + 12], 0
4:	

strtoul$1:	; value = 0
5:		mov dword [bp + 14], 0
7:	

strtoul$2:	; call header integral zero 0 stack zero 0
9:	

strtoul$3:	; parameter s, offset 6
10:		mov a1539, [bp + 6]
11:		mov [bp + 24], a1539
13:	

strtoul$4:	; parameter string_25lu25n#, offset 8
14:		mov word [bp + 26], string_25lu25n#
16:	

strtoul$5:	; £temporary2397 = &value
17:		mov t1540, bp
18:		add t1540, 14
20:	

strtoul$6:	; parameter £temporary2397, offset 10
21:		mov [bp + 28], t1540
23:	

strtoul$7:	; £temporary2398 = &chars
24:		mov t1541, bp
25:		add t1541, 12
27:	

strtoul$8:	; parameter £temporary2398, offset 12
28:		mov [bp + 30], t1541
30:	

strtoul$9:	; call function noellipse-ellipse sscanf, extra 0
31:		mov word [bp + 18], strtoul$10
32:		mov [bp + 20], bp
33:		add bp, 18
34:		mov di, bp
35:		add di, 4
36:		jmp sscanf
38:	

strtoul$10:	; post call
40:	

strtoul$11:	; if endp == 0 goto 14
41:		cmp word [bp + 8], 0
42:		je strtoul$14
44:	

strtoul$12:	; £temporary2401 -> endp = *endp
45:		mov a1542, [bp + 8]
47:	

strtoul$13:	; £temporary2401 -> endp = s + chars
48:		mov a1543, [bp + 6]
49:		add a1543, [bp + 12]
50:		mov [a1542], a1543
52:	

strtoul$14:	; return_value = value
53:		mov a1544, [bp + 14]
55:	

strtoul$15:	; return
56:		mov t1545, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp t1545
61:	

strtoul$16:	; function end strtoul
1:	

atof:	; call header integral zero 0 stack zero 0
3:	

atof$1:	; parameter s, offset 6
4:		mov a1546, [bp + 6]
5:		mov [bp + 14], a1546
7:	

atof$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atof$3:	; call function noellipse-noellipse strtod
11:		mov word [bp + 8], atof$4
12:		mov [bp + 10], bp
13:		add bp, 8
14:		jmp strtod
16:	

atof$4:	; post call
18:	

atof$5:	; £temporary2409 = return_value
20:	

atof$6:	; return_value = £temporary2409
22:	

atof$7:	; return
23:		mov t1547, [bp]
24:		mov di, [bp + 4]
25:		mov bp, [bp + 2]
26:		jmp t1547
28:	

atof$8:	; function end atof
1:	

strtod:	; chars = 0
2:		mov word [bp + 10], 0
4:	

strtod$1:	; push 0
5:		fldz
7:	

strtod$2:	; pop float value
8:		fstp qword [bp + 12]
10:	

strtod$3:	; call header integral zero 0 stack zero 0
12:	

strtod$4:	; parameter s, offset 6
13:		mov a1548, [bp + 6]
14:		mov [bp + 26], a1548
16:	

strtod$5:	; parameter string_25lf25n#, offset 8
17:		mov word [bp + 28], string_25lf25n#
19:	

strtod$6:	; £temporary2412 = &value
20:		mov t1549, bp
21:		add t1549, 12
23:	

strtod$7:	; parameter £temporary2412, offset 10
24:		mov [bp + 30], t1549
26:	

strtod$8:	; £temporary2413 = &chars
27:		mov t1550, bp
28:		add t1550, 10
30:	

strtod$9:	; parameter £temporary2413, offset 12
31:		mov [bp + 32], t1550
33:	

strtod$10:	; call function noellipse-ellipse sscanf, extra 0
34:		mov word [bp + 20], strtod$11
35:		mov [bp + 22], bp
36:		add bp, 20
37:		mov di, bp
38:		add di, 4
39:		jmp sscanf
41:	

strtod$11:	; post call
43:	

strtod$12:	; if endp == 0 goto 15
44:		cmp word [bp + 8], 0
45:		je strtod$15
47:	

strtod$13:	; £temporary2416 -> endp = *endp
48:		mov a1551, [bp + 8]
50:	

strtod$14:	; £temporary2416 -> endp = s + chars
51:		mov a1552, [bp + 6]
52:		add a1552, [bp + 10]
53:		mov [a1551], a1552
55:	

strtod$15:	; push float value
56:		fld qword [bp + 12]
58:	

strtod$16:	; return_value = value
60:	

strtod$17:	; return
61:		mov t1553, [bp]
62:		mov di, [bp + 4]
63:		mov bp, [bp + 2]
64:		jmp t1553
66:	

strtod$18:	; function end strtod
1:	

abort:	; ah = 76
2:		mov a1554, 76
4:	

abort$1:	; al = -1
5:		mov a1555, -1
7:	

abort$2:	; interrupt 33
8:		int 33
10:	

abort$3:	; return
11:		mov t1556, [bp]
12:		mov di, [bp + 4]
13:		mov bp, [bp + 2]
14:		jmp t1556
16:	

abort$4:	; function end abort
1:	

getenv:	; return_value = 0
2:		mov a1557, 0
4:	

getenv$1:	; return
5:		mov t1558, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp t1558
10:	

getenv$2:	; function end getenv
1:	

system:	; return_value = -1
2:		mov a1559, -1
4:	

system$1:	; return
5:		mov t1560, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp t1560
10:	

system$2:	; function end system
1:	

memswp:	; £temporary2426 = int_to_int value1 (Pointer -> Pointer)
2:		mov a1561, [bp + 6]
5:	

memswp$1:	; charValue1 = £temporary2426
6:		mov [bp + 12], a1561
8:	

memswp$2:	; £temporary2427 = int_to_int value2 (Pointer -> Pointer)
9:		mov a1562, [bp + 8]
12:	

memswp$3:	; charValue2 = £temporary2427
13:		mov [bp + 14], a1562
15:	

memswp$4:	; index = 0
16:		mov word [bp + 16], 0
18:	

memswp$5:	; if index >= valueSize goto 19
19:		mov a1563, [bp + 10]
20:		cmp [bp + 16], a1563
21:		jge memswp$19
23:	

memswp$6:	; £temporary2431 = charValue1 + index
24:		mov a1564, [bp + 12]
25:		add a1564, [bp + 16]
27:	

memswp$7:	; £temporary2430 -> £temporary2431 = *£temporary2431
29:	

memswp$8:	; tempValue = £temporary2430 -> £temporary2431
30:		mov t1565, [a1564]
31:		mov [bp + 18], t1565
33:	

memswp$9:	; £temporary2433 = charValue1 + index
34:		mov a1566, [bp + 12]
35:		add a1566, [bp + 16]
37:	

memswp$10:	; £temporary2432 -> £temporary2433 = *£temporary2433
39:	

memswp$11:	; £temporary2435 = charValue2 + index
40:		mov a1567, [bp + 14]
41:		add a1567, [bp + 16]
43:	

memswp$12:	; £temporary2434 -> £temporary2435 = *£temporary2435
45:	

memswp$13:	; £temporary2432 -> £temporary2433 = £temporary2434 -> £temporary2435
46:		mov t1568, [a1567]
47:		mov [a1566], t1568
49:	

memswp$14:	; £temporary2437 = charValue2 + index
50:		mov a1569, [bp + 14]
51:		add a1569, [bp + 16]
53:	

memswp$15:	; £temporary2436 -> £temporary2437 = *£temporary2437
55:	

memswp$16:	; £temporary2436 -> £temporary2437 = tempValue
56:		mov a1570, [bp + 18]
57:		mov [a1569], a1570
59:	

memswp$17:	; ++index
60:		inc word [bp + 16]
62:	

memswp$18:	; goto 5
63:		jmp memswp$5
65:	

memswp$19:	; return
66:		mov t1571, [bp]
67:		mov di, [bp + 4]
68:		mov bp, [bp + 2]
69:		jmp t1571
71:	

memswp$20:	; function end memswp
1:	

bsearch:	; firstIndex = 0
2:		mov word [bp + 16], 0
4:	

bsearch$1:	; lastIndex = listSize - 1
5:		mov a1572, [bp + 10]
6:		sub a1572, 1
7:		mov [bp + 18], a1572
9:	

bsearch$2:	; if listSize != 0 goto 5
10:		cmp word [bp + 10], 0
11:		jne bsearch$5
13:	

bsearch$3:	; return_value = 0
14:		mov a1573, 0
16:	

bsearch$4:	; return
17:		mov t1574, [bp]
18:		mov di, [bp + 4]
19:		mov bp, [bp + 2]
20:		jmp t1574
22:	

bsearch$5:	; £temporary2440 = int_to_int valueList (Pointer -> Pointer)
23:		mov a1575, [bp + 8]
26:	

bsearch$6:	; £temporary2441 = firstIndex * valueSize
27:		mov a1576, [bp + 16]
29:		xor dx, dx
30:		imul word [bp + 12]
36:	

bsearch$7:	; firstValuePtr = £temporary2440 + £temporary2441
37:		add a1575, t1579
38:		mov [bp + 20], a1575
40:	

bsearch$8:	; call header integral zero 0 stack zero 0
42:	

bsearch$9:	; parameter keyPtr, offset 6
43:		mov a1580, [bp + 6]
44:		mov [bp + 28], a1580
46:	

bsearch$10:	; parameter firstValuePtr, offset 8
47:		mov a1581, [bp + 20]
48:		mov [bp + 30], a1581
50:	

bsearch$11:	; call function noellipse-noellipse compare
51:		mov word [bp + 22], bsearch$12
52:		mov [bp + 24], bp
53:		add bp, 22
54:		mov a1582, [bp + 14]
55:		jmp a1582 a1582 compare 54 55
57:	

bsearch$12:	; post call
59:	

bsearch$13:	; £temporary2443 = return_value
64:	

bsearch$14:	; firstCompare = £temporary2443
65:		mov [bp + 22], t1584
67:	

bsearch$15:	; if firstCompare >= 0 goto 18
68:		cmp word [bp + 22], 0
69:		jge bsearch$18
71:	

bsearch$16:	; return_value = 0
72:		mov a1585, 0
74:	

bsearch$17:	; return
75:		mov t1586, [bp]
76:		mov di, [bp + 4]
77:		mov bp, [bp + 2]
78:		jmp t1586
80:	

bsearch$18:	; if firstCompare != 0 goto 21
81:		cmp word [bp + 22], 0
82:		jne bsearch$21
84:	

bsearch$19:	; return_value = firstValuePtr
85:		mov a1587, [bp + 20]
87:	

bsearch$20:	; return
88:		mov t1588, [bp]
89:		mov di, [bp + 4]
90:		mov bp, [bp + 2]
91:		jmp t1588
93:	

bsearch$21:	; £temporary2446 = int_to_int valueList (Pointer -> Pointer)
94:		mov a1589, [bp + 8]
97:	

bsearch$22:	; £temporary2447 = lastIndex * valueSize
98:		mov a1590, [bp + 18]
100:		xor dx, dx
101:		imul word [bp + 12]
107:	

bsearch$23:	; lastValuePtr = £temporary2446 + £temporary2447
108:		add a1589, t1593
109:		mov [bp + 20], a1589
111:	

bsearch$24:	; call header integral zero 0 stack zero 0
113:	

bsearch$25:	; parameter keyPtr, offset 6
114:		mov a1594, [bp + 6]
115:		mov [bp + 28], a1594
117:	

bsearch$26:	; parameter lastValuePtr, offset 8
118:		mov a1595, [bp + 20]
119:		mov [bp + 30], a1595
121:	

bsearch$27:	; call function noellipse-noellipse compare
122:		mov word [bp + 22], bsearch$28
123:		mov [bp + 24], bp
124:		add bp, 22
125:		mov a1596, [bp + 14]
126:		jmp a1596 a1596 compare 125 126
128:	

bsearch$28:	; post call
130:	

bsearch$29:	; £temporary2449 = return_value
135:	

bsearch$30:	; lastCompare = £temporary2449
136:		mov [bp + 22], t1598
138:	

bsearch$31:	; if lastCompare <= 0 goto 34
139:		cmp word [bp + 22], 0
140:		jle bsearch$34
142:	

bsearch$32:	; return_value = 0
143:		mov a1599, 0
145:	

bsearch$33:	; return
146:		mov t1600, [bp]
147:		mov di, [bp + 4]
148:		mov bp, [bp + 2]
149:		jmp t1600
151:	

bsearch$34:	; if lastCompare != 0 goto 37
152:		cmp word [bp + 22], 0
153:		jne bsearch$37
155:	

bsearch$35:	; return_value = lastValuePtr
156:		mov a1601, [bp + 20]
158:	

bsearch$36:	; return
159:		mov t1602, [bp]
160:		mov di, [bp + 4]
161:		mov bp, [bp + 2]
162:		jmp t1602
164:	

bsearch$37:	; £temporary2452 = firstIndex + lastIndex
165:		mov a1603, [bp + 16]
166:		add a1603, [bp + 18]
168:	

bsearch$38:	; middleIndex = £temporary2452 / 2
170:		xor dx, dx
171:		idiv word [int2$2#]
172:		mov [bp + 20], ax
174:	

bsearch$39:	; £temporary2454 = int_to_int valueList (Pointer -> Pointer)
175:		mov a1606, [bp + 8]
178:	

bsearch$40:	; £temporary2455 = middleIndex * valueSize
179:		mov a1607, [bp + 20]
181:		xor dx, dx
182:		imul word [bp + 12]
188:	

bsearch$41:	; middleValuePtr = £temporary2454 + £temporary2455
189:		add a1606, t1610
190:		mov [bp + 22], a1606
192:	

bsearch$42:	; call header integral zero 0 stack zero 0
194:	

bsearch$43:	; parameter keyPtr, offset 6
195:		mov a1611, [bp + 6]
196:		mov [bp + 30], a1611
198:	

bsearch$44:	; parameter middleValuePtr, offset 8
199:		mov a1612, [bp + 22]
200:		mov [bp + 32], a1612
202:	

bsearch$45:	; call function noellipse-noellipse compare
203:		mov word [bp + 24], bsearch$46
204:		mov [bp + 26], bp
205:		add bp, 24
206:		mov a1613, [bp + 14]
207:		jmp a1613 a1613 compare 206 207
209:	

bsearch$46:	; post call
211:	

bsearch$47:	; £temporary2457 = return_value
216:	

bsearch$48:	; middleCompare = £temporary2457
217:		mov [bp + 24], t1615
219:	

bsearch$49:	; if middleCompare >= 0 goto 52
220:		cmp word [bp + 24], 0
221:		jge bsearch$52
223:	

bsearch$50:	; lastIndex = middleIndex
224:		mov a1616, [bp + 20]
225:		mov [bp + 18], a1616
227:	

bsearch$51:	; goto 5
228:		jmp bsearch$5
230:	

bsearch$52:	; if middleCompare <= 0 goto 55
231:		cmp word [bp + 24], 0
232:		jle bsearch$55
234:	

bsearch$53:	; firstIndex = middleIndex
235:		mov a1617, [bp + 20]
236:		mov [bp + 16], a1617
238:	

bsearch$54:	; goto 5
239:		jmp bsearch$5
241:	

bsearch$55:	; return_value = middleValuePtr
242:		mov a1618, [bp + 22]
244:	

bsearch$56:	; return
245:		mov t1619, [bp]
246:		mov di, [bp + 4]
247:		mov bp, [bp + 2]
248:		jmp t1619
250:	

bsearch$57:	; function end bsearch
1:	

rand:	; £temporary2467 = g_randValue * 1664525
2:		mov a1620, [@25$g_randValue]
4:		xor edx, edx
5:		imul dword [int4$1664525#]
11:	

rand$1:	; £temporary2468 = £temporary2467 + 1013904223
12:		add t1623, 1013904223
14:	

rand$2:	; g_randValue = £temporary2468 % 127
16:		xor edx, edx
17:		idiv dword [int4$127#]
18:		mov [@25$g_randValue], edx
20:	

rand$3:	; £temporary2470 = int_to_int g_randValue (Signed_Long_Int -> Signed_Int)
21:		mov a1625, [@25$g_randValue]
24:		cmp a1625, 0
25:		jge rand$4
26:		neg a1625
28:		neg a1625
30:	

rand$4:	; return_value = £temporary2470
32:	

rand$5:	; return
33:		mov t1626, [bp]
34:		mov di, [bp + 4]
35:		mov bp, [bp + 2]
36:		jmp t1626
38:	

rand$6:	; function end rand
1:	

srand:	; £temporary2471 = int_to_int seed (Unsigned_Int -> Signed_Long_Int)
2:		mov a1627, [bp + 6]
4:		and a1627, 65535
6:	

srand$1:	; g_randValue = £temporary2471
7:		mov [@25$g_randValue], a1627
9:	

srand$2:	; return
10:		mov t1628, [bp]
11:		mov di, [bp + 4]
12:		mov bp, [bp + 2]
13:		jmp t1628
15:	

srand$3:	; function end srand
1:	

atexit:	; index = 0
2:		mov word [bp + 8], 0
4:	

atexit$1:	; if index >= 256 goto 14
5:		cmp word [bp + 8], 256
6:		jge atexit$14
8:	

atexit$2:	; £temporary2475 = index * 2
9:		mov a1629, [bp + 8]
11:		xor dx, dx
12:		mul word [int2$2#]
18:	

atexit$3:	; £temporary2476 = g_funcArray + £temporary2475
19:		mov a1633, g_funcArray
20:		add a1633, t1632
22:	

atexit$4:	; £temporary2474 -> £temporary2476 = *£temporary2476
24:	

atexit$5:	; if £temporary2474 -> £temporary2476 != 0 goto 12
25:		cmp word [a1633], 0
26:		jne atexit$12
28:	

atexit$6:	; £temporary2479 = index * 2
29:		mov a1634, [bp + 8]
31:		xor dx, dx
32:		mul word [int2$2#]
38:	

atexit$7:	; £temporary2480 = g_funcArray + £temporary2479
39:		mov a1638, g_funcArray
40:		add a1638, t1637
42:	

atexit$8:	; £temporary2478 -> £temporary2480 = *£temporary2480
44:	

atexit$9:	; £temporary2478 -> £temporary2480 = fcn
45:		mov a1639, [bp + 6]
46:		mov [a1638], a1639
48:	

atexit$10:	; return_value = 0
49:		mov a1640, 0
51:	

atexit$11:	; return
52:		mov t1641, [bp]
53:		mov di, [bp + 4]
54:		mov bp, [bp + 2]
55:		jmp t1641
57:	

atexit$12:	; ++index
58:		inc word [bp + 8]
60:	

atexit$13:	; goto 1
61:		jmp atexit$1
63:	

atexit$14:	; return_value = -1
64:		mov a1642, -1
66:	

atexit$15:	; return
67:		mov t1643, [bp]
68:		mov di, [bp + 4]
69:		mov bp, [bp + 2]
70:		jmp t1643
72:	

atexit$16:	; function end atexit
1:	

exit:	; index = 255
2:		mov word [bp + 8], 255
4:	

exit$1:	; if index < 0 goto 14
5:		cmp word [bp + 8], 0
6:		jl exit$14
8:	

exit$2:	; £temporary2484 = index * 2
9:		mov a1644, [bp + 8]
11:		xor dx, dx
12:		mul word [int2$2#]
18:	

exit$3:	; £temporary2485 = g_funcArray + £temporary2484
19:		mov a1648, g_funcArray
20:		add a1648, t1647
22:	

exit$4:	; £temporary2483 -> £temporary2485 = *£temporary2485
24:	

exit$5:	; if £temporary2483 -> £temporary2485 == 0 goto 12
25:		cmp word [a1648], 0
26:		je exit$12
28:	

exit$6:	; £temporary2488 = index * 2
29:		mov a1649, [bp + 8]
31:		xor dx, dx
32:		mul word [int2$2#]
38:	

exit$7:	; £temporary2489 = g_funcArray + £temporary2488
39:		mov a1653, g_funcArray
40:		add a1653, t1652
42:	

exit$8:	; £temporary2487 -> £temporary2489 = *£temporary2489
43:		mov t1654, [a1653]
44:		mov [bp + 10], t1654
46:	

exit$9:	; call header integral zero 0 stack zero 0
48:	

exit$10:	; call function noellipse-noellipse £temporary2487 -> £temporary2489
49:		mov word [bp + 12], exit$11
50:		mov [bp + 14], bp
51:		add bp, 12
52:		mov t1655, [bp + 10]
53:		jmp t1655 t1655 £temporary2487 52 53
55:	

exit$11:	; post call
57:	

exit$12:	; --index
58:		dec word [bp + 8]
60:	

exit$13:	; goto 1
61:		jmp exit$1
63:	

exit$14:	; £temporary2492 = int_to_int status (Signed_Int -> Signed_Short_Int)
64:		mov a1656, [bp + 6]
67:		cmp a1656, 0
68:		jge exit$15
69:		neg a1656
71:		neg a1656
73:	

exit$15:	; al = £temporary2492
75:	

exit$16:	; ah = 76
76:		mov a1657, 76
78:	

exit$17:	; interrupt 33
79:		int 33
81:	

exit$18:	; return
82:		mov t1658, [bp]
83:		mov di, [bp + 4]
84:		mov bp, [bp + 2]
85:		jmp t1658
87:	

exit$19:	; function end exit
1:	

swap:	; index = 0
2:		mov word [bp + 12], 0
4:	

swap$1:	; if index >= valueSize goto 15
5:		mov a1659, [bp + 10]
6:		cmp [bp + 12], a1659
7:		jge swap$15
9:	

swap$2:	; £temporary2497 = leftValuePtr + index
10:		mov a1660, [bp + 6]
11:		add a1660, [bp + 12]
13:	

swap$3:	; £temporary2496 -> £temporary2497 = *£temporary2497
15:	

swap$4:	; tempValue = £temporary2496 -> £temporary2497
16:		mov t1661, [a1660]
17:		mov [bp + 14], t1661
19:	

swap$5:	; £temporary2499 = leftValuePtr + index
20:		mov a1662, [bp + 6]
21:		add a1662, [bp + 12]
23:	

swap$6:	; £temporary2498 -> £temporary2499 = *£temporary2499
25:	

swap$7:	; £temporary2501 = rightValuePtr + index
26:		mov a1663, [bp + 8]
27:		add a1663, [bp + 12]
29:	

swap$8:	; £temporary2500 -> £temporary2501 = *£temporary2501
31:	

swap$9:	; £temporary2498 -> £temporary2499 = £temporary2500 -> £temporary2501
32:		mov t1664, [a1663]
33:		mov [a1662], t1664
35:	

swap$10:	; £temporary2503 = rightValuePtr + index
36:		mov a1665, [bp + 8]
37:		add a1665, [bp + 12]
39:	

swap$11:	; £temporary2502 -> £temporary2503 = *£temporary2503
41:	

swap$12:	; £temporary2502 -> £temporary2503 = tempValue
42:		mov a1666, [bp + 14]
43:		mov [a1665], a1666
45:	

swap$13:	; ++index
46:		inc word [bp + 12]
48:	

swap$14:	; goto 1
49:		jmp swap$1
51:	

swap$15:	; return
52:		mov t1667, [bp]
53:		mov di, [bp + 4]
54:		mov bp, [bp + 2]
55:		jmp t1667
57:	

swap$16:	; function end swap
1:	

qsort:	; £temporary2504 = int_to_int valueList (Pointer -> Pointer)
2:		mov a1668, [bp + 6]
5:	

qsort$1:	; charList = £temporary2504
6:		mov [bp + 16], a1668
8:	

qsort$2:	; index1 = listSize - 1
9:		mov a1669, [bp + 8]
10:		sub a1669, 1
11:		mov [bp + 18], a1669
13:	

qsort$3:	; if index1 <= 0 goto 31
14:		cmp word [bp + 18], 0
15:		jle qsort$31
17:	

qsort$4:	; update = 0
18:		mov word [bp + 14], 0
20:	

qsort$5:	; index2 = 0
21:		mov word [bp + 20], 0
23:	

qsort$6:	; if index2 >= index1 goto 28
24:		mov a1670, [bp + 18]
25:		cmp [bp + 20], a1670
26:		jge qsort$28
28:	

qsort$7:	; £temporary2510 = index2 * valueSize
29:		mov a1671, [bp + 20]
31:		xor dx, dx
32:		imul word [bp + 10]
38:	

qsort$8:	; valuePtr1 = charList + £temporary2510
39:		mov a1675, [bp + 16]
40:		add a1675, t1674
41:		mov [bp + 22], a1675
43:	

qsort$9:	; £temporary2512 = index2 + 1
44:		mov a1676, [bp + 20]
45:		add a1676, 1
47:	

qsort$10:	; £temporary2513 = £temporary2512 * valueSize
49:		xor dx, dx
50:		imul word [bp + 10]
56:	

qsort$11:	; valuePtr2 = charList + £temporary2513
57:		mov a1680, [bp + 16]
58:		add a1680, t1679
59:		mov [bp + 24], a1680
61:	

qsort$12:	; call header integral zero 0 stack zero 0
63:	

qsort$13:	; parameter valuePtr1, offset 6
64:		mov a1681, [bp + 22]
65:		mov [bp + 32], a1681
67:	

qsort$14:	; parameter valuePtr2, offset 8
68:		mov a1682, [bp + 24]
69:		mov [bp + 34], a1682
71:	

qsort$15:	; call function noellipse-noellipse compare
72:		mov word [bp + 26], qsort$16
73:		mov [bp + 28], bp
74:		add bp, 26
75:		mov a1683, [bp + 12]
76:		jmp a1683 a1683 compare 75 76
78:	

qsort$16:	; post call
80:	

qsort$17:	; £temporary2515 = return_value
85:	

qsort$18:	; if £temporary2515 <= 0 goto 26
86:		cmp t1685, 0
87:		jle qsort$26
89:	

qsort$19:	; call header integral zero 0 stack zero 0
91:	

qsort$20:	; parameter valuePtr1, offset 6
92:		mov a1686, [bp + 22]
93:		mov [bp + 32], a1686
95:	

qsort$21:	; parameter valuePtr2, offset 8
96:		mov a1687, [bp + 24]
97:		mov [bp + 34], a1687
99:	

qsort$22:	; parameter valueSize, offset 10
100:		mov a1688, [bp + 10]
101:		mov [bp + 36], a1688
103:	

qsort$23:	; call function noellipse-noellipse swap
104:		mov word [bp + 26], qsort$24
105:		mov [bp + 28], bp
106:		add bp, 26
107:		jmp swap
109:	

qsort$24:	; post call
111:	

qsort$25:	; update = 1
112:		mov word [bp + 14], 1
114:	

qsort$26:	; ++index2
115:		inc word [bp + 20]
117:	

qsort$27:	; goto 6
118:		jmp qsort$6
120:	

qsort$28:	; if update == 0 goto 31
121:		cmp word [bp + 14], 0
122:		je qsort$31
124:	

qsort$29:	; --index1
125:		dec word [bp + 18]
127:	

qsort$30:	; goto 3
128:		jmp qsort$3
130:	

qsort$31:	; return
131:		mov t1689, [bp]
132:		mov di, [bp + 4]
133:		mov bp, [bp + 2]
134:		jmp t1689
136:	

qsort$32:	; function end qsort
1:	

abs:	; if value >= 0 goto 4
2:		cmp word [bp + 6], 0
3:		jge abs$4
5:	

abs$1:	; £temporary2526 = -value
6:		mov a1690, [bp + 6]
7:		neg a1690
9:	

abs$2:	; £temporary2530 = £temporary2526
11:	

abs$3:	; goto 5
12:		jmp abs$5
14:	

abs$4:	; £temporary2530 = value
15:		mov t1692, [bp + 6]
17:	

abs$5:	; return_value = £temporary2530
19:	

abs$6:	; return
20:		mov t1693, [bp]
21:		mov di, [bp + 4]
22:		mov bp, [bp + 2]
23:		jmp t1693
25:	

abs$7:	; function end abs
1:	

labs:	; if value >= 0 goto 4
2:		cmp dword [bp + 6], 0
3:		jge labs$4
5:	

labs$1:	; £temporary2532 = -value
6:		mov a1694, [bp + 6]
7:		neg a1694
9:	

labs$2:	; £temporary2536 = £temporary2532
11:	

labs$3:	; goto 5
12:		jmp labs$5
14:	

labs$4:	; £temporary2536 = value
15:		mov t1696, [bp + 6]
17:	

labs$5:	; return_value = £temporary2536
19:	

labs$6:	; return
20:		mov t1697, [bp]
21:		mov di, [bp + 4]
22:		mov bp, [bp + 2]
23:		jmp t1697
25:	

labs$7:	; function end labs
1:	

div:	; result$quot = 0
2:		mov word [bp + 10], 0
4:	

div$1:	; result$rem = 0
5:		mov word [bp + 12], 0
7:	

div$2:	; if denum != 0 goto 6
8:		cmp word [bp + 8], 0
9:		jne div$6
11:	

div$3:	; errno = 6
12:		mov word [errno], 6
14:	

div$4:	; return_value = result
15:		mov t1698, bp
16:		add t1698, 10
18:	

div$5:	; return
19:		mov t1699, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp t1699
24:	

div$6:	; result$quot = num / denum
25:		mov a1700, [bp + 6]
27:		xor dx, dx
28:		idiv word [bp + 8]
29:		mov [bp + 10], ax
31:	

div$7:	; result$rem = num % denum
32:		mov a1703, [bp + 6]
34:		xor dx, dx
35:		idiv word [bp + 8]
36:		mov [bp + 12], dx
38:	

div$8:	; return_value = result
39:		mov t1705, bp
40:		add t1705, 10
42:	

div$9:	; return
43:		mov t1706, [bp]
44:		mov di, [bp + 4]
45:		mov bp, [bp + 2]
46:		jmp t1706
48:	

div$10:	; function end div
1:	

ldiv:	; result$quot = 0
2:		mov dword [bp + 14], 0
4:	

ldiv$1:	; result$rem = 0
5:		mov dword [bp + 18], 0
7:	

ldiv$2:	; if denum != 0 goto 6
8:		cmp dword [bp + 10], 0
9:		jne ldiv$6
11:	

ldiv$3:	; errno = 6
12:		mov word [errno], 6
14:	

ldiv$4:	; return_value = result
15:		mov t1707, bp
16:		add t1707, 14
18:	

ldiv$5:	; return
19:		mov t1708, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp t1708
24:	

ldiv$6:	; result$quot = num / denum
25:		mov a1709, [bp + 6]
27:		xor edx, edx
28:		idiv dword [bp + 10]
29:		mov [bp + 14], eax
31:	

ldiv$7:	; result$rem = num % denum
32:		mov a1712, [bp + 6]
34:		xor edx, edx
35:		idiv dword [bp + 10]
36:		mov [bp + 18], edx
38:	

ldiv$8:	; return_value = result
39:		mov t1714, bp
40:		add t1714, 14
42:	

ldiv$9:	; return
43:		mov t1715, [bp]
44:		mov di, [bp + 4]
45:		mov bp, [bp + 2]
46:		jmp t1715
48:	

ldiv$10:	; function end ldiv
