1:	

clock:	; return_value = -1
2:		mov a1835, -1
4:	

clock$1:	; return
5:		mov t1836, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp t1836
10:	

clock$2:	; function end clock
1:	

time:	; ah = 42
2:		mov a1837, 42
4:	

time$1:	; interrupt 33
5:		int 33
7:	

time$2:	; £temporary2786 = cx
9:	

time$3:	; year = £temporary2786 - 1900
10:		sub t1838, 1900
11:		mov [bp + 12], t1838
13:	

time$4:	; £temporary2788 = dh
15:	

time$5:	; month = £temporary2788 - 1
16:		sub t1839, 1
17:		mov [bp + 14], t1839
19:	

time$6:	; £temporary2790 = dl
21:	

time$7:	; monthDay = £temporary2790
22:		mov [bp + 15], t1840
24:	

time$8:	; ah = 44
25:		mov a1841, 44
27:	

time$9:	; interrupt 33
28:		int 33
30:	

time$10:	; £temporary2792 = ch
32:	

time$11:	; hour = £temporary2792
33:		mov [bp + 16], t1842
35:	

time$12:	; £temporary2793 = cl
37:	

time$13:	; min = £temporary2793
38:		mov [bp + 17], t1843
40:	

time$14:	; £temporary2794 = dh
42:	

time$15:	; sec = £temporary2794
43:		mov [bp + 18], t1844
45:	

time$16:	; £temporary2795 = year % 4
46:		mov a1845, [bp + 12]
48:		xor dx, dx
49:		idiv word [int2$4#]
55:	

time$17:	; if £temporary2795 != 0 goto 20
56:		cmp t1847, 0
57:		jne time$20
59:	

time$18:	; £temporary2797 = 1
60:		mov t1848, 1
62:	

time$19:	; goto 21
63:		jmp time$21
65:	

time$20:	; £temporary2797 = 0
66:		mov t1849, 0
68:	

time$21:	; leapYear = £temporary2797
69:		mov [bp + 19], t1849
71:	

time$22:	; daysOfMonths[0] = 31
72:		mov word [bp + 21], 31
74:	

time$23:	; if leapYear == 0 goto 26
75:		cmp word [bp + 19], 0
76:		je time$26
78:	

time$24:	; £temporary2802 = 29
79:		mov t1850, 29
81:	

time$25:	; goto 27
82:		jmp time$27
84:	

time$26:	; £temporary2802 = 28
85:		mov t1851, 28
87:	

time$27:	; daysOfMonths[1] = £temporary2802
88:		mov [bp + 23], t1851
90:	

time$28:	; daysOfMonths[2] = 31
91:		mov word [bp + 25], 31
93:	

time$29:	; daysOfMonths[3] = 30
94:		mov word [bp + 27], 30
96:	

time$30:	; daysOfMonths[4] = 31
97:		mov word [bp + 29], 31
99:	

time$31:	; daysOfMonths[5] = 30
100:		mov word [bp + 31], 30
102:	

time$32:	; daysOfMonths[6] = 30
103:		mov word [bp + 33], 30
105:	

time$33:	; daysOfMonths[7] = 31
106:		mov word [bp + 35], 31
108:	

time$34:	; daysOfMonths[8] = 30
109:		mov word [bp + 37], 30
111:	

time$35:	; daysOfMonths[9] = 31
112:		mov word [bp + 39], 31
114:	

time$36:	; daysOfMonths[10] = 30
115:		mov word [bp + 41], 30
117:	

time$37:	; daysOfMonths[11] = 31
118:		mov word [bp + 43], 31
120:	

time$38:	; £temporary2815 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
121:		mov a1852, [bp + 15]
123:		and a1852, 255
125:		cmp a1852, 0
126:		jge time$39
127:		neg a1852
129:		neg a1852
131:	

time$39:	; yearDay = £temporary2815 - 1
132:		sub a1852, 1
133:		mov [bp + 45], a1852
135:	

time$40:	; mon = 0
136:		mov word [bp + 47], 0
138:	

time$41:	; £temporary2817 = int_to_int month (Signed_Short_Int -> Signed_Int)
139:		mov a1853, [bp + 14]
141:		and a1853, 255
143:		cmp a1853, 0
144:		jge time$42
145:		neg a1853
147:		neg a1853
149:	

time$42:	; if mon >= £temporary2817 goto 49
150:		cmp [bp + 47], a1853
151:		jge time$49
153:	

time$43:	; £temporary2821 = mon * 2
154:		mov a1854, [bp + 47]
156:		xor dx, dx
157:		mul word [int2$2#]
163:	

time$44:	; £temporary2822 = daysOfMonths + £temporary2821
164:		mov a1858, bp
165:		add a1858, 21
166:		add a1858, t1857
168:	

time$45:	; £temporary2820 -> £temporary2822 = *£temporary2822
170:	

time$46:	; yearDay = yearDay + £temporary2820 -> £temporary2822
171:		mov t1859, [a1858]
172:		add [bp + 45], t1859
174:	

time$47:	; ++mon
175:		inc word [bp + 47]
177:	

time$48:	; goto 41
178:		jmp time$41
180:	

time$49:	; £temporary2825 = int_to_int sec (Signed_Short_Int -> Signed_Int)
181:		mov a1860, [bp + 18]
183:		and a1860, 255
185:		cmp a1860, 0
186:		jge time$50
187:		neg a1860
189:		neg a1860
191:	

time$50:	; s$tm_sec = £temporary2825
192:		mov [bp + 49], a1860
194:	

time$51:	; £temporary2827 = int_to_int min (Signed_Short_Int -> Signed_Int)
195:		mov a1861, [bp + 17]
197:		and a1861, 255
199:		cmp a1861, 0
200:		jge time$52
201:		neg a1861
203:		neg a1861
205:	

time$52:	; s$tm_min = £temporary2827
206:		mov [bp + 51], a1861
208:	

time$53:	; £temporary2829 = int_to_int hour (Signed_Short_Int -> Signed_Int)
209:		mov a1862, [bp + 16]
211:		and a1862, 255
213:		cmp a1862, 0
214:		jge time$54
215:		neg a1862
217:		neg a1862
219:	

time$54:	; s$tm_hour = £temporary2829
220:		mov [bp + 53], a1862
222:	

time$55:	; £temporary2831 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
223:		mov a1863, [bp + 15]
225:		and a1863, 255
227:		cmp a1863, 0
228:		jge time$56
229:		neg a1863
231:		neg a1863
233:	

time$56:	; s$tm_mday = £temporary2831
234:		mov [bp + 55], a1863
236:	

time$57:	; £temporary2833 = int_to_int month (Signed_Short_Int -> Signed_Int)
237:		mov a1864, [bp + 14]
239:		and a1864, 255
241:		cmp a1864, 0
242:		jge time$58
243:		neg a1864
245:		neg a1864
247:	

time$58:	; s$tm_mon = £temporary2833
248:		mov [bp + 57], a1864
250:	

time$59:	; s$tm_year = year
251:		mov a1865, [bp + 12]
252:		mov [bp + 59], a1865
254:	

time$60:	; s$tm_wday = 0
255:		mov word [bp + 61], 0
257:	

time$61:	; s$tm_yday = yearDay
258:		mov a1866, [bp + 45]
259:		mov [bp + 63], a1866
261:	

time$62:	; s$tm_isdst = 0
262:		mov word [bp + 65], 0
264:	

time$63:	; call header integral zero 0 stack zero 0
266:	

time$64:	; £temporary2838 = &s
267:		mov t1867, bp
268:		add t1867, 49
270:	

time$65:	; parameter £temporary2838, offset 6
271:		mov [bp + 73], t1867
273:	

time$66:	; call function noellipse-noellipse mktime
274:		mov word [bp + 67], time$67
275:		mov [bp + 69], bp
276:		add bp, 67
277:		jmp mktime
279:	

time$67:	; post call
281:	

time$68:	; £temporary2839 = return_value
286:	

time$69:	; time = £temporary2839
287:		mov [bp + 8], t1869
289:	

time$70:	; if timePtr == 0 goto 73
290:		cmp word [bp + 6], 0
291:		je time$73
293:	

time$71:	; £temporary2841 -> timePtr = *timePtr
294:		mov a1870, [bp + 6]
296:	

time$72:	; £temporary2841 -> timePtr = time
297:		mov a1871, [bp + 8]
298:		mov [a1870], a1871
300:	

time$73:	; return_value = time
301:		mov a1872, [bp + 8]
303:	

time$74:	; return
304:		mov t1873, [bp]
305:		mov di, [bp + 4]
306:		mov bp, [bp + 2]
307:		jmp t1873
309:	

time$75:	; function end time
1:	

mktime:	; if tp == 0 goto 28
2:		cmp word [bp + 6], 0
3:		je mktime$28
5:	

mktime$1:	; £temporary2845 -> tp = *tp, offset 10
6:		mov a1874, [bp + 6]
8:	

mktime$2:	; £temporary2846 = £temporary2845 -> tp - 69
9:		mov t1875, [a1874 + 10]
10:		sub t1875, 69
12:	

mktime$3:	; £temporary2847 = £temporary2846 / 4
14:		xor dx, dx
15:		idiv word [int2$4#]
21:	

mktime$4:	; £temporary2848 = int_to_int £temporary2847 (Signed_Int -> Signed_Long_Int)
23:		and t1878, 65535
25:		cmp t1878, 0
26:		jge mktime$5
27:		neg t1878
29:		neg t1878
31:	

mktime$5:	; leapDays = £temporary2848
32:		mov [bp + 8], t1878
34:	

mktime$6:	; £temporary2849 -> tp = *tp, offset 10
35:		mov a1879, [bp + 6]
37:	

mktime$7:	; £temporary2850 = £temporary2849 -> tp - 70
38:		mov t1880, [a1879 + 10]
39:		sub t1880, 70
41:	

mktime$8:	; £temporary2851 = £temporary2850 * 365
43:		xor dx, dx
44:		imul word [int2$365#]
50:	

mktime$9:	; £temporary2852 = int_to_int £temporary2851 (Signed_Int -> Signed_Long_Int)
52:		and t1883, 65535
54:		cmp t1883, 0
55:		jge mktime$10
56:		neg t1883
58:		neg t1883
60:	

mktime$10:	; £temporary2853 = £temporary2852 + leapDays
61:		add t1883, [bp + 8]
63:	

mktime$11:	; £temporary2854 -> tp = *tp, offset 14
64:		mov a1884, [bp + 6]
66:	

mktime$12:	; £temporary2855 = int_to_int £temporary2854 -> tp (Signed_Int -> Signed_Long_Int)
67:		mov t1885, [a1884 + 14]
69:		and t1885, 65535
71:		cmp t1885, 0
72:		jge mktime$13
73:		neg t1885
75:		neg t1885
77:	

mktime$13:	; totalDays = £temporary2853 + £temporary2855
78:		add t1883, t1885
79:		mov [bp + 12], t1883
81:	

mktime$14:	; £temporary2857 = totalDays * 86400
82:		mov a1886, [bp + 12]
84:		xor edx, edx
85:		imul dword [int4$86400#]
91:		mov t1892, t1889
93:	

mktime$15:	; £temporary2858 -> tp = *tp, offset 4
94:		mov a1890, [bp + 6]
96:	

mktime$16:	; £temporary2859 = int_to_int £temporary2858 -> tp (Signed_Int -> Signed_Long_Int)
97:		mov t1891, [a1890 + 4]
99:		and t1891, 65535
101:		cmp t1891, 0
102:		jge mktime$17
103:		neg t1891
105:		neg t1891
107:	

mktime$17:	; £temporary2860 = £temporary2859 * 3600
109:		xor edx, edx
110:		imul dword [int4$3600#]
116:	

mktime$18:	; £temporary2861 = £temporary2857 + £temporary2860
117:		add t1892, t1895
119:	

mktime$19:	; £temporary2862 -> tp = *tp, offset 2
120:		mov a1896, [bp + 6]
122:	

mktime$20:	; £temporary2863 = int_to_int £temporary2862 -> tp (Signed_Int -> Signed_Long_Int)
123:		mov t1897, [a1896 + 2]
125:		and t1897, 65535
127:		cmp t1897, 0
128:		jge mktime$21
129:		neg t1897
131:		neg t1897
133:	

mktime$21:	; £temporary2864 = £temporary2863 * 60
135:		xor edx, edx
136:		imul dword [int4$60#]
142:	

mktime$22:	; £temporary2865 = £temporary2861 + £temporary2864
143:		add t1892, t1900
145:	

mktime$23:	; £temporary2866 -> tp = *tp
146:		mov a1901, [bp + 6]
148:	

mktime$24:	; £temporary2867 = int_to_int £temporary2866 -> tp (Signed_Int -> Signed_Long_Int)
149:		mov t1902, [a1901]
151:		and t1902, 65535
153:		cmp t1902, 0
154:		jge mktime$25
155:		neg t1902
157:		neg t1902
159:	

mktime$25:	; £temporary2868 = £temporary2865 + £temporary2867
160:		add t1892, t1902
162:	

mktime$26:	; return_value = £temporary2868
164:	

mktime$27:	; return
165:		mov t1903, [bp]
166:		mov di, [bp + 4]
167:		mov bp, [bp + 2]
168:		jmp t1903
170:	

mktime$28:	; return_value = 0
171:		mov a1904, 0
173:	

mktime$29:	; return
174:		mov t1905, [bp]
175:		mov di, [bp + 4]
176:		mov bp, [bp + 2]
177:		jmp t1905
179:	

mktime$30:	; function end mktime
1:	

gmtime:	; year = 1970
2:		mov word [bp + 8], 1970
4:	

gmtime$1:	; if timePtr == 0 goto 86
5:		cmp word [bp + 6], 0
6:		je gmtime$86
8:	

gmtime$2:	; £temporary2870 -> timePtr = *timePtr
9:		mov a1906, [bp + 6]
11:	

gmtime$3:	; time = £temporary2870 -> timePtr
12:		mov t1907, [a1906]
13:		mov [bp + 10], t1907
15:	

gmtime$4:	; secondsOfDay = time % 86400
16:		mov a1908, [bp + 10]
18:		xor edx, edx
19:		idiv dword [int4$86400#]
20:		mov [bp + 14], edx
22:	

gmtime$5:	; £temporary2873 = secondsOfDay / 3600
23:		mov a1910, [bp + 14]
25:		xor edx, edx
26:		idiv dword [int4$3600#]
32:	

gmtime$6:	; £temporary2874 = int_to_int £temporary2873 (Signed_Long_Int -> Signed_Int)
35:		cmp t1913, 0
36:		jge gmtime$7
37:		neg t1913
39:		neg t1913
41:	

gmtime$7:	; g_timeStruct$tm_hour = £temporary2874
42:		mov [@28$g_timeStruct + 4], t1913
44:	

gmtime$8:	; £temporary2876 = secondsOfDay % 3600
45:		mov a1914, [bp + 14]
47:		xor edx, edx
48:		idiv dword [int4$3600#]
54:	

gmtime$9:	; £temporary2877 = £temporary2876 / 60
55:		mov t1917, t1916
57:		xor edx, edx
58:		idiv dword [int4$60#]
64:	

gmtime$10:	; £temporary2878 = int_to_int £temporary2877 (Signed_Long_Int -> Signed_Int)
67:		cmp t1920, 0
68:		jge gmtime$11
69:		neg t1920
71:		neg t1920
73:	

gmtime$11:	; g_timeStruct$tm_min = £temporary2878
74:		mov [@28$g_timeStruct + 2], t1920
76:	

gmtime$12:	; £temporary2880 = secondsOfDay % 3600
77:		mov a1921, [bp + 14]
79:		xor edx, edx
80:		idiv dword [int4$3600#]
86:	

gmtime$13:	; £temporary2881 = £temporary2880 % 60
87:		mov t1924, t1923
89:		xor edx, edx
90:		idiv dword [int4$60#]
96:	

gmtime$14:	; £temporary2882 = int_to_int £temporary2881 (Signed_Long_Int -> Signed_Int)
99:		cmp t1926, 0
100:		jge gmtime$15
101:		neg t1926
103:		neg t1926
105:	

gmtime$15:	; g_timeStruct$tm_sec = £temporary2882
106:		mov [@28$g_timeStruct], t1926
108:	

gmtime$16:	; totalDays = time / 86400
109:		mov a1927, [bp + 10]
111:		xor edx, edx
112:		idiv dword [int4$86400#]
113:		mov [bp + 18], eax
115:	

gmtime$17:	; if totalDays >= 3 goto 22
116:		cmp dword [bp + 18], 3
117:		jge gmtime$22
119:	

gmtime$18:	; £temporary2886 = totalDays + 4
120:		mov a1930, [bp + 18]
121:		add a1930, 4
123:	

gmtime$19:	; £temporary2887 = int_to_int £temporary2886 (Signed_Long_Int -> Signed_Int)
126:		cmp a1930, 0
127:		jge gmtime$20
128:		neg a1930
130:		neg a1930
132:	

gmtime$20:	; g_timeStruct$tm_wday = £temporary2887
133:		mov [@28$g_timeStruct + 12], a1930
135:	

gmtime$21:	; goto 26
136:		jmp gmtime$26
138:	

gmtime$22:	; £temporary2889 = totalDays - 3
139:		mov a1931, [bp + 18]
140:		sub a1931, 3
142:	

gmtime$23:	; £temporary2890 = £temporary2889 % 7
144:		xor edx, edx
145:		idiv dword [int4$7#]
151:	

gmtime$24:	; £temporary2891 = int_to_int £temporary2890 (Signed_Long_Int -> Signed_Int)
154:		cmp t1933, 0
155:		jge gmtime$25
156:		neg t1933
158:		neg t1933
160:	

gmtime$25:	; g_timeStruct$tm_wday = £temporary2891
161:		mov [@28$g_timeStruct + 12], t1933
163:	

gmtime$26:	; £temporary2892 = year % 4
164:		mov a1934, [bp + 8]
166:		xor dx, dx
167:		idiv word [int2$4#]
173:	

gmtime$27:	; if £temporary2892 != 0 goto 30
174:		cmp t1936, 0
175:		jne gmtime$30
177:	

gmtime$28:	; £temporary2894 = year % 100
178:		mov a1937, [bp + 8]
180:		xor dx, dx
181:		idiv word [int2$100#]
187:	

gmtime$29:	; if £temporary2894 != 0 goto 32
188:		cmp t1939, 0
189:		jne gmtime$32
191:	

gmtime$30:	; £temporary2897 = year % 400
192:		mov a1940, [bp + 8]
194:		xor dx, dx
195:		idiv word [int2$400#]
201:	

gmtime$31:	; if £temporary2897 != 0 goto 34
202:		cmp t1942, 0
203:		jne gmtime$34
205:	

gmtime$32:	; £temporary2900 = 1
206:		mov t1943, 1
208:	

gmtime$33:	; goto 35
209:		jmp gmtime$35
211:	

gmtime$34:	; £temporary2900 = 0
212:		mov t1944, 0
214:	

gmtime$35:	; leapYear = £temporary2900
215:		mov [bp + 22], t1944
217:	

gmtime$36:	; if leapYear == 0 goto 39
218:		cmp word [bp + 22], 0
219:		je gmtime$39
221:	

gmtime$37:	; £temporary2905 = 366
222:		mov t1945, 366
224:	

gmtime$38:	; goto 40
225:		jmp gmtime$40
227:	

gmtime$39:	; £temporary2905 = 365
228:		mov t1946, 365
230:	

gmtime$40:	; daysOfYear = £temporary2905
231:		mov [bp + 24], t1946
233:	

gmtime$41:	; £temporary2906 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
234:		mov a1947, [bp + 24]
236:		and a1947, 65535
238:		cmp a1947, 0
239:		jge gmtime$42
240:		neg a1947
242:		neg a1947
244:	

gmtime$42:	; if totalDays >= £temporary2906 goto 82
245:		cmp [bp + 18], a1947
246:		jge gmtime$82
248:	

gmtime$43:	; g_timeStruct$tm_year = year - 1900
249:		mov a1948, [bp + 8]
250:		sub a1948, 1900
251:		mov [@28$g_timeStruct], a1948
253:	

gmtime$44:	; £temporary2911 = int_to_int totalDays (Signed_Long_Int -> Signed_Int)
254:		mov a1949, [bp + 18]
257:		cmp a1949, 0
258:		jge gmtime$45
259:		neg a1949
261:		neg a1949
263:	

gmtime$45:	; g_timeStruct$tm_yday = £temporary2911
264:		mov [@28$g_timeStruct + 14], a1949
266:	

gmtime$46:	; daysOfMonths[0] = 31
267:		mov word [bp + 26], 31
269:	

gmtime$47:	; if leapYear == 0 goto 50
270:		cmp word [bp + 22], 0
271:		je gmtime$50
273:	

gmtime$48:	; £temporary2916 = 29
274:		mov t1950, 29
276:	

gmtime$49:	; goto 51
277:		jmp gmtime$51
279:	

gmtime$50:	; £temporary2916 = 28
280:		mov t1951, 28
282:	

gmtime$51:	; daysOfMonths[1] = £temporary2916
283:		mov [bp + 28], t1951
285:	

gmtime$52:	; daysOfMonths[2] = 31
286:		mov word [bp + 30], 31
288:	

gmtime$53:	; daysOfMonths[3] = 30
289:		mov word [bp + 32], 30
291:	

gmtime$54:	; daysOfMonths[4] = 31
292:		mov word [bp + 34], 31
294:	

gmtime$55:	; daysOfMonths[5] = 30
295:		mov word [bp + 36], 30
297:	

gmtime$56:	; daysOfMonths[6] = 30
298:		mov word [bp + 38], 30
300:	

gmtime$57:	; daysOfMonths[7] = 31
301:		mov word [bp + 40], 31
303:	

gmtime$58:	; daysOfMonths[8] = 30
304:		mov word [bp + 42], 30
306:	

gmtime$59:	; daysOfMonths[9] = 31
307:		mov word [bp + 44], 31
309:	

gmtime$60:	; daysOfMonths[10] = 30
310:		mov word [bp + 46], 30
312:	

gmtime$61:	; daysOfMonths[11] = 31
313:		mov word [bp + 48], 31
315:	

gmtime$62:	; month = 0
316:		mov word [bp + 50], 0
318:	

gmtime$63:	; £temporary2930 = month * 2
319:		mov a1952, [bp + 50]
321:		xor dx, dx
322:		mul word [int2$2#]
328:	

gmtime$64:	; £temporary2931 = daysOfMonths + £temporary2930
329:		mov a1956, bp
330:		add a1956, 26
331:		add a1956, t1955
333:	

gmtime$65:	; £temporary2929 -> £temporary2931 = *£temporary2931
335:	

gmtime$66:	; £temporary2932 = int_to_int £temporary2929 -> £temporary2931 (Signed_Int -> Signed_Long_Int)
336:		mov t1957, [a1956]
338:		and t1957, 65535
340:		cmp t1957, 0
341:		jge gmtime$67
342:		neg t1957
344:		neg t1957
346:	

gmtime$67:	; if totalDays < £temporary2932 goto 75
347:		cmp [bp + 18], t1957
348:		jl gmtime$75
350:	

gmtime$68:	; £temporary2935 = month * 2
351:		mov a1958, [bp + 50]
353:		xor dx, dx
354:		mul word [int2$2#]
360:	

gmtime$69:	; £temporary2936 = daysOfMonths + £temporary2935
361:		mov a1962, bp
362:		add a1962, 26
363:		add a1962, t1961
365:	

gmtime$70:	; £temporary2934 -> £temporary2936 = *£temporary2936
367:	

gmtime$71:	; £temporary2937 = int_to_int £temporary2934 -> £temporary2936 (Signed_Int -> Signed_Long_Int)
368:		mov t1963, [a1962]
370:		and t1963, 65535
372:		cmp t1963, 0
373:		jge gmtime$72
374:		neg t1963
376:		neg t1963
378:	

gmtime$72:	; totalDays = totalDays - £temporary2937
379:		sub [bp + 18], t1963
381:	

gmtime$73:	; ++month
382:		inc word [bp + 50]
384:	

gmtime$74:	; goto 63
385:		jmp gmtime$63
387:	

gmtime$75:	; g_timeStruct$tm_mon = month
388:		mov a1964, [bp + 50]
389:		mov [@28$g_timeStruct + 8], a1964
391:	

gmtime$76:	; £temporary2942 = totalDays + 1
392:		mov a1965, [bp + 18]
393:		add a1965, 1
395:	

gmtime$77:	; £temporary2943 = int_to_int £temporary2942 (Signed_Long_Int -> Signed_Int)
398:		cmp a1965, 0
399:		jge gmtime$78
400:		neg a1965
402:		neg a1965
404:	

gmtime$78:	; g_timeStruct$tm_mday = £temporary2943
405:		mov [@28$g_timeStruct + 6], a1965
407:	

gmtime$79:	; g_timeStruct$tm_isdst = -1
408:		mov word [@28$g_timeStruct + 16], -1
410:	

gmtime$80:	; return_value = (@28$g_timeStruct,0)
411:		mov a1966, @28$g_timeStruct
413:	

gmtime$81:	; return
414:		mov t1967, [bp]
415:		mov di, [bp + 4]
416:		mov bp, [bp + 2]
417:		jmp t1967
419:	

gmtime$82:	; ++year
420:		inc word [bp + 8]
422:	

gmtime$83:	; £temporary2946 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
423:		mov a1968, [bp + 24]
425:		and a1968, 65535
427:		cmp a1968, 0
428:		jge gmtime$84
429:		neg a1968
431:		neg a1968
433:	

gmtime$84:	; totalDays = totalDays - £temporary2946
434:		sub [bp + 18], a1968
436:	

gmtime$85:	; goto 26
437:		jmp gmtime$26
439:	

gmtime$86:	; return_value = 0
440:		mov a1969, 0
442:	

gmtime$87:	; return
443:		mov t1970, [bp]
444:		mov di, [bp + 4]
445:		mov bp, [bp + 2]
446:		jmp t1970
448:	

gmtime$88:	; function end gmtime
1:	

difftime:	; £temporary2949 = time2 - time1
2:		mov a1971, [bp + 10]
3:		sub a1971, [bp + 6]
5:	

difftime$1:	; £temporary2950 = int_to_float £temporary2949 (Unsigned_Long_Int -> Double)
6:		mov [container4bytes#], a1971
7:		fild dword [container4bytes#]
9:	

difftime$2:	; return_value = £temporary2950
11:	

difftime$3:	; return
12:		mov t1972, [bp]
13:		mov di, [bp + 4]
14:		mov bp, [bp + 2]
15:		jmp t1972
17:	

difftime$4:	; function end difftime
1:	

asctime:	; localeConvPtr = 0
2:		mov word [bp + 8], 0
4:	

asctime$1:	; if localeConvPtr == 0 goto 5
5:		cmp word [bp + 8], 0
6:		je asctime$5
8:	

asctime$2:	; £temporary2952 -> localeConvPtr = *localeConvPtr, offset 4
9:		mov a1973, [bp + 8]
11:	

asctime$3:	; £temporary2956 = £temporary2952 -> localeConvPtr
12:		mov t1974, [a1973 + 4]
14:	

asctime$4:	; goto 6
15:		jmp asctime$6
17:	

asctime$5:	; £temporary2956 = 0
18:		mov t1975, 0
20:	

asctime$6:	; shortDayList = £temporary2956
21:		mov [bp + 10], t1975
23:	

asctime$7:	; if localeConvPtr == 0 goto 11
24:		cmp word [bp + 8], 0
25:		je asctime$11
27:	

asctime$8:	; £temporary2958 -> localeConvPtr = *localeConvPtr, offset 8
28:		mov a1976, [bp + 8]
30:	

asctime$9:	; £temporary2962 = £temporary2958 -> localeConvPtr
31:		mov t1977, [a1976 + 8]
33:	

asctime$10:	; goto 12
34:		jmp asctime$12
36:	

asctime$11:	; £temporary2962 = 0
37:		mov t1978, 0
39:	

asctime$12:	; shortMonthList = £temporary2962
40:		mov [bp + 12], t1978
42:	

asctime$13:	; if shortDayList == 0 goto 16
43:		cmp word [bp + 10], 0
44:		je asctime$16
46:	

asctime$14:	; £temporary2967 = shortDayList
47:		mov t1979, [bp + 10]
49:	

asctime$15:	; goto 17
50:		jmp asctime$17
52:	

asctime$16:	; £temporary2967 = g_defaultShortDayList
53:		mov t1980, @30$g_defaultShortDayList
55:	

asctime$17:	; shortDayList = £temporary2967
56:		mov [bp + 10], t1980
58:	

asctime$18:	; if shortMonthList == 0 goto 21
59:		cmp word [bp + 12], 0
60:		je asctime$21
62:	

asctime$19:	; £temporary2972 = shortMonthList
63:		mov t1981, [bp + 12]
65:	

asctime$20:	; goto 22
66:		jmp asctime$22
68:	

asctime$21:	; £temporary2972 = g_defaultShortMonthList
69:		mov t1982, @32$g_defaultShortMonthList
71:	

asctime$22:	; shortMonthList = £temporary2972
72:		mov [bp + 12], t1982
74:	

asctime$23:	; call header integral zero 0 stack zero 0
76:	

asctime$24:	; parameter g_timeString, offset 6
77:		mov word [bp + 20], @29$g_timeString
79:	

asctime$25:	; parameter string_25s2025s20252i202502i3A2502i3A2502i202504i#, offset 8
80:		mov word [bp + 22], string_25s2025s20252i202502i3A2502i3A2502i202504i#
82:	

asctime$26:	; £temporary2973 -> tp = *tp, offset 12
83:		mov a1983, [bp + 6]
85:	

asctime$27:	; £temporary2975 = £temporary2973 -> tp * 2
86:		mov t1984, [a1983 + 12]
88:		xor dx, dx
89:		mul word [int2$2#]
95:	

asctime$28:	; £temporary2976 = shortDayList + £temporary2975
96:		mov a1988, [bp + 10]
97:		add a1988, t1987
99:	

asctime$29:	; £temporary2974 -> £temporary2976 = *£temporary2976
101:	

asctime$30:	; parameter £temporary2974 -> £temporary2976, offset 10
102:		mov t1989, [a1988]
103:		mov [bp + 24], t1989
105:	

asctime$31:	; £temporary2977 -> tp = *tp, offset 8
106:		mov a1990, [bp + 6]
108:	

asctime$32:	; £temporary2979 = £temporary2977 -> tp * 2
109:		mov t1991, [a1990 + 8]
111:		xor dx, dx
112:		mul word [int2$2#]
118:	

asctime$33:	; £temporary2980 = shortMonthList + £temporary2979
119:		mov a1995, [bp + 12]
120:		add a1995, t1994
122:	

asctime$34:	; £temporary2978 -> £temporary2980 = *£temporary2980
124:	

asctime$35:	; parameter £temporary2978 -> £temporary2980, offset 12
125:		mov t1996, [a1995]
126:		mov [bp + 26], t1996
128:	

asctime$36:	; £temporary2981 -> tp = *tp, offset 6
129:		mov a1997, [bp + 6]
131:	

asctime$37:	; parameter £temporary2981 -> tp, offset 14
132:		mov t1998, [a1997 + 6]
133:		mov [bp + 28], t1998
135:	

asctime$38:	; £temporary2982 -> tp = *tp, offset 4
136:		mov a1999, [bp + 6]
138:	

asctime$39:	; parameter £temporary2982 -> tp, offset 16
139:		mov t2000, [a1999 + 4]
140:		mov [bp + 30], t2000
142:	

asctime$40:	; £temporary2983 -> tp = *tp, offset 2
143:		mov a2001, [bp + 6]
145:	

asctime$41:	; parameter £temporary2983 -> tp, offset 18
146:		mov t2002, [a2001 + 2]
147:		mov [bp + 32], t2002
149:	

asctime$42:	; £temporary2984 -> tp = *tp
150:		mov a2003, [bp + 6]
152:	

asctime$43:	; parameter £temporary2984 -> tp, offset 20
153:		mov t2004, [a2003]
154:		mov [bp + 34], t2004
156:	

asctime$44:	; £temporary2985 -> tp = *tp, offset 10
157:		mov a2005, [bp + 6]
159:	

asctime$45:	; £temporary2986 = £temporary2985 -> tp + 1900
160:		mov t2006, [a2005 + 10]
161:		add t2006, 1900
163:	

asctime$46:	; parameter £temporary2986, offset 22
164:		mov [bp + 36], t2006
166:	

asctime$47:	; call function noellipse-ellipse sprintf, extra 0
167:		mov word [bp + 14], asctime$48
168:		mov [bp + 16], bp
169:		add bp, 14
170:		mov di, bp
171:		add di, 14
172:		jmp sprintf
174:	

asctime$48:	; post call
176:	

asctime$49:	; return_value = g_timeString
177:		mov a2007, @29$g_timeString
179:	

asctime$50:	; return
180:		mov t2008, [bp]
181:		mov di, [bp + 4]
182:		mov bp, [bp + 2]
183:		jmp t2008
185:	

asctime$51:	; function end asctime
1:	

ctime:	; call header integral zero 0 stack zero 0
3:	

ctime$1:	; call header integral zero 0 stack zero 0
5:	

ctime$2:	; parameter time, offset 6
6:		mov a2009, [bp + 6]
7:		mov [bp + 14], a2009
9:	

ctime$3:	; call function noellipse-noellipse localtime
10:		mov word [bp + 8], ctime$4
11:		mov [bp + 10], bp
12:		add bp, 8
13:		jmp localtime
15:	

ctime$4:	; post call
17:	

ctime$5:	; £temporary2997 = return_value
22:	

ctime$6:	; parameter £temporary2997, offset 6
23:		mov [bp + 14], t2011
25:	

ctime$7:	; call function noellipse-noellipse asctime
26:		mov word [bp + 8], ctime$8
27:		mov [bp + 10], bp
28:		add bp, 8
29:		jmp asctime
31:	

ctime$8:	; post call
33:	

ctime$9:	; £temporary2998 = return_value
38:	

ctime$10:	; return_value = £temporary2998
40:	

ctime$11:	; return
41:		mov t2014, [bp]
42:		mov di, [bp + 4]
43:		mov bp, [bp + 2]
44:		jmp t2014
46:	

ctime$12:	; function end ctime
1:	

localtime:	; call header integral zero 0 stack zero 0
3:	

localtime$1:	; parameter timePtr, offset 6
4:		mov a2015, [bp + 6]
5:		mov [bp + 14], a2015
7:	

localtime$2:	; call function noellipse-noellipse gmtime
8:		mov word [bp + 8], localtime$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp gmtime
13:	

localtime$3:	; post call
15:	

localtime$4:	; £temporary3001 = return_value
20:	

localtime$5:	; tmPtr = £temporary3001
21:		mov [bp + 8], t2017
23:	

localtime$6:	; call header integral zero 0 stack zero 0
25:	

localtime$7:	; call function noellipse-noellipse localeconv
26:		mov word [bp + 10], localtime$8
27:		mov [bp + 12], bp
28:		add bp, 10
29:		jmp localeconv
31:	

localtime$8:	; post call
33:	

localtime$9:	; £temporary3002 = return_value
38:	

localtime$10:	; localeConvPtr = £temporary3002
39:		mov [bp + 10], t2019
41:	

localtime$11:	; timeZone = 0
42:		mov word [bp + 12], 0
44:	

localtime$12:	; if localeConvPtr == 0 goto 21
45:		cmp word [bp + 10], 0
46:		je localtime$21
48:	

localtime$13:	; £temporary3004 -> tmPtr = *tmPtr, offset 16
49:		mov a2020, [bp + 8]
51:	

localtime$14:	; if £temporary3004 -> tmPtr == 0 goto 18
52:		cmp word [a2020 + 16], 0
53:		je localtime$18
55:	

localtime$15:	; £temporary3005 -> localeConvPtr = *localeConvPtr
56:		mov a2021, [bp + 10]
58:	

localtime$16:	; £temporary3011 = £temporary3005 -> localeConvPtr
59:		mov t2022, [a2021]
61:	

localtime$17:	; goto 20
62:		jmp localtime$20
64:	

localtime$18:	; £temporary3006 -> localeConvPtr = *localeConvPtr, offset 2
65:		mov a2023, [bp + 10]
67:	

localtime$19:	; £temporary3011 = £temporary3006 -> localeConvPtr
68:		mov t2024, [a2023 + 2]
70:	

localtime$20:	; timeZone = £temporary3011
71:		mov [bp + 12], t2024
73:	

localtime$21:	; £temporary3012 -> timePtr = *timePtr
74:		mov a2025, [bp + 6]
76:	

localtime$22:	; £temporary3013 = timeZone * 3600
77:		mov a2026, [bp + 12]
79:		xor dx, dx
80:		imul word [int2$3600#]
86:	

localtime$23:	; £temporary3014 = int_to_int £temporary3013 (Signed_Int -> Unsigned_Long_Int)
88:		and t2029, 65535
90:	

localtime$24:	; time = £temporary3012 -> timePtr + £temporary3014
91:		mov t2030, [a2025]
92:		add t2030, t2029
93:		mov [bp + 14], t2030
95:	

localtime$25:	; call header integral zero 0 stack zero 0
97:	

localtime$26:	; £temporary3016 = &time
98:		mov t2031, bp
99:		add t2031, 14
101:	

localtime$27:	; parameter £temporary3016, offset 6
102:		mov [bp + 24], t2031
104:	

localtime$28:	; call function noellipse-noellipse gmtime
105:		mov word [bp + 18], localtime$29
106:		mov [bp + 20], bp
107:		add bp, 18
108:		jmp gmtime
110:	

localtime$29:	; post call
112:	

localtime$30:	; £temporary3017 = return_value
117:	

localtime$31:	; return_value = £temporary3017
119:	

localtime$32:	; return
120:		mov t2034, [bp]
121:		mov di, [bp + 4]
122:		mov bp, [bp + 2]
123:		jmp t2034
125:	

localtime$33:	; function end localtime
1:	

strftime:	; call header integral zero 0 stack zero 0
3:	

strftime$1:	; call function noellipse-noellipse localeconv
4:		mov word [bp + 14], strftime$2
5:		mov [bp + 16], bp
6:		add bp, 14
7:		jmp localeconv
9:	

strftime$2:	; post call
11:	

strftime$3:	; £temporary3021 = return_value
16:	

strftime$4:	; localeConvPtr = £temporary3021
17:		mov [bp + 14], t2036
19:	

strftime$5:	; if localeConvPtr == 0 goto 9
20:		cmp word [bp + 14], 0
21:		je strftime$9
23:	

strftime$6:	; £temporary3023 -> localeConvPtr = *localeConvPtr, offset 4
24:		mov a2037, [bp + 14]
26:	

strftime$7:	; £temporary3027 = £temporary3023 -> localeConvPtr
27:		mov t2038, [a2037 + 4]
29:	

strftime$8:	; goto 10
30:		jmp strftime$10
32:	

strftime$9:	; £temporary3027 = 0
33:		mov t2039, 0
35:	

strftime$10:	; shortDayList = £temporary3027
36:		mov [bp + 16], t2039
38:	

strftime$11:	; if localeConvPtr == 0 goto 15
39:		cmp word [bp + 14], 0
40:		je strftime$15
42:	

strftime$12:	; £temporary3029 -> localeConvPtr = *localeConvPtr, offset 8
43:		mov a2040, [bp + 14]
45:	

strftime$13:	; £temporary3033 = £temporary3029 -> localeConvPtr
46:		mov t2041, [a2040 + 8]
48:	

strftime$14:	; goto 16
49:		jmp strftime$16
51:	

strftime$15:	; £temporary3033 = 0
52:		mov t2042, 0
54:	

strftime$16:	; shortMonthList = £temporary3033
55:		mov [bp + 18], t2042
57:	

strftime$17:	; if localeConvPtr == 0 goto 21
58:		cmp word [bp + 14], 0
59:		je strftime$21
61:	

strftime$18:	; £temporary3035 -> localeConvPtr = *localeConvPtr, offset 6
62:		mov a2043, [bp + 14]
64:	

strftime$19:	; £temporary3039 = £temporary3035 -> localeConvPtr
65:		mov t2044, [a2043 + 6]
67:	

strftime$20:	; goto 22
68:		jmp strftime$22
70:	

strftime$21:	; £temporary3039 = 0
71:		mov t2045, 0
73:	

strftime$22:	; longDayList = £temporary3039
74:		mov [bp + 20], t2045
76:	

strftime$23:	; if localeConvPtr == 0 goto 27
77:		cmp word [bp + 14], 0
78:		je strftime$27
80:	

strftime$24:	; £temporary3041 -> localeConvPtr = *localeConvPtr, offset 10
81:		mov a2046, [bp + 14]
83:	

strftime$25:	; £temporary3045 = £temporary3041 -> localeConvPtr
84:		mov t2047, [a2046 + 10]
86:	

strftime$26:	; goto 28
87:		jmp strftime$28
89:	

strftime$27:	; £temporary3045 = 0
90:		mov t2048, 0
92:	

strftime$28:	; longMonthList = £temporary3045
93:		mov [bp + 22], t2048
95:	

strftime$29:	; call header integral zero 0 stack zero 0
97:	

strftime$30:	; parameter s, offset 6
98:		mov a2049, [bp + 6]
99:		mov [bp + 30], a2049
101:	

strftime$31:	; parameter string_#, offset 8
102:		mov word [bp + 32], string_#
104:	

strftime$32:	; call function noellipse-noellipse strcpy
105:		mov word [bp + 24], strftime$33
106:		mov [bp + 26], bp
107:		add bp, 24
108:		jmp strcpy
110:	

strftime$33:	; post call
112:	

strftime$34:	; if shortDayList == 0 goto 37
113:		cmp word [bp + 16], 0
114:		je strftime$37
116:	

strftime$35:	; £temporary3051 = shortDayList
117:		mov t2050, [bp + 16]
119:	

strftime$36:	; goto 38
120:		jmp strftime$38
122:	

strftime$37:	; £temporary3051 = g_defaultShortDayList
123:		mov t2051, @30$g_defaultShortDayList
125:	

strftime$38:	; shortDayList = £temporary3051
126:		mov [bp + 16], t2051
128:	

strftime$39:	; if longDayList == 0 goto 42
129:		cmp word [bp + 20], 0
130:		je strftime$42
132:	

strftime$40:	; £temporary3056 = longDayList
133:		mov t2052, [bp + 20]
135:	

strftime$41:	; goto 43
136:		jmp strftime$43
138:	

strftime$42:	; £temporary3056 = g_defaultLongDayList
139:		mov t2053, @31$g_defaultLongDayList
141:	

strftime$43:	; longDayList = £temporary3056
142:		mov [bp + 20], t2053
144:	

strftime$44:	; if shortMonthList == 0 goto 47
145:		cmp word [bp + 18], 0
146:		je strftime$47
148:	

strftime$45:	; £temporary3061 = shortMonthList
149:		mov t2054, [bp + 18]
151:	

strftime$46:	; goto 48
152:		jmp strftime$48
154:	

strftime$47:	; £temporary3061 = g_defaultShortMonthList
155:		mov t2055, @32$g_defaultShortMonthList
157:	

strftime$48:	; shortMonthList = £temporary3061
158:		mov [bp + 18], t2055
160:	

strftime$49:	; if longMonthList == 0 goto 52
161:		cmp word [bp + 22], 0
162:		je strftime$52
164:	

strftime$50:	; £temporary3066 = longMonthList
165:		mov t2056, [bp + 22]
167:	

strftime$51:	; goto 53
168:		jmp strftime$53
170:	

strftime$52:	; £temporary3066 = g_defaultLongMonthList
171:		mov t2057, @33$g_defaultLongMonthList
173:	

strftime$53:	; longMonthList = £temporary3066
174:		mov [bp + 22], t2057
176:	

strftime$54:	; £temporary3067 -> tp = *tp, offset 10
177:		mov a2058, [bp + 12]
179:	

strftime$55:	; £temporary3068 = £temporary3067 -> tp - 69
180:		mov t2059, [a2058 + 10]
181:		sub t2059, 69
183:	

strftime$56:	; leapDays = £temporary3068 / 4
185:		xor dx, dx
186:		idiv word [int2$4#]
187:		mov [bp + 24], ax
189:	

strftime$57:	; £temporary3070 -> tp = *tp, offset 10
190:		mov a2062, [bp + 12]
192:	

strftime$58:	; £temporary3071 = £temporary3070 -> tp - 70
193:		mov t2063, [a2062 + 10]
194:		sub t2063, 70
196:	

strftime$59:	; £temporary3072 = £temporary3071 * 365
198:		xor dx, dx
199:		imul word [int2$365#]
205:	

strftime$60:	; £temporary3073 = £temporary3072 + leapDays
206:		add t2066, [bp + 24]
208:	

strftime$61:	; £temporary3074 -> tp = *tp, offset 14
209:		mov a2067, [bp + 12]
211:	

strftime$62:	; £temporary3075 = £temporary3073 + £temporary3074 -> tp
212:		add t2066, [a2067 + 14]
214:	

strftime$63:	; £temporary3076 = int_to_int £temporary3075 (Signed_Int -> Signed_Long_Int)
216:		and t2066, 65535
218:		cmp t2066, 0
219:		jge strftime$64
220:		neg t2066
222:		neg t2066
224:	

strftime$64:	; totalDays = £temporary3076
225:		mov [bp + 26], t2066
227:	

strftime$65:	; if totalDays >= 3 goto 70
228:		cmp dword [bp + 26], 3
229:		jge strftime$70
231:	

strftime$66:	; £temporary3078 = totalDays + 4
232:		mov a2068, [bp + 26]
233:		add a2068, 4
235:	

strftime$67:	; £temporary3079 = int_to_int £temporary3078 (Signed_Long_Int -> Signed_Int)
238:		cmp a2068, 0
239:		jge strftime$68
240:		neg a2068
242:		neg a2068
244:	

strftime$68:	; yearDaySunday = £temporary3079
245:		mov [bp + 30], a2068
247:	

strftime$69:	; goto 74
248:		jmp strftime$74
250:	

strftime$70:	; £temporary3080 = totalDays - 3
251:		mov a2069, [bp + 26]
252:		sub a2069, 3
254:	

strftime$71:	; £temporary3081 = £temporary3080 % 7
256:		xor edx, edx
257:		idiv dword [int4$7#]
263:	

strftime$72:	; £temporary3082 = int_to_int £temporary3081 (Signed_Long_Int -> Signed_Int)
266:		cmp t2071, 0
267:		jge strftime$73
268:		neg t2071
270:		neg t2071
272:	

strftime$73:	; yearDaySunday = £temporary3082
273:		mov [bp + 30], t2071
275:	

strftime$74:	; if totalDays >= 4 goto 79
276:		cmp dword [bp + 26], 4
277:		jge strftime$79
279:	

strftime$75:	; £temporary3084 = totalDays + 3
280:		mov a2072, [bp + 26]
281:		add a2072, 3
283:	

strftime$76:	; £temporary3085 = int_to_int £temporary3084 (Signed_Long_Int -> Signed_Int)
286:		cmp a2072, 0
287:		jge strftime$77
288:		neg a2072
290:		neg a2072
292:	

strftime$77:	; yearDayMonday = £temporary3085
293:		mov [bp + 32], a2072
295:	

strftime$78:	; goto 83
296:		jmp strftime$83
298:	

strftime$79:	; £temporary3086 = totalDays - 4
299:		mov a2073, [bp + 26]
300:		sub a2073, 4
302:	

strftime$80:	; £temporary3087 = £temporary3086 % 7
304:		xor edx, edx
305:		idiv dword [int4$7#]
311:	

strftime$81:	; £temporary3088 = int_to_int £temporary3087 (Signed_Long_Int -> Signed_Int)
314:		cmp t2075, 0
315:		jge strftime$82
316:		neg t2075
318:		neg t2075
320:	

strftime$82:	; yearDayMonday = £temporary3088
321:		mov [bp + 32], t2075
323:	

strftime$83:	; index = 0
324:		mov word [bp + 34], 0
326:	

strftime$84:	; £temporary3090 = fmt + index
327:		mov a2076, [bp + 10]
328:		add a2076, [bp + 34]
330:	

strftime$85:	; £temporary3089 -> £temporary3090 = *£temporary3090
332:	

strftime$86:	; if £temporary3089 -> £temporary3090 == 0 goto 350
333:		cmp byte [a2076], 0
334:		je strftime$350
336:	

strftime$87:	; £temporary3094 = fmt + index
337:		mov a2077, [bp + 10]
338:		add a2077, [bp + 34]
340:	

strftime$88:	; £temporary3093 -> £temporary3094 = *£temporary3094
342:	

strftime$89:	; if £temporary3093 -> £temporary3094 != 37 goto 325
343:		cmp byte [a2077], 37
344:		jne strftime$325
346:	

strftime$90:	; £temporary3096 = index + 1
347:		mov a2078, [bp + 34]
348:		add a2078, 1
350:	

strftime$91:	; £temporary3098 = fmt + £temporary3096
351:		mov a2079, [bp + 10]
352:		add a2079, a2078
354:	

strftime$92:	; £temporary3097 -> £temporary3098 = *£temporary3098
355:		mov t2080, [a2079]
356:		mov [bp + 56], t2080
358:	

strftime$93:	; case £temporary3097 -> £temporary3098 == 97 goto 117
359:		mov t2081, [bp + 56]
360:		cmp t2081, 97
361:		je strftime$117
363:	

strftime$94:	; case £temporary3097 -> £temporary3098 == 65 goto 127
364:		cmp t2081, 65
365:		je strftime$127
367:	

strftime$95:	; case £temporary3097 -> £temporary3098 == 98 goto 137
368:		cmp t2081, 98
369:		je strftime$137
371:	

strftime$96:	; case £temporary3097 -> £temporary3098 == 66 goto 147
372:		cmp t2081, 66
373:		je strftime$147
375:	

strftime$97:	; case £temporary3097 -> £temporary3098 == 99 goto 157
376:		cmp t2081, 99
377:		je strftime$157
379:	

strftime$98:	; case £temporary3097 -> £temporary3098 == 100 goto 177
380:		cmp t2081, 100
381:		je strftime$177
383:	

strftime$99:	; case £temporary3097 -> £temporary3098 == 72 goto 185
384:		cmp t2081, 72
385:		je strftime$185
387:	

strftime$100:	; case £temporary3097 -> £temporary3098 == 73 goto 193
388:		cmp t2081, 73
389:		je strftime$193
391:	

strftime$101:	; case £temporary3097 -> £temporary3098 == 106 goto 202
392:		cmp t2081, 106
393:		je strftime$202
395:	

strftime$102:	; case £temporary3097 -> £temporary3098 == 109 goto 210
396:		cmp t2081, 109
397:		je strftime$210
399:	

strftime$103:	; case £temporary3097 -> £temporary3098 == 77 goto 219
400:		cmp t2081, 77
401:		je strftime$219
403:	

strftime$104:	; case £temporary3097 -> £temporary3098 == 112 goto 227
404:		cmp t2081, 112
405:		je strftime$227
407:	

strftime$105:	; case £temporary3097 -> £temporary3098 == 83 goto 239
408:		cmp t2081, 83
409:		je strftime$239
411:	

strftime$106:	; case £temporary3097 -> £temporary3098 == 85 goto 247
412:		cmp t2081, 85
413:		je strftime$247
415:	

strftime$107:	; case £temporary3097 -> £temporary3098 == 119 goto 254
416:		cmp t2081, 119
417:		je strftime$254
419:	

strftime$108:	; case £temporary3097 -> £temporary3098 == 87 goto 262
420:		cmp t2081, 87
421:		je strftime$262
423:	

strftime$109:	; case £temporary3097 -> £temporary3098 == 120 goto 269
424:		cmp t2081, 120
425:		je strftime$269
427:	

strftime$110:	; case £temporary3097 -> £temporary3098 == 88 goto 283
428:		cmp t2081, 88
429:		je strftime$283
431:	

strftime$111:	; case £temporary3097 -> £temporary3098 == 121 goto 295
432:		cmp t2081, 121
433:		je strftime$295
435:	

strftime$112:	; case £temporary3097 -> £temporary3098 == 89 goto 304
436:		cmp t2081, 89
437:		je strftime$304
439:	

strftime$113:	; case £temporary3097 -> £temporary3098 == 90 goto 313
440:		cmp t2081, 90
441:		je strftime$313
443:	

strftime$114:	; case £temporary3097 -> £temporary3098 == 37 goto 319
444:		cmp t2081, 37
445:		je strftime$319
447:	

strftime$115:	; case end £temporary3097 -> £temporary3098
449:	

strftime$116:	; goto 331
450:		jmp strftime$331
452:	

strftime$117:	; call header integral zero 0 stack zero 0
454:	

strftime$118:	; parameter add, offset 6
455:		mov [bp + 62], bp
456:		add word [bp + 62], 36
458:	

strftime$119:	; £temporary3099 -> tp = *tp, offset 12
459:		mov a2082, [bp + 12]
461:	

strftime$120:	; £temporary3101 = £temporary3099 -> tp * 2
462:		mov t2083, [a2082 + 12]
464:		xor dx, dx
465:		mul word [int2$2#]
471:	

strftime$121:	; £temporary3102 = shortDayList + £temporary3101
472:		mov a2087, [bp + 16]
473:		add a2087, t2086
475:	

strftime$122:	; £temporary3100 -> £temporary3102 = *£temporary3102
477:	

strftime$123:	; parameter £temporary3100 -> £temporary3102, offset 8
478:		mov t2088, [a2087]
479:		mov [bp + 64], t2088
481:	

strftime$124:	; call function noellipse-noellipse strcpy
482:		mov word [bp + 56], strftime$125
483:		mov [bp + 58], bp
484:		add bp, 56
485:		jmp strcpy
487:	

strftime$125:	; post call
489:	

strftime$126:	; goto 331
490:		jmp strftime$331
492:	

strftime$127:	; call header integral zero 0 stack zero 0
494:	

strftime$128:	; parameter add, offset 6
495:		mov [bp + 62], bp
496:		add word [bp + 62], 36
498:	

strftime$129:	; £temporary3104 -> tp = *tp, offset 12
499:		mov a2089, [bp + 12]
501:	

strftime$130:	; £temporary3106 = £temporary3104 -> tp * 2
502:		mov t2090, [a2089 + 12]
504:		xor dx, dx
505:		mul word [int2$2#]
511:	

strftime$131:	; £temporary3107 = longDayList + £temporary3106
512:		mov a2094, [bp + 20]
513:		add a2094, t2093
515:	

strftime$132:	; £temporary3105 -> £temporary3107 = *£temporary3107
517:	

strftime$133:	; parameter £temporary3105 -> £temporary3107, offset 8
518:		mov t2095, [a2094]
519:		mov [bp + 64], t2095
521:	

strftime$134:	; call function noellipse-noellipse strcpy
522:		mov word [bp + 56], strftime$135
523:		mov [bp + 58], bp
524:		add bp, 56
525:		jmp strcpy
527:	

strftime$135:	; post call
529:	

strftime$136:	; goto 331
530:		jmp strftime$331
532:	

strftime$137:	; call header integral zero 0 stack zero 0
534:	

strftime$138:	; parameter add, offset 6
535:		mov [bp + 62], bp
536:		add word [bp + 62], 36
538:	

strftime$139:	; £temporary3109 -> tp = *tp, offset 8
539:		mov a2096, [bp + 12]
541:	

strftime$140:	; £temporary3111 = £temporary3109 -> tp * 2
542:		mov t2097, [a2096 + 8]
544:		xor dx, dx
545:		mul word [int2$2#]
551:	

strftime$141:	; £temporary3112 = shortMonthList + £temporary3111
552:		mov a2101, [bp + 18]
553:		add a2101, t2100
555:	

strftime$142:	; £temporary3110 -> £temporary3112 = *£temporary3112
557:	

strftime$143:	; parameter £temporary3110 -> £temporary3112, offset 8
558:		mov t2102, [a2101]
559:		mov [bp + 64], t2102
561:	

strftime$144:	; call function noellipse-noellipse strcpy
562:		mov word [bp + 56], strftime$145
563:		mov [bp + 58], bp
564:		add bp, 56
565:		jmp strcpy
567:	

strftime$145:	; post call
569:	

strftime$146:	; goto 331
570:		jmp strftime$331
572:	

strftime$147:	; call header integral zero 0 stack zero 0
574:	

strftime$148:	; parameter add, offset 6
575:		mov [bp + 62], bp
576:		add word [bp + 62], 36
578:	

strftime$149:	; £temporary3114 -> tp = *tp, offset 8
579:		mov a2103, [bp + 12]
581:	

strftime$150:	; £temporary3116 = £temporary3114 -> tp * 2
582:		mov t2104, [a2103 + 8]
584:		xor dx, dx
585:		mul word [int2$2#]
591:	

strftime$151:	; £temporary3117 = longMonthList + £temporary3116
592:		mov a2108, [bp + 22]
593:		add a2108, t2107
595:	

strftime$152:	; £temporary3115 -> £temporary3117 = *£temporary3117
597:	

strftime$153:	; parameter £temporary3115 -> £temporary3117, offset 8
598:		mov t2109, [a2108]
599:		mov [bp + 64], t2109
601:	

strftime$154:	; call function noellipse-noellipse strcpy
602:		mov word [bp + 56], strftime$155
603:		mov [bp + 58], bp
604:		add bp, 56
605:		jmp strcpy
607:	

strftime$155:	; post call
609:	

strftime$156:	; goto 331
610:		jmp strftime$331
612:	

strftime$157:	; call header integral zero 0 stack zero 0
614:	

strftime$158:	; parameter add, offset 6
615:		mov [bp + 62], bp
616:		add word [bp + 62], 36
618:	

strftime$159:	; parameter string_2504d2D2502d2D2502d202502d3A2502d3A2502d#, offset 8
619:		mov word [bp + 64], string_2504d2D2502d2D2502d202502d3A2502d3A2502d#
621:	

strftime$160:	; £temporary3119 -> tp = *tp, offset 10
622:		mov a2110, [bp + 12]
624:	

strftime$161:	; £temporary3120 = £temporary3119 -> tp + 1900
625:		mov t2111, [a2110 + 10]
626:		add t2111, 1900
628:	

strftime$162:	; parameter £temporary3120, offset 10
629:		mov [bp + 66], t2111
631:	

strftime$163:	; £temporary3121 -> tp = *tp, offset 8
632:		mov a2112, [bp + 12]
634:	

strftime$164:	; £temporary3122 = £temporary3121 -> tp + 1
635:		mov t2113, [a2112 + 8]
636:		add t2113, 1
638:	

strftime$165:	; parameter £temporary3122, offset 12
639:		mov [bp + 68], t2113
641:	

strftime$166:	; £temporary3123 -> tp = *tp, offset 6
642:		mov a2114, [bp + 12]
644:	

strftime$167:	; parameter £temporary3123 -> tp, offset 14
645:		mov t2115, [a2114 + 6]
646:		mov [bp + 70], t2115
648:	

strftime$168:	; £temporary3124 -> tp = *tp, offset 4
649:		mov a2116, [bp + 12]
651:	

strftime$169:	; parameter £temporary3124 -> tp, offset 16
652:		mov t2117, [a2116 + 4]
653:		mov [bp + 72], t2117
655:	

strftime$170:	; £temporary3125 -> tp = *tp, offset 2
656:		mov a2118, [bp + 12]
658:	

strftime$171:	; parameter £temporary3125 -> tp, offset 18
659:		mov t2119, [a2118 + 2]
660:		mov [bp + 74], t2119
662:	

strftime$172:	; £temporary3126 -> tp = *tp
663:		mov a2120, [bp + 12]
665:	

strftime$173:	; parameter £temporary3126 -> tp, offset 20
666:		mov t2121, [a2120]
667:		mov [bp + 76], t2121
669:	

strftime$174:	; call function noellipse-ellipse sprintf, extra 0
670:		mov word [bp + 56], strftime$175
671:		mov [bp + 58], bp
672:		add bp, 56
673:		mov di, bp
674:		add di, 12
675:		jmp sprintf
677:	

strftime$175:	; post call
679:	

strftime$176:	; goto 331
680:		jmp strftime$331
682:	

strftime$177:	; call header integral zero 0 stack zero 0
684:	

strftime$178:	; parameter add, offset 6
685:		mov [bp + 62], bp
686:		add word [bp + 62], 36
688:	

strftime$179:	; parameter string_2502d#, offset 8
689:		mov word [bp + 64], string_2502d#
691:	

strftime$180:	; £temporary3128 -> tp = *tp, offset 6
692:		mov a2122, [bp + 12]
694:	

strftime$181:	; parameter £temporary3128 -> tp, offset 10
695:		mov t2123, [a2122 + 6]
696:		mov [bp + 66], t2123
698:	

strftime$182:	; call function noellipse-ellipse sprintf, extra 0
699:		mov word [bp + 56], strftime$183
700:		mov [bp + 58], bp
701:		add bp, 56
702:		mov di, bp
703:		add di, 2
704:		jmp sprintf
706:	

strftime$183:	; post call
708:	

strftime$184:	; goto 331
709:		jmp strftime$331
711:	

strftime$185:	; call header integral zero 0 stack zero 0
713:	

strftime$186:	; parameter add, offset 6
714:		mov [bp + 62], bp
715:		add word [bp + 62], 36
717:	

strftime$187:	; parameter string_2502d#, offset 8
718:		mov word [bp + 64], string_2502d#
720:	

strftime$188:	; £temporary3130 -> tp = *tp, offset 4
721:		mov a2124, [bp + 12]
723:	

strftime$189:	; parameter £temporary3130 -> tp, offset 10
724:		mov t2125, [a2124 + 4]
725:		mov [bp + 66], t2125
727:	

strftime$190:	; call function noellipse-ellipse sprintf, extra 0
728:		mov word [bp + 56], strftime$191
729:		mov [bp + 58], bp
730:		add bp, 56
731:		mov di, bp
732:		add di, 2
733:		jmp sprintf
735:	

strftime$191:	; post call
737:	

strftime$192:	; goto 331
738:		jmp strftime$331
740:	

strftime$193:	; call header integral zero 0 stack zero 0
742:	

strftime$194:	; parameter add, offset 6
743:		mov [bp + 62], bp
744:		add word [bp + 62], 36
746:	

strftime$195:	; parameter string_2502d#, offset 8
747:		mov word [bp + 64], string_2502d#
749:	

strftime$196:	; £temporary3132 -> tp = *tp, offset 4
750:		mov a2126, [bp + 12]
752:	

strftime$197:	; £temporary3133 = £temporary3132 -> tp % 12
753:		mov t2127, [a2126 + 4]
755:		xor dx, dx
756:		idiv word [int2$12#]
762:	

strftime$198:	; parameter £temporary3133, offset 10
763:		mov [bp + 66], t2129
765:	

strftime$199:	; call function noellipse-ellipse sprintf, extra 0
766:		mov word [bp + 56], strftime$200
767:		mov [bp + 58], bp
768:		add bp, 56
769:		mov di, bp
770:		add di, 2
771:		jmp sprintf
773:	

strftime$200:	; post call
775:	

strftime$201:	; goto 331
776:		jmp strftime$331
778:	

strftime$202:	; call header integral zero 0 stack zero 0
780:	

strftime$203:	; parameter add, offset 6
781:		mov [bp + 62], bp
782:		add word [bp + 62], 36
784:	

strftime$204:	; parameter string_2503d#, offset 8
785:		mov word [bp + 64], string_2503d#
787:	

strftime$205:	; £temporary3135 -> tp = *tp, offset 14
788:		mov a2130, [bp + 12]
790:	

strftime$206:	; parameter £temporary3135 -> tp, offset 10
791:		mov t2131, [a2130 + 14]
792:		mov [bp + 66], t2131
794:	

strftime$207:	; call function noellipse-ellipse sprintf, extra 0
795:		mov word [bp + 56], strftime$208
796:		mov [bp + 58], bp
797:		add bp, 56
798:		mov di, bp
799:		add di, 2
800:		jmp sprintf
802:	

strftime$208:	; post call
804:	

strftime$209:	; goto 331
805:		jmp strftime$331
807:	

strftime$210:	; call header integral zero 0 stack zero 0
809:	

strftime$211:	; parameter add, offset 6
810:		mov [bp + 62], bp
811:		add word [bp + 62], 36
813:	

strftime$212:	; parameter string_2502d#, offset 8
814:		mov word [bp + 64], string_2502d#
816:	

strftime$213:	; £temporary3137 -> tp = *tp, offset 8
817:		mov a2132, [bp + 12]
819:	

strftime$214:	; £temporary3138 = £temporary3137 -> tp + 1
820:		mov t2133, [a2132 + 8]
821:		add t2133, 1
823:	

strftime$215:	; parameter £temporary3138, offset 10
824:		mov [bp + 66], t2133
826:	

strftime$216:	; call function noellipse-ellipse sprintf, extra 0
827:		mov word [bp + 56], strftime$217
828:		mov [bp + 58], bp
829:		add bp, 56
830:		mov di, bp
831:		add di, 2
832:		jmp sprintf
834:	

strftime$217:	; post call
836:	

strftime$218:	; goto 331
837:		jmp strftime$331
839:	

strftime$219:	; call header integral zero 0 stack zero 0
841:	

strftime$220:	; parameter add, offset 6
842:		mov [bp + 62], bp
843:		add word [bp + 62], 36
845:	

strftime$221:	; parameter string_2502d#, offset 8
846:		mov word [bp + 64], string_2502d#
848:	

strftime$222:	; £temporary3140 -> tp = *tp, offset 2
849:		mov a2134, [bp + 12]
851:	

strftime$223:	; parameter £temporary3140 -> tp, offset 10
852:		mov t2135, [a2134 + 2]
853:		mov [bp + 66], t2135
855:	

strftime$224:	; call function noellipse-ellipse sprintf, extra 0
856:		mov word [bp + 56], strftime$225
857:		mov [bp + 58], bp
858:		add bp, 56
859:		mov di, bp
860:		add di, 2
861:		jmp sprintf
863:	

strftime$225:	; post call
865:	

strftime$226:	; goto 331
866:		jmp strftime$331
868:	

strftime$227:	; call header integral zero 0 stack zero 0
870:	

strftime$228:	; parameter add, offset 6
871:		mov [bp + 62], bp
872:		add word [bp + 62], 36
874:	

strftime$229:	; parameter string_25s#, offset 8
875:		mov word [bp + 64], string_25s#
877:	

strftime$230:	; £temporary3142 -> tp = *tp, offset 4
878:		mov a2136, [bp + 12]
880:	

strftime$231:	; if £temporary3142 -> tp >= 12 goto 234
881:		cmp word [a2136 + 4], 12
882:		jge strftime$234
884:	

strftime$232:	; £temporary3147 = string_AM#
885:		mov t2137, string_AM#
887:	

strftime$233:	; goto 235
888:		jmp strftime$235
890:	

strftime$234:	; £temporary3147 = string_PM#
891:		mov t2138, string_PM#
893:	

strftime$235:	; parameter £temporary3147, offset 10
894:		mov [bp + 66], t2138
896:	

strftime$236:	; call function noellipse-ellipse sprintf, extra 0
897:		mov word [bp + 56], strftime$237
898:		mov [bp + 58], bp
899:		add bp, 56
900:		mov di, bp
901:		add di, 2
902:		jmp sprintf
904:	

strftime$237:	; post call
906:	

strftime$238:	; goto 331
907:		jmp strftime$331
909:	

strftime$239:	; call header integral zero 0 stack zero 0
911:	

strftime$240:	; parameter add, offset 6
912:		mov [bp + 62], bp
913:		add word [bp + 62], 36
915:	

strftime$241:	; parameter string_2502d#, offset 8
916:		mov word [bp + 64], string_2502d#
918:	

strftime$242:	; £temporary3149 -> tp = *tp
919:		mov a2139, [bp + 12]
921:	

strftime$243:	; parameter £temporary3149 -> tp, offset 10
922:		mov t2140, [a2139]
923:		mov [bp + 66], t2140
925:	

strftime$244:	; call function noellipse-ellipse sprintf, extra 0
926:		mov word [bp + 56], strftime$245
927:		mov [bp + 58], bp
928:		add bp, 56
929:		mov di, bp
930:		add di, 2
931:		jmp sprintf
933:	

strftime$245:	; post call
935:	

strftime$246:	; goto 331
936:		jmp strftime$331
938:	

strftime$247:	; call header integral zero 0 stack zero 0
940:	

strftime$248:	; parameter add, offset 6
941:		mov [bp + 62], bp
942:		add word [bp + 62], 36
944:	

strftime$249:	; parameter string_2502d#, offset 8
945:		mov word [bp + 64], string_2502d#
947:	

strftime$250:	; parameter yearDaySunday, offset 10
948:		mov a2141, [bp + 30]
949:		mov [bp + 66], a2141
951:	

strftime$251:	; call function noellipse-ellipse sprintf, extra 0
952:		mov word [bp + 56], strftime$252
953:		mov [bp + 58], bp
954:		add bp, 56
955:		mov di, bp
956:		add di, 2
957:		jmp sprintf
959:	

strftime$252:	; post call
961:	

strftime$253:	; goto 331
962:		jmp strftime$331
964:	

strftime$254:	; call header integral zero 0 stack zero 0
966:	

strftime$255:	; parameter add, offset 6
967:		mov [bp + 62], bp
968:		add word [bp + 62], 36
970:	

strftime$256:	; parameter string_2502d#, offset 8
971:		mov word [bp + 64], string_2502d#
973:	

strftime$257:	; £temporary3152 -> tp = *tp, offset 12
974:		mov a2142, [bp + 12]
976:	

strftime$258:	; parameter £temporary3152 -> tp, offset 10
977:		mov t2143, [a2142 + 12]
978:		mov [bp + 66], t2143
980:	

strftime$259:	; call function noellipse-ellipse sprintf, extra 0
981:		mov word [bp + 56], strftime$260
982:		mov [bp + 58], bp
983:		add bp, 56
984:		mov di, bp
985:		add di, 2
986:		jmp sprintf
988:	

strftime$260:	; post call
990:	

strftime$261:	; goto 331
991:		jmp strftime$331
993:	

strftime$262:	; call header integral zero 0 stack zero 0
995:	

strftime$263:	; parameter add, offset 6
996:		mov [bp + 62], bp
997:		add word [bp + 62], 36
999:	

strftime$264:	; parameter string_2502d#, offset 8
1000:		mov word [bp + 64], string_2502d#
1002:	

strftime$265:	; parameter yearDayMonday, offset 10
1003:		mov a2144, [bp + 32]
1004:		mov [bp + 66], a2144
1006:	

strftime$266:	; call function noellipse-ellipse sprintf, extra 0
1007:		mov word [bp + 56], strftime$267
1008:		mov [bp + 58], bp
1009:		add bp, 56
1010:		mov di, bp
1011:		add di, 2
1012:		jmp sprintf
1014:	

strftime$267:	; post call
1016:	

strftime$268:	; goto 331
1017:		jmp strftime$331
1019:	

strftime$269:	; call header integral zero 0 stack zero 0
1021:	

strftime$270:	; parameter add, offset 6
1022:		mov [bp + 62], bp
1023:		add word [bp + 62], 36
1025:	

strftime$271:	; parameter string_2504d2D2502d2D2502d#, offset 8
1026:		mov word [bp + 64], string_2504d2D2502d2D2502d#
1028:	

strftime$272:	; £temporary3155 -> tp = *tp, offset 10
1029:		mov a2145, [bp + 12]
1031:	

strftime$273:	; £temporary3156 = £temporary3155 -> tp + 1900
1032:		mov t2146, [a2145 + 10]
1033:		add t2146, 1900
1035:	

strftime$274:	; parameter £temporary3156, offset 10
1036:		mov [bp + 66], t2146
1038:	

strftime$275:	; £temporary3157 -> tp = *tp, offset 8
1039:		mov a2147, [bp + 12]
1041:	

strftime$276:	; £temporary3158 = £temporary3157 -> tp + 1
1042:		mov t2148, [a2147 + 8]
1043:		add t2148, 1
1045:	

strftime$277:	; parameter £temporary3158, offset 12
1046:		mov [bp + 68], t2148
1048:	

strftime$278:	; £temporary3159 -> tp = *tp, offset 6
1049:		mov a2149, [bp + 12]
1051:	

strftime$279:	; parameter £temporary3159 -> tp, offset 14
1052:		mov t2150, [a2149 + 6]
1053:		mov [bp + 70], t2150
1055:	

strftime$280:	; call function noellipse-ellipse sprintf, extra 0
1056:		mov word [bp + 56], strftime$281
1057:		mov [bp + 58], bp
1058:		add bp, 56
1059:		mov di, bp
1060:		add di, 6
1061:		jmp sprintf
1063:	

strftime$281:	; post call
1065:	

strftime$282:	; goto 331
1066:		jmp strftime$331
1068:	

strftime$283:	; call header integral zero 0 stack zero 0
1070:	

strftime$284:	; parameter add, offset 6
1071:		mov [bp + 62], bp
1072:		add word [bp + 62], 36
1074:	

strftime$285:	; parameter string_2502d3A2502d3A2502d#, offset 8
1075:		mov word [bp + 64], string_2502d3A2502d3A2502d#
1077:	

strftime$286:	; £temporary3161 -> tp = *tp, offset 4
1078:		mov a2151, [bp + 12]
1080:	

strftime$287:	; parameter £temporary3161 -> tp, offset 10
1081:		mov t2152, [a2151 + 4]
1082:		mov [bp + 66], t2152
1084:	

strftime$288:	; £temporary3162 -> tp = *tp, offset 2
1085:		mov a2153, [bp + 12]
1087:	

strftime$289:	; parameter £temporary3162 -> tp, offset 12
1088:		mov t2154, [a2153 + 2]
1089:		mov [bp + 68], t2154
1091:	

strftime$290:	; £temporary3163 -> tp = *tp
1092:		mov a2155, [bp + 12]
1094:	

strftime$291:	; parameter £temporary3163 -> tp, offset 14
1095:		mov t2156, [a2155]
1096:		mov [bp + 70], t2156
1098:	

strftime$292:	; call function noellipse-ellipse sprintf, extra 0
1099:		mov word [bp + 56], strftime$293
1100:		mov [bp + 58], bp
1101:		add bp, 56
1102:		mov di, bp
1103:		add di, 6
1104:		jmp sprintf
1106:	

strftime$293:	; post call
1108:	

strftime$294:	; goto 331
1109:		jmp strftime$331
1111:	

strftime$295:	; call header integral zero 0 stack zero 0
1113:	

strftime$296:	; parameter add, offset 6
1114:		mov [bp + 62], bp
1115:		add word [bp + 62], 36
1117:	

strftime$297:	; parameter string_2502d#, offset 8
1118:		mov word [bp + 64], string_2502d#
1120:	

strftime$298:	; £temporary3165 -> tp = *tp, offset 10
1121:		mov a2157, [bp + 12]
1123:	

strftime$299:	; £temporary3166 = £temporary3165 -> tp % 100
1124:		mov t2158, [a2157 + 10]
1126:		xor dx, dx
1127:		idiv word [int2$100#]
1133:	

strftime$300:	; parameter £temporary3166, offset 10
1134:		mov [bp + 66], t2160
1136:	

strftime$301:	; call function noellipse-ellipse sprintf, extra 0
1137:		mov word [bp + 56], strftime$302
1138:		mov [bp + 58], bp
1139:		add bp, 56
1140:		mov di, bp
1141:		add di, 2
1142:		jmp sprintf
1144:	

strftime$302:	; post call
1146:	

strftime$303:	; goto 331
1147:		jmp strftime$331
1149:	

strftime$304:	; call header integral zero 0 stack zero 0
1151:	

strftime$305:	; parameter add, offset 6
1152:		mov [bp + 62], bp
1153:		add word [bp + 62], 36
1155:	

strftime$306:	; parameter string_2504d#, offset 8
1156:		mov word [bp + 64], string_2504d#
1158:	

strftime$307:	; £temporary3168 -> tp = *tp, offset 10
1159:		mov a2161, [bp + 12]
1161:	

strftime$308:	; £temporary3169 = £temporary3168 -> tp + 1900
1162:		mov t2162, [a2161 + 10]
1163:		add t2162, 1900
1165:	

strftime$309:	; parameter £temporary3169, offset 10
1166:		mov [bp + 66], t2162
1168:	

strftime$310:	; call function noellipse-ellipse sprintf, extra 0
1169:		mov word [bp + 56], strftime$311
1170:		mov [bp + 58], bp
1171:		add bp, 56
1172:		mov di, bp
1173:		add di, 2
1174:		jmp sprintf
1176:	

strftime$311:	; post call
1178:	

strftime$312:	; goto 331
1179:		jmp strftime$331
1181:	

strftime$313:	; call header integral zero 0 stack zero 0
1183:	

strftime$314:	; parameter add, offset 6
1184:		mov [bp + 62], bp
1185:		add word [bp + 62], 36
1187:	

strftime$315:	; parameter string_#, offset 8
1188:		mov word [bp + 64], string_#
1190:	

strftime$316:	; call function noellipse-noellipse strcpy
1191:		mov word [bp + 56], strftime$317
1192:		mov [bp + 58], bp
1193:		add bp, 56
1194:		jmp strcpy
1196:	

strftime$317:	; post call
1198:	

strftime$318:	; goto 331
1199:		jmp strftime$331
1201:	

strftime$319:	; call header integral zero 0 stack zero 0
1203:	

strftime$320:	; parameter add, offset 6
1204:		mov [bp + 62], bp
1205:		add word [bp + 62], 36
1207:	

strftime$321:	; parameter string_25#, offset 8
1208:		mov word [bp + 64], string_25#
1210:	

strftime$322:	; call function noellipse-noellipse strcpy
1211:		mov word [bp + 56], strftime$323
1212:		mov [bp + 58], bp
1213:		add bp, 56
1214:		jmp strcpy
1216:	

strftime$323:	; post call
1218:	

strftime$324:	; goto 331
1219:		jmp strftime$331
1221:	

strftime$325:	; £temporary3173 -> add = *add
1222:		mov a2163, bp
1223:		add a2163, 36
1225:	

strftime$326:	; £temporary3175 = fmt + index
1226:		mov a2164, [bp + 10]
1227:		add a2164, [bp + 34]
1229:	

strftime$327:	; £temporary3174 -> £temporary3175 = *£temporary3175
1231:	

strftime$328:	; £temporary3173 -> add = £temporary3174 -> £temporary3175
1232:		mov t2165, [a2164]
1233:		mov [a2163], t2165
1235:	

strftime$329:	; £temporary3176 -> add = *add, offset 1
1236:		mov a2166, bp
1237:		add a2166, 36
1239:	

strftime$330:	; £temporary3176 -> add = 0
1240:		mov byte [a2166 + 1], 0
1242:	

strftime$331:	; call header integral zero 0 stack zero 0
1244:	

strftime$332:	; parameter s, offset 6
1245:		mov a2167, [bp + 6]
1246:		mov [bp + 62], a2167
1248:	

strftime$333:	; call function noellipse-noellipse strlen
1249:		mov word [bp + 56], strftime$334
1250:		mov [bp + 58], bp
1251:		add bp, 56
1252:		jmp strlen
1254:	

strftime$334:	; post call
1256:	

strftime$335:	; £temporary3177 = return_value
1261:	

strftime$336:	; call header integral no zero 1 stack zero 0
1262:		mov [bp + 56], t2169
1264:	

strftime$337:	; parameter add, offset 6
1265:		mov [bp + 64], bp
1266:		add word [bp + 64], 36
1268:	

strftime$338:	; call function noellipse-noellipse strlen
1269:		mov word [bp + 58], strftime$339
1270:		mov [bp + 60], bp
1271:		add bp, 58
1272:		jmp strlen
1274:	

strftime$339:	; post call
1275:		mov t2169, [bp + 56]
1277:		mov t2170, t2169
1279:	

strftime$340:	; £temporary3178 = return_value
1284:	

strftime$341:	; £temporary3179 = £temporary3177 + £temporary3178
1285:		add t2170, t2172
1287:	

strftime$342:	; if £temporary3179 >= smax goto 350
1288:		cmp t2170, [bp + 8]
1289:		jge strftime$350
1291:	

strftime$343:	; call header integral zero 0 stack zero 0
1293:	

strftime$344:	; parameter s, offset 6
1294:		mov a2173, [bp + 6]
1295:		mov [bp + 62], a2173
1297:	

strftime$345:	; parameter add, offset 8
1298:		mov [bp + 64], bp
1299:		add word [bp + 64], 36
1301:	

strftime$346:	; call function noellipse-noellipse strcat
1302:		mov word [bp + 56], strftime$347
1303:		mov [bp + 58], bp
1304:		add bp, 56
1305:		jmp strcat
1307:	

strftime$347:	; post call
1309:	

strftime$348:	; ++index
1310:		inc word [bp + 34]
1312:	

strftime$349:	; goto 84
1313:		jmp strftime$84
1315:	

strftime$350:	; call header integral zero 0 stack zero 0
1317:	

strftime$351:	; parameter s, offset 6
1318:		mov a2174, [bp + 6]
1319:		mov [bp + 42], a2174
1321:	

strftime$352:	; call function noellipse-noellipse strlen
1322:		mov word [bp + 36], strftime$353
1323:		mov [bp + 38], bp
1324:		add bp, 36
1325:		jmp strlen
1327:	

strftime$353:	; post call
1329:	

strftime$354:	; £temporary3182 = return_value
1334:	

strftime$355:	; return_value = £temporary3182
1336:	

strftime$356:	; return
1337:		mov t2177, [bp]
1338:		mov di, [bp + 4]
1339:		mov bp, [bp + 2]
1340:		jmp t2177
1342:	

strftime$357:	; function end strftime
