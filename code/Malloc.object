1:	

malloc:	; if memorySize >= 0 goto 12
2:		cmp word [bp + 6], 0
3:		jge malloc$12
5:	

malloc$1:	; call header integral zero 0 stack zero 0
7:	

malloc$2:	; parameter stderr, offset 6
8:		mov ax, [stderr]
9:		mov [bp + 14], ax
11:	

malloc$3:	; parameter string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#, offset 8
12:		mov word [bp + 16], string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#
14:	

malloc$4:	; parameter string_memorySize203E3D200#, offset 10
15:		mov word [bp + 18], string_memorySize203E3D200#
17:	

malloc$5:	; parameter string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#, offset 12
18:		mov word [bp + 20], string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#
20:	

malloc$6:	; parameter 25, offset 14
21:		mov word [bp + 22], 25
23:	

malloc$7:	; call function noellipse-ellipse fprintf, extra 0
24:		mov word [bp + 8], malloc$8
25:		mov [bp + 10], bp
26:		add bp, 8
27:		mov di, bp
28:		add di, 6
29:		jmp fprintf
31:	

malloc$8:	; post call
33:	

malloc$9:	; call header integral zero 0 stack zero 0
35:	

malloc$10:	; call function noellipse-noellipse abort
36:		mov word [bp + 8], malloc$11
37:		mov [bp + 10], bp
38:		add bp, 8
39:		jmp abort
41:	

malloc$11:	; post call
43:	

malloc$12:	; if memorySize != 0 goto 15
44:		cmp word [bp + 6], 0
45:		jne malloc$15
47:	

malloc$13:	; return_value = 0
48:		mov bx, 0
50:	

malloc$14:	; return
51:		mov ax, [bp]
52:		mov di, [bp + 4]
53:		mov bp, [bp + 2]
54:		jmp ax
56:	

malloc$15:	; £temporary179 = int_to_int memorySize (Signed_Int -> Unsigned_Int)
57:		mov ax, [bp + 6]
60:	

malloc$16:	; £temporary180 = £temporary179 + 4
61:		add ax, 4
63:	

malloc$17:	; newBlockSize = £temporary180
64:		mov [bp + 8], ax
66:	

malloc$18:	; minGap = 0
67:		mov word [bp + 10], 0
69:	

malloc$19:	; lastAddress = 65528
70:		mov word [bp + 12], 65528
72:	

malloc$20:	; minBlockPtr = 0
73:		mov word [bp + 14], 0
75:	

malloc$21:	; minPrevBlockPtr = 0
76:		mov word [bp + 16], 0
78:	

malloc$22:	; prevBlockPtr = 0
79:		mov word [bp + 18], 0
81:	

malloc$23:	; currBlockPtr = g_firstBlockPtr
82:		mov ax, [g_firstBlockPtr]
83:		mov [bp + 20], ax
85:	

malloc$24:	; if currBlockPtr == 0 goto 43
86:		cmp word [bp + 20], 0
87:		je malloc$43
89:	

malloc$25:	; £temporary182 = int_to_int currBlockPtr (Pointer -> Unsigned_Int)
90:		mov ax, [bp + 20]
93:	

malloc$26:	; currAddress = £temporary182
94:		mov [bp + 22], ax
96:	

malloc$27:	; £temporary183 -> currBlockPtr = *currBlockPtr
97:		mov si, [bp + 20]
99:	

malloc$28:	; £temporary184 = currAddress + £temporary183 -> currBlockPtr
100:		mov ax, [bp + 22]
101:		add ax, [si]
103:	

malloc$29:	; £temporary185 = £temporary184 + 4
104:		add ax, 4
106:	

malloc$30:	; £temporary186 = lastAddress - £temporary185
107:		mov bx, [bp + 12]
108:		sub bx, ax
110:	

malloc$31:	; currGap = £temporary186
111:		mov [bp + 24], bx
113:	

malloc$32:	; if newBlockSize > currGap goto 38
114:		mov ax, [bp + 8]
115:		cmp ax, [bp + 24]
116:		ja malloc$38
118:	

malloc$33:	; if minGap == 0 goto 35
119:		cmp word [bp + 10], 0
120:		je malloc$35
122:	

malloc$34:	; if currGap >= minGap goto 38
123:		mov ax, [bp + 24]
124:		cmp ax, [bp + 10]
125:		jae malloc$38
127:	

malloc$35:	; minGap = currGap
128:		mov ax, [bp + 24]
129:		mov [bp + 10], ax
131:	

malloc$36:	; minBlockPtr = currBlockPtr
132:		mov ax, [bp + 20]
133:		mov [bp + 14], ax
135:	

malloc$37:	; minPrevBlockPtr = prevBlockPtr
136:		mov ax, [bp + 18]
137:		mov [bp + 16], ax
139:	

malloc$38:	; lastAddress = currAddress
140:		mov ax, [bp + 22]
141:		mov [bp + 12], ax
143:	

malloc$39:	; prevBlockPtr = currBlockPtr
144:		mov ax, [bp + 20]
145:		mov [bp + 18], ax
147:	

malloc$40:	; £temporary192 -> currBlockPtr = *currBlockPtr, offset 2
148:		mov si, [bp + 20]
150:	

malloc$41:	; currBlockPtr = £temporary192 -> currBlockPtr
151:		mov ax, [si + 2]
152:		mov [bp + 20], ax
154:	

malloc$42:	; goto 24
155:		jmp malloc$24
157:	

malloc$43:	; if minBlockPtr == 0 goto 64
158:		cmp word [bp + 14], 0
159:		je malloc$64
161:	

malloc$44:	; £temporary194 = int_to_int minBlockPtr (Pointer -> Unsigned_Int)
162:		mov ax, [bp + 14]
165:	

malloc$45:	; £temporary195 -> minBlockPtr = *minBlockPtr
166:		mov si, [bp + 14]
168:	

malloc$46:	; £temporary196 = £temporary194 + £temporary195 -> minBlockPtr
169:		add ax, [si]
171:	

malloc$47:	; £temporary197 = £temporary196 + 4
172:		add ax, 4
174:	

malloc$48:	; newAddress = £temporary197
175:		mov [bp + 22], ax
177:	

malloc$49:	; £temporary198 = int_to_int newAddress (Unsigned_Int -> Pointer)
178:		mov ax, [bp + 22]
181:	

malloc$50:	; newBlockPtr = £temporary198
182:		mov [bp + 24], ax
184:	

malloc$51:	; £temporary199 -> newBlockPtr = *newBlockPtr
185:		mov si, [bp + 24]
187:	

malloc$52:	; £temporary199 -> newBlockPtr = memorySize
188:		mov ax, [bp + 6]
189:		mov [si], ax
191:	

malloc$53:	; £temporary200 -> newBlockPtr = *newBlockPtr, offset 2
192:		mov si, [bp + 24]
194:	

malloc$54:	; £temporary200 -> newBlockPtr = minBlockPtr
195:		mov ax, [bp + 14]
196:		mov [si + 2], ax
198:	

malloc$55:	; if minPrevBlockPtr == 0 goto 59
199:		cmp word [bp + 16], 0
200:		je malloc$59
202:	

malloc$56:	; £temporary202 -> minPrevBlockPtr = *minPrevBlockPtr, offset 2
203:		mov si, [bp + 16]
205:	

malloc$57:	; £temporary202 -> minPrevBlockPtr = newBlockPtr
206:		mov ax, [bp + 24]
207:		mov [si + 2], ax
209:	

malloc$58:	; goto 60
210:		jmp malloc$60
212:	

malloc$59:	; g_firstBlockPtr = newBlockPtr
213:		mov ax, [bp + 24]
214:		mov [g_firstBlockPtr], ax
216:	

malloc$60:	; £temporary203 = newAddress + 4
217:		mov bx, [bp + 22]
218:		add bx, 4
220:	

malloc$61:	; £temporary204 = int_to_int £temporary203 (Unsigned_Int -> Pointer)
223:	

malloc$62:	; return_value = £temporary204
225:	

malloc$63:	; return
226:		mov ax, [bp]
227:		mov di, [bp + 4]
228:		mov bp, [bp + 2]
229:		jmp ax
231:	

malloc$64:	; £temporary205 = lastAddress - newBlockSize
232:		mov ax, [bp + 12]
233:		sub ax, [bp + 8]
235:	

malloc$65:	; newAddress = £temporary205
236:		mov [bp + 22], ax
238:	

malloc$66:	; £temporary206 = bp
240:	

malloc$67:	; stackTop = £temporary206
241:		mov [bp + 24], bp
243:	

malloc$68:	; if stackTop > newAddress goto 84
244:		mov ax, [bp + 24]
245:		cmp ax, [bp + 22]
246:		ja malloc$84
248:	

malloc$69:	; £temporary208 = int_to_int newAddress (Unsigned_Int -> Pointer)
249:		mov ax, [bp + 22]
252:	

malloc$70:	; newBlockPtr = £temporary208
253:		mov [bp + 26], ax
255:	

malloc$71:	; £temporary209 -> newBlockPtr = *newBlockPtr
256:		mov si, [bp + 26]
258:	

malloc$72:	; £temporary209 -> newBlockPtr = memorySize
259:		mov ax, [bp + 6]
260:		mov [si], ax
262:	

malloc$73:	; £temporary210 -> newBlockPtr = *newBlockPtr, offset 2
263:		mov si, [bp + 26]
265:	

malloc$74:	; £temporary210 -> newBlockPtr = 0
266:		mov word [si + 2], 0
268:	

malloc$75:	; if prevBlockPtr == 0 goto 79
269:		cmp word [bp + 18], 0
270:		je malloc$79
272:	

malloc$76:	; £temporary212 -> prevBlockPtr = *prevBlockPtr, offset 2
273:		mov si, [bp + 18]
275:	

malloc$77:	; £temporary212 -> prevBlockPtr = newBlockPtr
276:		mov ax, [bp + 26]
277:		mov [si + 2], ax
279:	

malloc$78:	; goto 80
280:		jmp malloc$80
282:	

malloc$79:	; g_firstBlockPtr = newBlockPtr
283:		mov ax, [bp + 26]
284:		mov [g_firstBlockPtr], ax
286:	

malloc$80:	; £temporary213 = newAddress + 4
287:		mov bx, [bp + 22]
288:		add bx, 4
290:	

malloc$81:	; £temporary214 = int_to_int £temporary213 (Unsigned_Int -> Pointer)
293:	

malloc$82:	; return_value = £temporary214
295:	

malloc$83:	; return
296:		mov ax, [bp]
297:		mov di, [bp + 4]
298:		mov bp, [bp + 2]
299:		jmp ax
301:	

malloc$84:	; return_value = 0
302:		mov bx, 0
304:	

malloc$85:	; return
305:		mov ax, [bp]
306:		mov di, [bp + 4]
307:		mov bp, [bp + 2]
308:		jmp ax
310:	

malloc$86:	; function end malloc
1:	

calloc:	; call header integral zero 0 stack zero 0
3:	

calloc$1:	; £temporary220 = number * size
4:		mov ax, [bp + 6]
6:		xor dx, dx
7:		imul word [bp + 8]
13:	

calloc$2:	; parameter £temporary220, offset 6
14:		mov [bp + 16], ax
16:	

calloc$3:	; call function noellipse-noellipse malloc
17:		mov word [bp + 10], calloc$4
18:		mov [bp + 12], bp
19:		add bp, 10
20:		jmp malloc
22:	

calloc$4:	; post call
24:	

calloc$5:	; £temporary221 = return_value
29:	

calloc$6:	; pointer = £temporary221
30:		mov [bp + 10], bx
32:	

calloc$7:	; if pointer == 0 goto 14
33:		cmp word [bp + 10], 0
34:		je calloc$14
36:	

calloc$8:	; call header integral zero 0 stack zero 0
38:	

calloc$9:	; parameter pointer, offset 6
39:		mov ax, [bp + 10]
40:		mov [bp + 18], ax
42:	

calloc$10:	; parameter 0, offset 8
43:		mov word [bp + 20], 0
45:	

calloc$11:	; parameter size, offset 10
46:		mov ax, [bp + 8]
47:		mov [bp + 22], ax
49:	

calloc$12:	; call function noellipse-noellipse memset
50:		mov word [bp + 12], calloc$13
51:		mov [bp + 14], bp
52:		add bp, 12
53:		jmp memset
55:	

calloc$13:	; post call
57:	

calloc$14:	; return_value = pointer
58:		mov bx, [bp + 10]
60:	

calloc$15:	; return
61:		mov ax, [bp]
62:		mov di, [bp + 4]
63:		mov bp, [bp + 2]
64:		jmp ax
66:	

calloc$16:	; function end calloc
1:	

free:	; if freeMemoryPtr != 0 goto 2
2:		cmp word [bp + 6], 0
3:		jne free$2
5:	

free$1:	; return
6:		mov ax, [bp]
7:		mov di, [bp + 4]
8:		mov bp, [bp + 2]
9:		jmp ax
11:	

free$2:	; £temporary229 = int_to_int freeMemoryPtr (Pointer -> Unsigned_Int)
12:		mov ax, [bp + 6]
15:	

free$3:	; £temporary230 = £temporary229 - 4
16:		sub ax, 4
18:	

free$4:	; £temporary231 = int_to_int £temporary230 (Unsigned_Int -> Pointer)
21:	

free$5:	; freeBlockPtr = £temporary231
22:		mov [bp + 8], ax
24:	

free$6:	; prevBlockPtr = 0
25:		mov word [bp + 10], 0
27:	

free$7:	; currBlockPtr = g_firstBlockPtr
28:		mov ax, [g_firstBlockPtr]
29:		mov [bp + 12], ax
31:	

free$8:	; if currBlockPtr == 0 goto 32
32:		cmp word [bp + 12], 0
33:		je free$32
35:	

free$9:	; if currBlockPtr != freeBlockPtr goto 28
36:		mov ax, [bp + 12]
37:		cmp ax, [bp + 8]
38:		jne free$28
40:	

free$10:	; if prevBlockPtr != 0 goto 15
41:		cmp word [bp + 10], 0
42:		jne free$15
44:	

free$11:	; £temporary235 -> currBlockPtr = *currBlockPtr, offset 2
45:		mov si, [bp + 12]
47:	

free$12:	; if £temporary235 -> currBlockPtr != 0 goto 15
48:		cmp word [si + 2], 0
49:		jne free$15
51:	

free$13:	; g_firstBlockPtr = 0
52:		mov word [g_firstBlockPtr], 0
54:	

free$14:	; goto 27
55:		jmp free$27
57:	

free$15:	; if prevBlockPtr != 0 goto 19
58:		cmp word [bp + 10], 0
59:		jne free$19
61:	

free$16:	; £temporary239 -> currBlockPtr = *currBlockPtr, offset 2
62:		mov si, [bp + 12]
64:	

free$17:	; g_firstBlockPtr = £temporary239 -> currBlockPtr
65:		mov ax, [si + 2]
66:		mov [g_firstBlockPtr], ax
68:	

free$18:	; goto 27
69:		jmp free$27
71:	

free$19:	; £temporary240 -> currBlockPtr = *currBlockPtr, offset 2
72:		mov si, [bp + 12]
74:	

free$20:	; if £temporary240 -> currBlockPtr != 0 goto 24
75:		cmp word [si + 2], 0
76:		jne free$24
78:	

free$21:	; £temporary242 -> prevBlockPtr = *prevBlockPtr, offset 2
79:		mov si, [bp + 10]
81:	

free$22:	; £temporary242 -> prevBlockPtr = 0
82:		mov word [si + 2], 0
84:	

free$23:	; goto 27
85:		jmp free$27
87:	

free$24:	; £temporary243 -> prevBlockPtr = *prevBlockPtr, offset 2
88:		mov si, [bp + 10]
90:	

free$25:	; £temporary244 -> currBlockPtr = *currBlockPtr, offset 2
91:		mov di, [bp + 12]
93:	

free$26:	; £temporary243 -> prevBlockPtr = £temporary244 -> currBlockPtr
94:		mov ax, [di + 2]
95:		mov [si + 2], ax
97:	

free$27:	; return
98:		mov ax, [bp]
99:		mov di, [bp + 4]
100:		mov bp, [bp + 2]
101:		jmp ax
103:	

free$28:	; prevBlockPtr = currBlockPtr
104:		mov ax, [bp + 12]
105:		mov [bp + 10], ax
107:	

free$29:	; £temporary245 -> currBlockPtr = *currBlockPtr, offset 2
108:		mov si, [bp + 12]
110:	

free$30:	; currBlockPtr = £temporary245 -> currBlockPtr
111:		mov ax, [si + 2]
112:		mov [bp + 12], ax
114:	

free$31:	; goto 8
115:		jmp free$8
117:	

free$32:	; return
118:		mov ax, [bp]
119:		mov di, [bp + 4]
120:		mov bp, [bp + 2]
121:		jmp ax
123:	

free$33:	; function end free
1:	

realloc:	; if newMemorySize >= 0 goto 12
2:		cmp word [bp + 8], 0
3:		jge realloc$12
5:	

realloc$1:	; call header integral zero 0 stack zero 0
7:	

realloc$2:	; parameter stderr, offset 6
8:		mov ax, [stderr]
9:		mov [bp + 16], ax
11:	

realloc$3:	; parameter string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#, offset 8
12:		mov word [bp + 18], string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#
14:	

realloc$4:	; parameter string_newMemorySize203E3D200#, offset 10
15:		mov word [bp + 20], string_newMemorySize203E3D200#
17:	

realloc$5:	; parameter string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#, offset 12
18:		mov word [bp + 22], string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#
20:	

realloc$6:	; parameter 239, offset 14
21:		mov word [bp + 24], 239
23:	

realloc$7:	; call function noellipse-ellipse fprintf, extra 0
24:		mov word [bp + 10], realloc$8
25:		mov [bp + 12], bp
26:		add bp, 10
27:		mov di, bp
28:		add di, 6
29:		jmp fprintf
31:	

realloc$8:	; post call
33:	

realloc$9:	; call header integral zero 0 stack zero 0
35:	

realloc$10:	; call function noellipse-noellipse abort
36:		mov word [bp + 10], realloc$11
37:		mov [bp + 12], bp
38:		add bp, 10
39:		jmp abort
41:	

realloc$11:	; post call
43:	

realloc$12:	; if oldMemoryPtr != 0 goto 25
44:		cmp word [bp + 6], 0
45:		jne realloc$25
47:	

realloc$13:	; if newMemorySize > 0 goto 25
48:		cmp word [bp + 8], 0
49:		jg realloc$25
51:	

realloc$14:	; call header integral zero 0 stack zero 0
53:	

realloc$15:	; parameter stderr, offset 6
54:		mov ax, [stderr]
55:		mov [bp + 16], ax
57:	

realloc$16:	; parameter string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#, offset 8
58:		mov word [bp + 18], string_Assertion20failed3A202225s2220in20file2025s20at20line2025i0A#
60:	

realloc$17:	; parameter string_2820oldMemoryPtr20213D20NULL2029207C7C202820newMemorySize203E2002029#, offset 10
61:		mov word [bp + 20], string_2820oldMemoryPtr20213D20NULL2029207C7C202820newMemorySize203E2002029#
63:	

realloc$18:	; parameter string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#, offset 12
64:		mov word [bp + 22], string_C3A5CUsers5CStefan5CDocuments5Cvagrant5Chomestead5Ccode5Ccode5CMalloc2Ec#
66:	

realloc$19:	; parameter 240, offset 14
67:		mov word [bp + 24], 240
69:	

realloc$20:	; call function noellipse-ellipse fprintf, extra 0
70:		mov word [bp + 10], realloc$21
71:		mov [bp + 12], bp
72:		add bp, 10
73:		mov di, bp
74:		add di, 6
75:		jmp fprintf
77:	

realloc$21:	; post call
79:	

realloc$22:	; call header integral zero 0 stack zero 0
81:	

realloc$23:	; call function noellipse-noellipse abort
82:		mov word [bp + 10], realloc$24
83:		mov [bp + 12], bp
84:		add bp, 10
85:		jmp abort
87:	

realloc$24:	; post call
89:	

realloc$25:	; if oldMemoryPtr != 0 goto 33
90:		cmp word [bp + 6], 0
91:		jne realloc$33
93:	

realloc$26:	; call header integral zero 0 stack zero 0
95:	

realloc$27:	; parameter newMemorySize, offset 6
96:		mov ax, [bp + 8]
97:		mov [bp + 16], ax
99:	

realloc$28:	; call function noellipse-noellipse malloc
100:		mov word [bp + 10], realloc$29
101:		mov [bp + 12], bp
102:		add bp, 10
103:		jmp malloc
105:	

realloc$29:	; post call
107:	

realloc$30:	; £temporary257 = return_value
112:	

realloc$31:	; return_value = £temporary257
114:	

realloc$32:	; return
115:		mov ax, [bp]
116:		mov di, [bp + 4]
117:		mov bp, [bp + 2]
118:		jmp ax
120:	

realloc$33:	; if newMemorySize != 0 goto 40
121:		cmp word [bp + 8], 0
122:		jne realloc$40
124:	

realloc$34:	; call header integral zero 0 stack zero 0
126:	

realloc$35:	; parameter oldMemoryPtr, offset 6
127:		mov ax, [bp + 6]
128:		mov [bp + 16], ax
130:	

realloc$36:	; call function noellipse-noellipse free
131:		mov word [bp + 10], realloc$37
132:		mov [bp + 12], bp
133:		add bp, 10
134:		jmp free
136:	

realloc$37:	; post call
138:	

realloc$38:	; return_value = 0
139:		mov bx, 0
141:	

realloc$39:	; return
142:		mov ax, [bp]
143:		mov di, [bp + 4]
144:		mov bp, [bp + 2]
145:		jmp ax
147:	

realloc$40:	; £temporary260 = int_to_int newMemorySize (Signed_Int -> Unsigned_Int)
148:		mov ax, [bp + 8]
151:	

realloc$41:	; £temporary261 = £temporary260 + 4
152:		add ax, 4
154:	

realloc$42:	; newBlockSize = £temporary261
155:		mov [bp + 10], ax
157:	

realloc$43:	; £temporary262 = int_to_int oldMemoryPtr (Pointer -> Unsigned_Int)
158:		mov ax, [bp + 6]
161:	

realloc$44:	; £temporary263 = £temporary262 - 4
162:		sub ax, 4
164:	

realloc$45:	; £temporary264 = int_to_int £temporary263 (Unsigned_Int -> Pointer)
167:	

realloc$46:	; oldBlockPtr = £temporary264
168:		mov [bp + 12], ax
170:	

realloc$47:	; £temporary265 -> oldBlockPtr = *oldBlockPtr
171:		mov si, [bp + 12]
173:	

realloc$48:	; if newBlockSize > £temporary265 -> oldBlockPtr goto 53
174:		mov ax, [bp + 10]
175:		cmp ax, [si]
176:		ja realloc$53
178:	

realloc$49:	; £temporary267 -> oldBlockPtr = *oldBlockPtr
179:		mov si, [bp + 12]
181:	

realloc$50:	; £temporary267 -> oldBlockPtr = newBlockSize
182:		mov ax, [bp + 10]
183:		mov [si], ax
185:	

realloc$51:	; return_value = oldMemoryPtr
186:		mov bx, [bp + 6]
188:	

realloc$52:	; return
189:		mov ax, [bp]
190:		mov di, [bp + 4]
191:		mov bp, [bp + 2]
192:		jmp ax
194:	

realloc$53:	; lastAddress = 65528
195:		mov word [bp + 14], 65528
197:	

realloc$54:	; currBlockPtr = g_firstBlockPtr
198:		mov ax, [g_firstBlockPtr]
199:		mov [bp + 16], ax
201:	

realloc$55:	; if currBlockPtr == 0 goto 70
202:		cmp word [bp + 16], 0
203:		je realloc$70
205:	

realloc$56:	; if currBlockPtr != oldBlockPtr goto 65
206:		mov ax, [bp + 16]
207:		cmp ax, [bp + 12]
208:		jne realloc$65
210:	

realloc$57:	; £temporary270 = int_to_int currBlockPtr (Pointer -> Unsigned_Int)
211:		mov ax, [bp + 16]
214:	

realloc$58:	; £temporary271 = lastAddress - £temporary270
215:		mov bx, [bp + 14]
216:		sub bx, ax
218:	

realloc$59:	; availableSize = £temporary271
219:		mov [bp + 18], bx
221:	

realloc$60:	; if availableSize < newBlockSize goto 70
222:		mov ax, [bp + 18]
223:		cmp ax, [bp + 10]
224:		jb realloc$70
226:	

realloc$61:	; £temporary273 -> oldBlockPtr = *oldBlockPtr
227:		mov si, [bp + 12]
229:	

realloc$62:	; £temporary273 -> oldBlockPtr = newBlockSize
230:		mov ax, [bp + 10]
231:		mov [si], ax
233:	

realloc$63:	; return_value = oldMemoryPtr
234:		mov bx, [bp + 6]
236:	

realloc$64:	; return
237:		mov ax, [bp]
238:		mov di, [bp + 4]
239:		mov bp, [bp + 2]
240:		jmp ax
242:	

realloc$65:	; £temporary274 = int_to_int currBlockPtr (Pointer -> Unsigned_Int)
243:		mov ax, [bp + 16]
246:	

realloc$66:	; lastAddress = £temporary274
247:		mov [bp + 14], ax
249:	

realloc$67:	; £temporary275 -> currBlockPtr = *currBlockPtr, offset 2
250:		mov si, [bp + 16]
252:	

realloc$68:	; currBlockPtr = £temporary275 -> currBlockPtr
253:		mov ax, [si + 2]
254:		mov [bp + 16], ax
256:	

realloc$69:	; goto 55
257:		jmp realloc$55
259:	

realloc$70:	; call header integral zero 0 stack zero 0
261:	

realloc$71:	; parameter newMemorySize, offset 6
262:		mov ax, [bp + 8]
263:		mov [bp + 24], ax
265:	

realloc$72:	; call function noellipse-noellipse malloc
266:		mov word [bp + 18], realloc$73
267:		mov [bp + 20], bp
268:		add bp, 18
269:		jmp malloc
271:	

realloc$73:	; post call
273:	

realloc$74:	; £temporary276 = return_value
278:	

realloc$75:	; newMemoryPtr = £temporary276
279:		mov [bp + 18], bx
281:	

realloc$76:	; if newMemoryPtr == 0 goto 89
282:		cmp word [bp + 18], 0
283:		je realloc$89
285:	

realloc$77:	; call header integral zero 0 stack zero 0
287:	

realloc$78:	; parameter newMemoryPtr, offset 6
288:		mov ax, [bp + 18]
289:		mov [bp + 26], ax
291:	

realloc$79:	; parameter oldMemoryPtr, offset 8
292:		mov ax, [bp + 6]
293:		mov [bp + 28], ax
295:	

realloc$80:	; parameter newMemorySize, offset 10
296:		mov ax, [bp + 8]
297:		mov [bp + 30], ax
299:	

realloc$81:	; call function noellipse-noellipse memcpy
300:		mov word [bp + 20], realloc$82
301:		mov [bp + 22], bp
302:		add bp, 20
303:		jmp memcpy
305:	

realloc$82:	; post call
307:	

realloc$83:	; call header integral zero 0 stack zero 0
309:	

realloc$84:	; parameter oldMemoryPtr, offset 6
310:		mov ax, [bp + 6]
311:		mov [bp + 26], ax
313:	

realloc$85:	; call function noellipse-noellipse free
314:		mov word [bp + 20], realloc$86
315:		mov [bp + 22], bp
316:		add bp, 20
317:		jmp free
319:	

realloc$86:	; post call
321:	

realloc$87:	; return_value = newMemoryPtr
322:		mov bx, [bp + 18]
324:	

realloc$88:	; return
325:		mov ax, [bp]
326:		mov di, [bp + 4]
327:		mov bp, [bp + 2]
328:		jmp ax
330:	

realloc$89:	; return_value = 0
331:		mov bx, 0
333:	

realloc$90:	; return
334:		mov ax, [bp]
335:		mov di, [bp + 4]
336:		mov bp, [bp + 2]
337:		jmp ax
339:	

realloc$91:	; function end realloc
1:	

print_heap:	; currBlockPtr = g_firstBlockPtr
2:		mov ax, [g_firstBlockPtr]
3:		mov [bp + 6], ax
5:	

print_heap$1:	; call header integral zero 0 stack zero 0
7:	

print_heap$2:	; parameter string_Heap3A0A#, offset 6
8:		mov word [bp + 14], string_Heap3A0A#
10:	

print_heap$3:	; call function noellipse-ellipse printf, extra 0
11:		mov word [bp + 8], print_heap$4
12:		mov [bp + 10], bp
13:		add bp, 8
14:		mov di, bp
15:		jmp printf
17:	

print_heap$4:	; post call
19:	

print_heap$5:	; if currBlockPtr == 0 goto 17
20:		cmp word [bp + 6], 0
21:		je print_heap$17
23:	

print_heap$6:	; call header integral zero 0 stack zero 0
25:	

print_heap$7:	; parameter string_2020Address2025u2C20Size2025u0A#, offset 6
26:		mov word [bp + 14], string_2020Address2025u2C20Size2025u0A#
28:	

print_heap$8:	; £temporary299 = int_to_int currBlockPtr (Pointer -> Unsigned_Int)
29:		mov ax, [bp + 6]
32:	

print_heap$9:	; parameter £temporary299, offset 8
33:		mov [bp + 16], ax
35:	

print_heap$10:	; £temporary300 -> currBlockPtr = *currBlockPtr
36:		mov si, [bp + 6]
38:	

print_heap$11:	; parameter £temporary300 -> currBlockPtr, offset 10
39:		mov ax, [si]
40:		mov [bp + 18], ax
42:	

print_heap$12:	; call function noellipse-ellipse printf, extra 0
43:		mov word [bp + 8], print_heap$13
44:		mov [bp + 10], bp
45:		add bp, 8
46:		mov di, bp
47:		add di, 4
48:		jmp printf
50:	

print_heap$13:	; post call
52:	

print_heap$14:	; £temporary302 -> currBlockPtr = *currBlockPtr, offset 2
53:		mov si, [bp + 6]
55:	

print_heap$15:	; currBlockPtr = £temporary302 -> currBlockPtr
56:		mov ax, [si + 2]
57:		mov [bp + 6], ax
59:	

print_heap$16:	; goto 5
60:		jmp print_heap$5
62:	

print_heap$17:	; call header integral zero 0 stack zero 0
64:	

print_heap$18:	; parameter string_0A#, offset 6
65:		mov word [bp + 14], string_0A#
67:	

print_heap$19:	; call function noellipse-ellipse printf, extra 0
68:		mov word [bp + 8], print_heap$20
69:		mov [bp + 10], bp
70:		add bp, 8
71:		mov di, bp
72:		jmp printf
74:	

print_heap$20:	; post call
76:	

print_heap$21:	; return
77:		mov ax, [bp]
78:		mov di, [bp + 4]
79:		mov bp, [bp + 2]
80:		jmp ax
82:	

print_heap$22:	; function end print_heap
