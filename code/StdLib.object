1:	

atoi:	; call header integral zero 0 stack zero 0
3:	

atoi$1:	; parameter s, offset 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

atoi$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atoi$3:	; parameter 10, offset 10
11:		mov word [bp + 18], 10
13:	

atoi$4:	; call function noellipse-noellipse strtol
14:		mov word [bp + 8], atoi$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp strtol
19:	

atoi$5:	; post call
21:	

atoi$6:	; £temporary2467 = return_value
26:	

atoi$7:	; £temporary2468 = int_to_int £temporary2467 (Signed_Long_Int -> Signed_Int)
29:		cmp ebx, 0
30:		jge atoi$8
31:		neg ebx
33:		neg bx
35:	

atoi$8:	; return_value = £temporary2468
37:	

atoi$9:	; return
38:		mov ax, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp ax
43:	

atoi$10:	; function end atoi
1:	

atol:	; call header integral zero 0 stack zero 0
3:	

atol$1:	; parameter s, offset 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

atol$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atol$3:	; parameter 10, offset 10
11:		mov word [bp + 18], 10
13:	

atol$4:	; call function noellipse-noellipse strtol
14:		mov word [bp + 8], atol$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp strtol
19:	

atol$5:	; post call
21:	

atol$6:	; £temporary2472 = return_value
26:	

atol$7:	; return_value = £temporary2472
28:	

atol$8:	; return
29:		mov ax, [bp]
30:		mov di, [bp + 4]
31:		mov bp, [bp + 2]
32:		jmp ax
34:	

atol$9:	; function end atol
1:	

strtol:	; chars = 0
2:		mov word [bp + 12], 0
4:	

strtol$1:	; value = 0
5:		mov dword [bp + 14], 0
7:	

strtol$2:	; call header integral zero 0 stack zero 0
9:	

strtol$3:	; parameter s, offset 6
10:		mov ax, [bp + 6]
11:		mov [bp + 24], ax
13:	

strtol$4:	; parameter string_25li25n#, offset 8
14:		mov word [bp + 26], string_25li25n#
16:	

strtol$5:	; £temporary2476 = &value
17:		mov si, bp
18:		add si, 14
20:	

strtol$6:	; parameter £temporary2476, offset 10
21:		mov [bp + 28], si
23:	

strtol$7:	; £temporary2477 = &chars
24:		mov si, bp
25:		add si, 12
27:	

strtol$8:	; parameter £temporary2477, offset 12
28:		mov [bp + 30], si
30:	

strtol$9:	; call function noellipse-ellipse sscanf, extra 0
31:		mov word [bp + 18], strtol$10
32:		mov [bp + 20], bp
33:		add bp, 18
34:		mov di, bp
35:		add di, 4
36:		jmp sscanf
38:	

strtol$10:	; post call
40:	

strtol$11:	; if endp == 0 goto 15
41:		cmp word [bp + 8], 0
42:		je strtol$15
44:	

strtol$12:	; £temporary2480 -> endp = *endp
45:		mov si, [bp + 8]
47:	

strtol$13:	; £temporary2481 = s + chars
48:		mov ax, [bp + 6]
49:		add ax, [bp + 12]
51:	

strtol$14:	; £temporary2480 -> endp = £temporary2481
52:		mov [si], ax
54:	

strtol$15:	; return_value = value
55:		mov ebx, [bp + 14]
57:	

strtol$16:	; return
58:		mov ax, [bp]
59:		mov di, [bp + 4]
60:		mov bp, [bp + 2]
61:		jmp ax
63:	

strtol$17:	; function end strtol
1:	

strtoul:	; chars = 0
2:		mov word [bp + 12], 0
4:	

strtoul$1:	; value = 0
5:		mov dword [bp + 14], 0
7:	

strtoul$2:	; call header integral zero 0 stack zero 0
9:	

strtoul$3:	; parameter s, offset 6
10:		mov ax, [bp + 6]
11:		mov [bp + 24], ax
13:	

strtoul$4:	; parameter string_25lu25n#, offset 8
14:		mov word [bp + 26], string_25lu25n#
16:	

strtoul$5:	; £temporary2488 = &value
17:		mov si, bp
18:		add si, 14
20:	

strtoul$6:	; parameter £temporary2488, offset 10
21:		mov [bp + 28], si
23:	

strtoul$7:	; £temporary2489 = &chars
24:		mov si, bp
25:		add si, 12
27:	

strtoul$8:	; parameter £temporary2489, offset 12
28:		mov [bp + 30], si
30:	

strtoul$9:	; call function noellipse-ellipse sscanf, extra 0
31:		mov word [bp + 18], strtoul$10
32:		mov [bp + 20], bp
33:		add bp, 18
34:		mov di, bp
35:		add di, 4
36:		jmp sscanf
38:	

strtoul$10:	; post call
40:	

strtoul$11:	; if endp == 0 goto 15
41:		cmp word [bp + 8], 0
42:		je strtoul$15
44:	

strtoul$12:	; £temporary2492 -> endp = *endp
45:		mov si, [bp + 8]
47:	

strtoul$13:	; £temporary2493 = s + chars
48:		mov ax, [bp + 6]
49:		add ax, [bp + 12]
51:	

strtoul$14:	; £temporary2492 -> endp = £temporary2493
52:		mov [si], ax
54:	

strtoul$15:	; return_value = value
55:		mov ebx, [bp + 14]
57:	

strtoul$16:	; return
58:		mov ax, [bp]
59:		mov di, [bp + 4]
60:		mov bp, [bp + 2]
61:		jmp ax
63:	

strtoul$17:	; function end strtoul
1:	

atof:	; call header integral zero 0 stack zero 0
3:	

atof$1:	; parameter s, offset 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

atof$2:	; parameter 0, offset 8
8:		mov word [bp + 16], 0
10:	

atof$3:	; call function noellipse-noellipse strtod
11:		mov word [bp + 8], atof$4
12:		mov [bp + 10], bp
13:		add bp, 8
14:		jmp strtod
16:	

atof$4:	; post call
18:	

atof$5:	; £temporary2500 = return_value
20:	

atof$6:	; return_value = £temporary2500
22:	

atof$7:	; return
23:		mov ax, [bp]
24:		mov di, [bp + 4]
25:		mov bp, [bp + 2]
26:		jmp ax
28:	

atof$8:	; function end atof
1:	

strtod:	; chars = 0
2:		mov word [bp + 10], 0
4:	

strtod$1:	; push 0
5:		fldz
7:	

strtod$2:	; pop float value
8:		fstp qword [bp + 12]
10:	

strtod$3:	; call header integral zero 0 stack zero 0
12:	

strtod$4:	; parameter s, offset 6
13:		mov ax, [bp + 6]
14:		mov [bp + 26], ax
16:	

strtod$5:	; parameter string_25lf25n#, offset 8
17:		mov word [bp + 28], string_25lf25n#
19:	

strtod$6:	; £temporary2503 = &value
20:		mov si, bp
21:		add si, 12
23:	

strtod$7:	; parameter £temporary2503, offset 10
24:		mov [bp + 30], si
26:	

strtod$8:	; £temporary2504 = &chars
27:		mov si, bp
28:		add si, 10
30:	

strtod$9:	; parameter £temporary2504, offset 12
31:		mov [bp + 32], si
33:	

strtod$10:	; call function noellipse-ellipse sscanf, extra 0
34:		mov word [bp + 20], strtod$11
35:		mov [bp + 22], bp
36:		add bp, 20
37:		mov di, bp
38:		add di, 4
39:		jmp sscanf
41:	

strtod$11:	; post call
43:	

strtod$12:	; if endp == 0 goto 16
44:		cmp word [bp + 8], 0
45:		je strtod$16
47:	

strtod$13:	; £temporary2507 -> endp = *endp
48:		mov si, [bp + 8]
50:	

strtod$14:	; £temporary2508 = s + chars
51:		mov ax, [bp + 6]
52:		add ax, [bp + 10]
54:	

strtod$15:	; £temporary2507 -> endp = £temporary2508
55:		mov [si], ax
57:	

strtod$16:	; push float value
58:		fld qword [bp + 12]
60:	

strtod$17:	; return_value = value
62:	

strtod$18:	; return
63:		mov ax, [bp]
64:		mov di, [bp + 4]
65:		mov bp, [bp + 2]
66:		jmp ax
68:	

strtod$19:	; function end strtod
1:	

abort:	; ah = 76
2:		mov ah, 76
4:	

abort$1:	; al = -1
5:		mov al, -1
7:	

abort$2:	; interrupt 33
8:		int 33
10:	

abort$3:	; return
11:		mov ax, [bp]
12:		mov di, [bp + 4]
13:		mov bp, [bp + 2]
14:		jmp ax
16:	

abort$4:	; function end abort
1:	

getenv:	; return_value = 0
2:		mov bx, 0
4:	

getenv$1:	; return
5:		mov ax, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp ax
10:	

getenv$2:	; function end getenv
1:	

system:	; return_value = -1
2:		mov bx, -1
4:	

system$1:	; return
5:		mov ax, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp ax
10:	

system$2:	; function end system
1:	

memswp:	; £temporary2517 = int_to_int value1 (Pointer -> Pointer)
2:		mov ax, [bp + 6]
5:	

memswp$1:	; charValue1 = £temporary2517
6:		mov [bp + 12], ax
8:	

memswp$2:	; £temporary2518 = int_to_int value2 (Pointer -> Pointer)
9:		mov ax, [bp + 8]
12:	

memswp$3:	; charValue2 = £temporary2518
13:		mov [bp + 14], ax
15:	

memswp$4:	; index = 0
16:		mov word [bp + 16], 0
18:	

memswp$5:	; if index >= valueSize goto 19
19:		mov ax, [bp + 16]
20:		cmp ax, [bp + 10]
21:		jge memswp$19
23:	

memswp$6:	; £temporary2522 = charValue1 + index
24:		mov si, [bp + 12]
25:		add si, [bp + 16]
27:	

memswp$7:	; £temporary2521 -> £temporary2522 = *£temporary2522
29:	

memswp$8:	; tempValue = £temporary2521 -> £temporary2522
30:		mov al, [si]
31:		mov [bp + 18], al
33:	

memswp$9:	; £temporary2524 = charValue1 + index
34:		mov si, [bp + 12]
35:		add si, [bp + 16]
37:	

memswp$10:	; £temporary2523 -> £temporary2524 = *£temporary2524
39:	

memswp$11:	; £temporary2526 = charValue2 + index
40:		mov di, [bp + 14]
41:		add di, [bp + 16]
43:	

memswp$12:	; £temporary2525 -> £temporary2526 = *£temporary2526
45:	

memswp$13:	; £temporary2523 -> £temporary2524 = £temporary2525 -> £temporary2526
46:		mov al, [di]
47:		mov [si], al
49:	

memswp$14:	; £temporary2528 = charValue2 + index
50:		mov si, [bp + 14]
51:		add si, [bp + 16]
53:	

memswp$15:	; £temporary2527 -> £temporary2528 = *£temporary2528
55:	

memswp$16:	; £temporary2527 -> £temporary2528 = tempValue
56:		mov al, [bp + 18]
57:		mov [si], al
59:	

memswp$17:	; ++index
60:		inc word [bp + 16]
62:	

memswp$18:	; goto 5
63:		jmp memswp$5
65:	

memswp$19:	; return
66:		mov ax, [bp]
67:		mov di, [bp + 4]
68:		mov bp, [bp + 2]
69:		jmp ax
71:	

memswp$20:	; function end memswp
1:	

bsearch:	; firstIndex = 0
2:		mov word [bp + 16], 0
4:	

bsearch$1:	; £temporary2529 = listSize - 1
5:		mov ax, [bp + 10]
6:		sub ax, 1
8:	

bsearch$2:	; lastIndex = £temporary2529
9:		mov [bp + 18], ax
11:	

bsearch$3:	; if listSize != 0 goto 6
12:		cmp word [bp + 10], 0
13:		jne bsearch$6
15:	

bsearch$4:	; return_value = 0
16:		mov bx, 0
18:	

bsearch$5:	; return
19:		mov ax, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp ax
24:	

bsearch$6:	; £temporary2531 = int_to_int valueList (Pointer -> Pointer)
25:		mov bx, [bp + 8]
28:	

bsearch$7:	; £temporary2532 = firstIndex * valueSize
29:		mov ax, [bp + 16]
31:		xor dx, dx
32:		imul word [bp + 12]
38:	

bsearch$8:	; £temporary2533 = £temporary2531 + £temporary2532
39:		add bx, ax
41:	

bsearch$9:	; firstValuePtr = £temporary2533
42:		mov [bp + 20], bx
44:	

bsearch$10:	; call header integral zero 0 stack zero 0
46:	

bsearch$11:	; parameter keyPtr, offset 6
47:		mov ax, [bp + 6]
48:		mov [bp + 28], ax
50:	

bsearch$12:	; parameter firstValuePtr, offset 8
51:		mov ax, [bp + 20]
52:		mov [bp + 30], ax
54:	

bsearch$13:	; call function noellipse-noellipse compare
55:		mov word [bp + 22], bsearch$14
56:		mov [bp + 24], bp
57:		mov ax, [bp + 14]
58:		add bp, 22
59:		jmp ax
61:	

bsearch$14:	; post call
63:	

bsearch$15:	; £temporary2534 = return_value
68:	

bsearch$16:	; firstCompare = £temporary2534
69:		mov [bp + 22], bx
71:	

bsearch$17:	; if firstCompare >= 0 goto 20
72:		cmp word [bp + 22], 0
73:		jge bsearch$20
75:	

bsearch$18:	; return_value = 0
76:		mov bx, 0
78:	

bsearch$19:	; return
79:		mov ax, [bp]
80:		mov di, [bp + 4]
81:		mov bp, [bp + 2]
82:		jmp ax
84:	

bsearch$20:	; if firstCompare != 0 goto 23
85:		cmp word [bp + 22], 0
86:		jne bsearch$23
88:	

bsearch$21:	; return_value = firstValuePtr
89:		mov bx, [bp + 20]
91:	

bsearch$22:	; return
92:		mov ax, [bp]
93:		mov di, [bp + 4]
94:		mov bp, [bp + 2]
95:		jmp ax
97:	

bsearch$23:	; £temporary2537 = int_to_int valueList (Pointer -> Pointer)
98:		mov bx, [bp + 8]
101:	

bsearch$24:	; £temporary2538 = lastIndex * valueSize
102:		mov ax, [bp + 18]
104:		xor dx, dx
105:		imul word [bp + 12]
111:	

bsearch$25:	; £temporary2539 = £temporary2537 + £temporary2538
112:		add bx, ax
114:	

bsearch$26:	; lastValuePtr = £temporary2539
115:		mov [bp + 20], bx
117:	

bsearch$27:	; call header integral zero 0 stack zero 0
119:	

bsearch$28:	; parameter keyPtr, offset 6
120:		mov ax, [bp + 6]
121:		mov [bp + 28], ax
123:	

bsearch$29:	; parameter lastValuePtr, offset 8
124:		mov ax, [bp + 20]
125:		mov [bp + 30], ax
127:	

bsearch$30:	; call function noellipse-noellipse compare
128:		mov word [bp + 22], bsearch$31
129:		mov [bp + 24], bp
130:		mov ax, [bp + 14]
131:		add bp, 22
132:		jmp ax
134:	

bsearch$31:	; post call
136:	

bsearch$32:	; £temporary2540 = return_value
141:	

bsearch$33:	; lastCompare = £temporary2540
142:		mov [bp + 22], bx
144:	

bsearch$34:	; if lastCompare <= 0 goto 37
145:		cmp word [bp + 22], 0
146:		jle bsearch$37
148:	

bsearch$35:	; return_value = 0
149:		mov bx, 0
151:	

bsearch$36:	; return
152:		mov ax, [bp]
153:		mov di, [bp + 4]
154:		mov bp, [bp + 2]
155:		jmp ax
157:	

bsearch$37:	; if lastCompare != 0 goto 40
158:		cmp word [bp + 22], 0
159:		jne bsearch$40
161:	

bsearch$38:	; return_value = lastValuePtr
162:		mov bx, [bp + 20]
164:	

bsearch$39:	; return
165:		mov ax, [bp]
166:		mov di, [bp + 4]
167:		mov bp, [bp + 2]
168:		jmp ax
170:	

bsearch$40:	; £temporary2543 = firstIndex + lastIndex
171:		mov ax, [bp + 16]
172:		add ax, [bp + 18]
174:	

bsearch$41:	; £temporary2544 = £temporary2543 / 2
176:		xor dx, dx
177:		idiv word [int2$2#]
183:	

bsearch$42:	; middleIndex = £temporary2544
184:		mov [bp + 20], ax
186:	

bsearch$43:	; £temporary2545 = int_to_int valueList (Pointer -> Pointer)
187:		mov bx, [bp + 8]
190:	

bsearch$44:	; £temporary2546 = middleIndex * valueSize
191:		mov ax, [bp + 20]
193:		xor dx, dx
194:		imul word [bp + 12]
200:	

bsearch$45:	; £temporary2547 = £temporary2545 + £temporary2546
201:		add bx, ax
203:	

bsearch$46:	; middleValuePtr = £temporary2547
204:		mov [bp + 22], bx
206:	

bsearch$47:	; call header integral zero 0 stack zero 0
208:	

bsearch$48:	; parameter keyPtr, offset 6
209:		mov ax, [bp + 6]
210:		mov [bp + 30], ax
212:	

bsearch$49:	; parameter middleValuePtr, offset 8
213:		mov ax, [bp + 22]
214:		mov [bp + 32], ax
216:	

bsearch$50:	; call function noellipse-noellipse compare
217:		mov word [bp + 24], bsearch$51
218:		mov [bp + 26], bp
219:		mov ax, [bp + 14]
220:		add bp, 24
221:		jmp ax
223:	

bsearch$51:	; post call
225:	

bsearch$52:	; £temporary2548 = return_value
230:	

bsearch$53:	; middleCompare = £temporary2548
231:		mov [bp + 24], bx
233:	

bsearch$54:	; if middleCompare >= 0 goto 57
234:		cmp word [bp + 24], 0
235:		jge bsearch$57
237:	

bsearch$55:	; lastIndex = middleIndex
238:		mov ax, [bp + 20]
239:		mov [bp + 18], ax
241:	

bsearch$56:	; goto 6
242:		jmp bsearch$6
244:	

bsearch$57:	; if middleCompare <= 0 goto 60
245:		cmp word [bp + 24], 0
246:		jle bsearch$60
248:	

bsearch$58:	; firstIndex = middleIndex
249:		mov ax, [bp + 20]
250:		mov [bp + 16], ax
252:	

bsearch$59:	; goto 6
253:		jmp bsearch$6
255:	

bsearch$60:	; return_value = middleValuePtr
256:		mov bx, [bp + 22]
258:	

bsearch$61:	; return
259:		mov ax, [bp]
260:		mov di, [bp + 4]
261:		mov bp, [bp + 2]
262:		jmp ax
264:	

bsearch$62:	; function end bsearch
1:	

rand:	; £temporary2558 = g_randValue * 1664525
2:		mov eax, [@29$g_randValue]
4:		xor edx, edx
5:		imul dword [int4$1664525#]
11:	

rand$1:	; £temporary2559 = £temporary2558 + 1013904223
12:		add eax, 1013904223
14:	

rand$2:	; £temporary2560 = £temporary2559 % 127
16:		xor edx, edx
17:		idiv dword [int4$127#]
23:	

rand$3:	; g_randValue = £temporary2560
24:		mov [@29$g_randValue], edx
26:	

rand$4:	; £temporary2561 = int_to_int g_randValue (Signed_Long_Int -> Signed_Int)
27:		mov ebx, [@29$g_randValue]
30:		cmp ebx, 0
31:		jge rand$5
32:		neg ebx
34:		neg bx
36:	

rand$5:	; return_value = £temporary2561
38:	

rand$6:	; return
39:		mov ax, [bp]
40:		mov di, [bp + 4]
41:		mov bp, [bp + 2]
42:		jmp ax
44:	

rand$7:	; function end rand
1:	

srand:	; £temporary2562 = int_to_int seed (Unsigned_Int -> Signed_Long_Int)
2:		mov ax, [bp + 6]
4:		and eax, 65535
6:	

srand$1:	; g_randValue = £temporary2562
7:		mov [@29$g_randValue], eax
9:	

srand$2:	; return
10:		mov ax, [bp]
11:		mov di, [bp + 4]
12:		mov bp, [bp + 2]
13:		jmp ax
15:	

srand$3:	; function end srand
1:	

print_heap2:	; heapBottom = (int2$32764#,0)
2:		mov ax, [int2$32764#]
3:		mov [bp + 6], ax
5:	

print_heap2$1:	; topStack = (int2$32766#,0)
6:		mov ax, [int2$32766#]
7:		mov [bp + 8], ax
9:	

print_heap2$2:	; heapTop = (int2$32762#,0)
10:		mov ax, [int2$32762#]
11:		mov [bp + 10], ax
13:	

print_heap2$3:	; index = 0
14:		mov word [bp + 12], 0
16:	

print_heap2$4:	; call header integral zero 0 stack zero 0
18:	

print_heap2$5:	; parameter string_stack20top2025u2C20heap20top2025u2C20heap20bottom2025u0A#, offset 6
19:		mov word [bp + 20], string_stack20top2025u2C20heap20top2025u2C20heap20bottom2025u0A#
21:	

print_heap2$6:	; parameter topStack, offset 8
22:		mov ax, [bp + 8]
23:		mov [bp + 22], ax
25:	

print_heap2$7:	; parameter heapTop, offset 10
26:		mov ax, [bp + 10]
27:		mov [bp + 24], ax
29:	

print_heap2$8:	; parameter heapBottom, offset 12
30:		mov ax, [bp + 6]
31:		mov [bp + 26], ax
33:	

print_heap2$9:	; call function noellipse-ellipse printf, extra 0
34:		mov word [bp + 14], print_heap2$10
35:		mov [bp + 16], bp
36:		add bp, 14
37:		mov di, bp
38:		add di, 6
39:		jmp printf
41:	

print_heap2$10:	; post call
43:	

print_heap2$11:	; if heapTop == 0 goto 29
44:		cmp word [bp + 10], 0
45:		je print_heap2$29
47:	

print_heap2$12:	; £temporary2568 = int_to_int heapTop (Unsigned_Int -> Pointer)
48:		mov si, [bp + 10]
51:	

print_heap2$13:	; £temporary2569 = £temporary2568 + 2
52:		add si, 2
54:	

print_heap2$14:	; £temporary2570 -> £temporary2569 = *£temporary2569
56:	

print_heap2$15:	; size = £temporary2570 -> £temporary2569
57:		mov ax, [si]
58:		mov [bp + 14], ax
60:	

print_heap2$16:	; call header integral zero 0 stack zero 0
62:	

print_heap2$17:	; parameter string_2020index2025u2C20address2025u2C20size2025u0A#, offset 6
63:		mov word [bp + 22], string_2020index2025u2C20address2025u2C20size2025u0A#
65:	

print_heap2$18:	; £temporary2571 = index
66:		mov ax, [bp + 12]
68:	

print_heap2$19:	; ++index
69:		inc word [bp + 12]
71:	

print_heap2$20:	; parameter £temporary2571, offset 8
72:		mov [bp + 24], ax
74:	

print_heap2$21:	; parameter heapTop, offset 10
75:		mov ax, [bp + 10]
76:		mov [bp + 26], ax
78:	

print_heap2$22:	; parameter size, offset 12
79:		mov ax, [bp + 14]
80:		mov [bp + 28], ax
82:	

print_heap2$23:	; call function noellipse-ellipse printf, extra 0
83:		mov word [bp + 16], print_heap2$24
84:		mov [bp + 18], bp
85:		add bp, 16
86:		mov di, bp
87:		add di, 6
88:		jmp printf
90:	

print_heap2$24:	; post call
92:	

print_heap2$25:	; £temporary2573 = int_to_int heapTop (Unsigned_Int -> Pointer)
93:		mov si, [bp + 10]
96:	

print_heap2$26:	; £temporary2574 -> £temporary2573 = *£temporary2573
98:	

print_heap2$27:	; heapTop = £temporary2574 -> £temporary2573
99:		mov ax, [si]
100:		mov [bp + 10], ax
102:	

print_heap2$28:	; goto 11
103:		jmp print_heap2$11
105:	

print_heap2$29:	; call header integral zero 0 stack zero 0
107:	

print_heap2$30:	; parameter string_0A#, offset 6
108:		mov word [bp + 20], string_0A#
110:	

print_heap2$31:	; call function noellipse-ellipse printf, extra 0
111:		mov word [bp + 14], print_heap2$32
112:		mov [bp + 16], bp
113:		add bp, 14
114:		mov di, bp
115:		jmp printf
117:	

print_heap2$32:	; post call
119:	

print_heap2$33:	; return
120:		mov ax, [bp]
121:		mov di, [bp + 4]
122:		mov bp, [bp + 2]
123:		jmp ax
125:	

print_heap2$34:	; function end print_heap2
1:	

atexit:	; call header integral zero 0 stack zero 0
3:	

atexit$1:	; parameter string_0A#, offset 6
4:		mov word [bp + 16], string_0A#
6:	

atexit$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 10], atexit$3
8:		mov [bp + 12], bp
9:		add bp, 10
10:		mov di, bp
11:		jmp printf
13:	

atexit$3:	; post call
15:	

atexit$4:	; index = 0
16:		mov word [bp + 8], 0
18:	

atexit$5:	; if index >= 256 goto 27
19:		cmp word [bp + 8], 256
20:		jge atexit$27
22:	

atexit$6:	; £temporary2589 = index * 2
23:		mov ax, [bp + 8]
25:		xor dx, dx
26:		mul word [int2$2#]
32:	

atexit$7:	; £temporary2590 = g_funcArray + £temporary2589
33:		mov si, g_funcArray
34:		add si, ax
36:	

atexit$8:	; £temporary2588 -> £temporary2590 = *£temporary2590
38:	

atexit$9:	; if £temporary2588 -> £temporary2590 != 0 goto 25
39:		cmp word [si], 0
40:		jne atexit$25
42:	

atexit$10:	; £temporary2593 = index * 2
43:		mov ax, [bp + 8]
45:		xor dx, dx
46:		mul word [int2$2#]
52:	

atexit$11:	; £temporary2594 = g_funcArray + £temporary2593
53:		mov si, g_funcArray
54:		add si, ax
56:	

atexit$12:	; £temporary2592 -> £temporary2594 = *£temporary2594
58:	

atexit$13:	; £temporary2592 -> £temporary2594 = fcn
59:		mov ax, [bp + 6]
60:		mov [si], ax
62:	

atexit$14:	; call header integral zero 0 stack zero 0
64:	

atexit$15:	; parameter string_Added20function20index2025i3A2025i0A#, offset 6
65:		mov word [bp + 16], string_Added20function20index2025i3A2025i0A#
67:	

atexit$16:	; parameter index, offset 8
68:		mov ax, [bp + 8]
69:		mov [bp + 18], ax
71:	

atexit$17:	; £temporary2596 = index * 2
72:		mov ax, [bp + 8]
74:		xor dx, dx
75:		mul word [int2$2#]
81:	

atexit$18:	; £temporary2597 = g_funcArray + £temporary2596
82:		mov si, g_funcArray
83:		add si, ax
85:	

atexit$19:	; £temporary2595 -> £temporary2597 = *£temporary2597
87:	

atexit$20:	; parameter £temporary2595 -> £temporary2597, offset 10
88:		mov ax, [si]
89:		mov [bp + 20], ax
91:	

atexit$21:	; call function noellipse-ellipse printf, extra 0
92:		mov word [bp + 10], atexit$22
93:		mov [bp + 12], bp
94:		add bp, 10
95:		mov di, bp
96:		add di, 4
97:		jmp printf
99:	

atexit$22:	; post call
101:	

atexit$23:	; return_value = 0
102:		mov bx, 0
104:	

atexit$24:	; return
105:		mov ax, [bp]
106:		mov di, [bp + 4]
107:		mov bp, [bp + 2]
108:		jmp ax
110:	

atexit$25:	; ++index
111:		inc word [bp + 8]
113:	

atexit$26:	; goto 5
114:		jmp atexit$5
116:	

atexit$27:	; return_value = -1
117:		mov bx, -1
119:	

atexit$28:	; return
120:		mov ax, [bp]
121:		mov di, [bp + 4]
122:		mov bp, [bp + 2]
123:		jmp ax
125:	

atexit$29:	; function end atexit
1:	

exit:	; call header integral zero 0 stack zero 0
3:	

exit$1:	; parameter string_0A#, offset 6
4:		mov word [bp + 16], string_0A#
6:	

exit$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 10], exit$3
8:		mov [bp + 12], bp
9:		add bp, 10
10:		mov di, bp
11:		jmp printf
13:	

exit$3:	; post call
15:	

exit$4:	; index = 255
16:		mov word [bp + 8], 255
18:	

exit$5:	; if index < 0 goto 27
19:		cmp word [bp + 8], 0
20:		jl exit$27
22:	

exit$6:	; £temporary2607 = index * 2
23:		mov ax, [bp + 8]
25:		xor dx, dx
26:		mul word [int2$2#]
32:	

exit$7:	; £temporary2608 = g_funcArray + £temporary2607
33:		mov si, g_funcArray
34:		add si, ax
36:	

exit$8:	; £temporary2606 -> £temporary2608 = *£temporary2608
38:	

exit$9:	; if £temporary2606 -> £temporary2608 == 0 goto 25
39:		cmp word [si], 0
40:		je exit$25
42:	

exit$10:	; call header integral zero 0 stack zero 0
44:	

exit$11:	; parameter string_Called20function20index2025i3A2025i0A#, offset 6
45:		mov word [bp + 16], string_Called20function20index2025i3A2025i0A#
47:	

exit$12:	; parameter index, offset 8
48:		mov ax, [bp + 8]
49:		mov [bp + 18], ax
51:	

exit$13:	; £temporary2611 = index * 2
52:		mov ax, [bp + 8]
54:		xor dx, dx
55:		mul word [int2$2#]
61:	

exit$14:	; £temporary2612 = g_funcArray + £temporary2611
62:		mov si, g_funcArray
63:		add si, ax
65:	

exit$15:	; £temporary2610 -> £temporary2612 = *£temporary2612
67:	

exit$16:	; parameter £temporary2610 -> £temporary2612, offset 10
68:		mov ax, [si]
69:		mov [bp + 20], ax
71:	

exit$17:	; call function noellipse-ellipse printf, extra 0
72:		mov word [bp + 10], exit$18
73:		mov [bp + 12], bp
74:		add bp, 10
75:		mov di, bp
76:		add di, 4
77:		jmp printf
79:	

exit$18:	; post call
81:	

exit$19:	; £temporary2615 = index * 2
82:		mov ax, [bp + 8]
84:		xor dx, dx
85:		mul word [int2$2#]
91:	

exit$20:	; £temporary2616 = g_funcArray + £temporary2615
92:		mov si, g_funcArray
93:		add si, ax
95:	

exit$21:	; £temporary2614 -> £temporary2616 = *£temporary2616
96:		mov ax, [si]
97:		mov [bp + 10], ax
99:	

exit$22:	; call header integral zero 0 stack zero 0
101:	

exit$23:	; call function noellipse-noellipse £temporary2614 -> £temporary2616
102:		mov word [bp + 12], exit$24
103:		mov [bp + 14], bp
104:		mov ax, [bp + 10]
105:		add bp, 12
106:		jmp ax
108:	

exit$24:	; post call
110:	

exit$25:	; --index
111:		dec word [bp + 8]
113:	

exit$26:	; goto 5
114:		jmp exit$5
116:	

exit$27:	; £temporary2619 = int_to_int status (Signed_Int -> Signed_Short_Int)
117:		mov ax, [bp + 6]
120:		cmp ax, 0
121:		jge exit$28
122:		neg ax
124:		neg al
126:	

exit$28:	; al = £temporary2619
128:	

exit$29:	; ah = 76
129:		mov ah, 76
131:	

exit$30:	; interrupt 33
132:		int 33
134:	

exit$31:	; return
135:		mov ax, [bp]
136:		mov di, [bp + 4]
137:		mov bp, [bp + 2]
138:		jmp ax
140:	

exit$32:	; function end exit
1:	

swap:	; index = 0
2:		mov word [bp + 12], 0
4:	

swap$1:	; if index >= valueSize goto 15
5:		mov ax, [bp + 12]
6:		cmp ax, [bp + 10]
7:		jge swap$15
9:	

swap$2:	; £temporary2628 = leftValuePtr + index
10:		mov si, [bp + 6]
11:		add si, [bp + 12]
13:	

swap$3:	; £temporary2627 -> £temporary2628 = *£temporary2628
15:	

swap$4:	; tempValue = £temporary2627 -> £temporary2628
16:		mov al, [si]
17:		mov [bp + 14], al
19:	

swap$5:	; £temporary2630 = leftValuePtr + index
20:		mov si, [bp + 6]
21:		add si, [bp + 12]
23:	

swap$6:	; £temporary2629 -> £temporary2630 = *£temporary2630
25:	

swap$7:	; £temporary2632 = rightValuePtr + index
26:		mov di, [bp + 8]
27:		add di, [bp + 12]
29:	

swap$8:	; £temporary2631 -> £temporary2632 = *£temporary2632
31:	

swap$9:	; £temporary2629 -> £temporary2630 = £temporary2631 -> £temporary2632
32:		mov al, [di]
33:		mov [si], al
35:	

swap$10:	; £temporary2634 = rightValuePtr + index
36:		mov si, [bp + 8]
37:		add si, [bp + 12]
39:	

swap$11:	; £temporary2633 -> £temporary2634 = *£temporary2634
41:	

swap$12:	; £temporary2633 -> £temporary2634 = tempValue
42:		mov al, [bp + 14]
43:		mov [si], al
45:	

swap$13:	; ++index
46:		inc word [bp + 12]
48:	

swap$14:	; goto 1
49:		jmp swap$1
51:	

swap$15:	; return
52:		mov ax, [bp]
53:		mov di, [bp + 4]
54:		mov bp, [bp + 2]
55:		jmp ax
57:	

swap$16:	; function end swap
1:	

qsort:	; £temporary2635 = int_to_int valueList (Pointer -> Pointer)
2:		mov ax, [bp + 6]
5:	

qsort$1:	; charList = £temporary2635
6:		mov [bp + 16], ax
8:	

qsort$2:	; £temporary2636 = listSize - 1
9:		mov ax, [bp + 8]
10:		sub ax, 1
12:	

qsort$3:	; index1 = £temporary2636
13:		mov [bp + 18], ax
15:	

qsort$4:	; if index1 <= 0 goto 33
16:		cmp word [bp + 18], 0
17:		jle qsort$33
19:	

qsort$5:	; update = 0
20:		mov word [bp + 14], 0
22:	

qsort$6:	; index2 = 0
23:		mov word [bp + 20], 0
25:	

qsort$7:	; if index2 >= index1 goto 31
26:		mov ax, [bp + 20]
27:		cmp ax, [bp + 18]
28:		jge qsort$31
30:	

qsort$8:	; £temporary2641 = index2 * valueSize
31:		mov ax, [bp + 20]
33:		xor dx, dx
34:		imul word [bp + 10]
40:	

qsort$9:	; £temporary2642 = charList + £temporary2641
41:		mov bx, [bp + 16]
42:		add bx, ax
44:	

qsort$10:	; valuePtr1 = £temporary2642
45:		mov [bp + 22], bx
47:	

qsort$11:	; £temporary2643 = index2 + 1
48:		mov ax, [bp + 20]
49:		add ax, 1
51:	

qsort$12:	; £temporary2644 = £temporary2643 * valueSize
53:		xor dx, dx
54:		imul word [bp + 10]
60:	

qsort$13:	; £temporary2645 = charList + £temporary2644
61:		mov bx, [bp + 16]
62:		add bx, ax
64:	

qsort$14:	; valuePtr2 = £temporary2645
65:		mov [bp + 24], bx
67:	

qsort$15:	; call header integral zero 0 stack zero 0
69:	

qsort$16:	; parameter valuePtr1, offset 6
70:		mov ax, [bp + 22]
71:		mov [bp + 32], ax
73:	

qsort$17:	; parameter valuePtr2, offset 8
74:		mov ax, [bp + 24]
75:		mov [bp + 34], ax
77:	

qsort$18:	; call function noellipse-noellipse compare
78:		mov word [bp + 26], qsort$19
79:		mov [bp + 28], bp
80:		mov ax, [bp + 12]
81:		add bp, 26
82:		jmp ax
84:	

qsort$19:	; post call
86:	

qsort$20:	; £temporary2646 = return_value
91:	

qsort$21:	; if £temporary2646 <= 0 goto 29
92:		cmp bx, 0
93:		jle qsort$29
95:	

qsort$22:	; call header integral zero 0 stack zero 0
97:	

qsort$23:	; parameter valuePtr1, offset 6
98:		mov ax, [bp + 22]
99:		mov [bp + 32], ax
101:	

qsort$24:	; parameter valuePtr2, offset 8
102:		mov ax, [bp + 24]
103:		mov [bp + 34], ax
105:	

qsort$25:	; parameter valueSize, offset 10
106:		mov ax, [bp + 10]
107:		mov [bp + 36], ax
109:	

qsort$26:	; call function noellipse-noellipse swap
110:		mov word [bp + 26], qsort$27
111:		mov [bp + 28], bp
112:		add bp, 26
113:		jmp swap
115:	

qsort$27:	; post call
117:	

qsort$28:	; update = 1
118:		mov word [bp + 14], 1
120:	

qsort$29:	; ++index2
121:		inc word [bp + 20]
123:	

qsort$30:	; goto 7
124:		jmp qsort$7
126:	

qsort$31:	; --index1
127:		dec word [bp + 18]
129:	

qsort$32:	; goto 4
130:		jmp qsort$4
132:	

qsort$33:	; return
133:		mov ax, [bp]
134:		mov di, [bp + 4]
135:		mov bp, [bp + 2]
136:		jmp ax
138:	

qsort$34:	; function end qsort
1:	

abs:	; if value >= 0 goto 4
2:		cmp word [bp + 6], 0
3:		jge abs$4
5:	

abs$1:	; £temporary2657 = -value
6:		mov bx, [bp + 6]
7:		neg bx
9:	

abs$2:	; £temporary2661 = £temporary2657
11:	

abs$3:	; goto 5
12:		jmp abs$5
14:	

abs$4:	; £temporary2661 = value
15:		mov bx, [bp + 6]
17:	

abs$5:	; return_value = £temporary2661
19:	

abs$6:	; return
20:		mov ax, [bp]
21:		mov di, [bp + 4]
22:		mov bp, [bp + 2]
23:		jmp ax
25:	

abs$7:	; function end abs
1:	

labs:	; if value >= 0 goto 4
2:		cmp dword [bp + 6], 0
3:		jge labs$4
5:	

labs$1:	; £temporary2663 = -value
6:		mov ebx, [bp + 6]
7:		neg ebx
9:	

labs$2:	; £temporary2667 = £temporary2663
11:	

labs$3:	; goto 5
12:		jmp labs$5
14:	

labs$4:	; £temporary2667 = value
15:		mov ebx, [bp + 6]
17:	

labs$5:	; return_value = £temporary2667
19:	

labs$6:	; return
20:		mov ax, [bp]
21:		mov di, [bp + 4]
22:		mov bp, [bp + 2]
23:		jmp ax
25:	

labs$7:	; function end labs
1:	

div:	; result$quot = 0
2:		mov word [bp + 10], 0
4:	

div$1:	; result$rem = 0
5:		mov word [bp + 12], 0
7:	

div$2:	; if denum != 0 goto 6
8:		cmp word [bp + 8], 0
9:		jne div$6
11:	

div$3:	; errno = 6
12:		mov word [errno], 6
14:	

div$4:	; return_value = result
15:		mov bx, bp
16:		add bx, 10
18:	

div$5:	; return
19:		mov ax, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp ax
24:	

div$6:	; £temporary2672 = num / denum
25:		mov ax, [bp + 6]
27:		xor dx, dx
28:		idiv word [bp + 8]
34:	

div$7:	; result$quot = £temporary2672
35:		mov [bp + 10], ax
37:	

div$8:	; £temporary2674 = num % denum
38:		mov ax, [bp + 6]
40:		xor dx, dx
41:		idiv word [bp + 8]
47:	

div$9:	; result$rem = £temporary2674
48:		mov [bp + 12], dx
50:	

div$10:	; return_value = result
51:		mov bx, bp
52:		add bx, 10
54:	

div$11:	; return
55:		mov ax, [bp]
56:		mov di, [bp + 4]
57:		mov bp, [bp + 2]
58:		jmp ax
60:	

div$12:	; function end div
1:	

ldiv:	; result$quot = 0
2:		mov dword [bp + 14], 0
4:	

ldiv$1:	; result$rem = 0
5:		mov dword [bp + 18], 0
7:	

ldiv$2:	; if denum != 0 goto 6
8:		cmp dword [bp + 10], 0
9:		jne ldiv$6
11:	

ldiv$3:	; errno = 6
12:		mov word [errno], 6
14:	

ldiv$4:	; return_value = result
15:		mov bx, bp
16:		add bx, 14
18:	

ldiv$5:	; return
19:		mov ax, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp ax
24:	

ldiv$6:	; £temporary2681 = num / denum
25:		mov eax, [bp + 6]
27:		xor edx, edx
28:		idiv dword [bp + 10]
34:	

ldiv$7:	; result$quot = £temporary2681
35:		mov [bp + 14], eax
37:	

ldiv$8:	; £temporary2683 = num % denum
38:		mov eax, [bp + 6]
40:		xor edx, edx
41:		idiv dword [bp + 10]
47:	

ldiv$9:	; result$rem = £temporary2683
48:		mov [bp + 18], edx
50:	

ldiv$10:	; return_value = result
51:		mov bx, bp
52:		add bx, 14
54:	

ldiv$11:	; return
55:		mov ax, [bp]
56:		mov di, [bp + 4]
57:		mov bp, [bp + 2]
58:		jmp ax
60:	

ldiv$12:	; function end ldiv
