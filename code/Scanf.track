1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov a852, [g_inStatus]
6:		cmp a852, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp a852, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1342 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov a853, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1342
23:		mov [bp + 7], a853
25:	

scanChar$7:	; £temporary1343 -> stream = *stream, offset 2
26:		mov a854, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1343 -> stream
29:		mov t855, [a854 + 2]
30:		mov [bp + 9], t855
32:	

scanChar$9:	; ah = 63
33:		mov a856, 63
35:	

scanChar$10:	; bx = handle
36:		mov a857, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov a858, 1
41:	

scanChar$12:	; £temporary1348 = &c
42:		mov t859, bp
43:		add t859, 6
45:	

scanChar$13:	; dx = £temporary1348
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov a860, [bp + 6]
56:	

scanChar$17:	; return
57:		mov t861, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp t861
62:	

scanChar$18:	; £temporary1350 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov a862, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1350
67:		mov [bp + 11], a862
69:	

scanChar$20:	; £temporary1351 = g_inChars
70:		mov t863, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1353 = inString + £temporary1351
76:		mov a864, [bp + 11]
77:		add a864, t863
79:	

scanChar$23:	; £temporary1352 -> £temporary1353 = *£temporary1353
81:	

scanChar$24:	; return_value = £temporary1352 -> £temporary1353
82:		mov t865, [a864]
84:	

scanChar$25:	; return
85:		mov t866, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp t866
90:	

scanChar$26:	; return_value = 0
91:		mov a867, 0
93:	

scanChar$27:	; return
94:		mov t868, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp t868
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov a869, [g_inStatus]
3:		cmp a869, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp a869, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov t870, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp t870
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1357 = return_value
19:	

scanPattern$5:	; input = £temporary1357
20:		mov [bp + 14], t872
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1358 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov a873, [bp + 14]
27:		and a873, 255
29:		cmp a873, 0
30:		jge scanPattern$8
31:		neg a873
33:		neg a873
35:	

scanPattern$8:	; parameter £temporary1358, offset 6
36:		mov [bp + 21], a873
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1359 = return_value
51:	

scanPattern$12:	; if £temporary1359 == 0 goto 19
52:		cmp t875, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1360 = return_value
70:	

scanPattern$17:	; input = £temporary1360
71:		mov [bp + 14], t877
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov a878, [bp + 8]
88:		mov [bp + 21], a878
90:	

scanPattern$23:	; £temporary1365 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov a879, [bp + 14]
93:		and a879, 255
95:		cmp a879, 0
96:		jge scanPattern$24
97:		neg a879
99:		neg a879
101:	

scanPattern$24:	; parameter £temporary1365, offset 8
102:		mov [bp + 23], a879
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1366 = return_value
117:	

scanPattern$28:	; if £temporary1366 != 0 goto 38
118:		cmp t881, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov a882, [bp + 8]
129:		mov [bp + 21], a882
131:	

scanPattern$32:	; £temporary1369 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov a883, [bp + 14]
134:		and a883, 255
136:		cmp a883, 0
137:		jge scanPattern$33
138:		neg a883
140:		neg a883
142:	

scanPattern$33:	; parameter £temporary1369, offset 8
143:		mov [bp + 23], a883
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1370 = return_value
158:	

scanPattern$37:	; if £temporary1370 != 0 goto 49
159:		cmp t885, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1376 = index
163:		mov t886, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1378 = string + £temporary1376
169:		mov a887, [bp + 6]
170:		add a887, t886
172:	

scanPattern$41:	; £temporary1377 -> £temporary1378 = *£temporary1378
174:	

scanPattern$42:	; £temporary1377 -> £temporary1378 = input
175:		mov a888, [bp + 14]
176:		mov [a887], a888
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1379 = return_value
193:	

scanPattern$47:	; input = £temporary1379
194:		mov [bp + 14], t890
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1381 = string + index
200:		mov a891, [bp + 6]
201:		add a891, [bp + 12]
203:	

scanPattern$50:	; £temporary1380 -> £temporary1381 = *£temporary1381
205:	

scanPattern$51:	; £temporary1380 -> £temporary1381 = 0
206:		mov byte [a891], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov a892, [bp + 8]
219:		mov [bp + 21], a892
221:	

scanPattern$56:	; £temporary1384 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov a893, [bp + 14]
224:		and a893, 255
226:		cmp a893, 0
227:		jge scanPattern$57
228:		neg a893
230:		neg a893
232:	

scanPattern$57:	; parameter £temporary1384, offset 8
233:		mov [bp + 23], a893
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1385 = return_value
248:	

scanPattern$61:	; if £temporary1385 != 0 goto 71
249:		cmp t895, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov a896, [bp + 8]
260:		mov [bp + 21], a896
262:	

scanPattern$65:	; £temporary1388 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov a897, [bp + 14]
265:		and a897, 255
267:		cmp a897, 0
268:		jge scanPattern$66
269:		neg a897
271:		neg a897
273:	

scanPattern$66:	; parameter £temporary1388, offset 8
274:		mov [bp + 23], a897
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1389 = return_value
289:	

scanPattern$70:	; if £temporary1389 != 0 goto 77
290:		cmp t899, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1395 = return_value
308:	

scanPattern$75:	; input = £temporary1395
309:		mov [bp + 14], t901
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov t902, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp t902
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1405 = return_value
19:	

scanString$5:	; input = £temporary1405
20:		mov [bp + 12], t904
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1406 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a905, [bp + 12]
30:		and a905, 255
32:		cmp a905, 0
33:		jge scanString$9
34:		neg a905
36:		neg a905
38:	

scanString$9:	; parameter £temporary1406, offset 6
39:		mov [bp + 21], a905
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1407 = return_value
54:	

scanString$13:	; if £temporary1407 == 0 goto 20
55:		cmp t907, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1408 = return_value
73:	

scanString$18:	; input = £temporary1408
74:		mov [bp + 12], t909
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1412 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov a910, [bp + 12]
92:		and a910, 255
94:		cmp a910, 0
95:		jge scanString$24
96:		neg a910
98:		neg a910
100:	

scanString$24:	; parameter £temporary1412, offset 6
101:		mov [bp + 21], a910
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1413 = return_value
116:	

scanString$28:	; if £temporary1413 != 0 goto 45
117:		cmp t912, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1416 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov a913, [bp + 12]
123:		and a913, 255
125:		cmp a913, 0
126:		jge scanString$30
127:		neg a913
129:		neg a913
131:	

scanString$30:	; if £temporary1416 == -1 goto 45
132:		cmp a913, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1421 = index
140:		mov t914, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1423 = string + £temporary1421
146:		mov a915, [bp + 6]
147:		add a915, t914
149:	

scanString$35:	; £temporary1422 -> £temporary1423 = *£temporary1423
151:	

scanString$36:	; £temporary1422 -> £temporary1423 = input
152:		mov a916, [bp + 12]
153:		mov [a915], a916
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1424 = return_value
170:	

scanString$41:	; input = £temporary1424
171:		mov [bp + 12], t918
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1427 = string + index
183:		mov a919, [bp + 6]
184:		add a919, [bp + 10]
186:	

scanString$46:	; £temporary1426 -> £temporary1427 = *£temporary1427
188:	

scanString$47:	; £temporary1426 -> £temporary1427 = 0
189:		mov byte [a919], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1429 = precision
198:		mov t920, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1429 <= 0 goto 76
204:		cmp t920, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1431 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov a921, [bp + 12]
212:		and a921, 255
214:		cmp a921, 0
215:		jge scanString$55
216:		neg a921
218:		neg a921
220:	

scanString$55:	; parameter £temporary1431, offset 6
221:		mov [bp + 21], a921
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1432 = return_value
236:	

scanString$59:	; if £temporary1432 != 0 goto 76
237:		cmp t923, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1435 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov a924, [bp + 12]
243:		and a924, 255
245:		cmp a924, 0
246:		jge scanString$61
247:		neg a924
249:		neg a924
251:	

scanString$61:	; if £temporary1435 == -1 goto 76
252:		cmp a924, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1441 = index
260:		mov t925, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1443 = string + £temporary1441
266:		mov a926, [bp + 6]
267:		add a926, t925
269:	

scanString$66:	; £temporary1442 -> £temporary1443 = *£temporary1443
271:	

scanString$67:	; £temporary1442 -> £temporary1443 = input
272:		mov a927, [bp + 12]
273:		mov [a926], a927
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1444 = return_value
290:	

scanString$72:	; input = £temporary1444
291:		mov [bp + 12], t929
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1448 = string + index
307:		mov a930, [bp + 6]
308:		add a930, [bp + 10]
310:	

scanString$78:	; £temporary1447 -> £temporary1448 = *£temporary1448
312:	

scanString$79:	; £temporary1447 -> £temporary1448 = 0
313:		mov byte [a930], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1451 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov a931, [bp + 12]
330:		and a931, 255
332:		cmp a931, 0
333:		jge scanString$85
334:		neg a931
336:		neg a931
338:	

scanString$85:	; parameter £temporary1451, offset 6
339:		mov [bp + 21], a931
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1452 = return_value
354:	

scanString$89:	; if £temporary1452 != 0 goto 101
355:		cmp t933, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1455 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov a934, [bp + 12]
361:		and a934, 255
363:		cmp a934, 0
364:		jge scanString$91
365:		neg a934
367:		neg a934
369:	

scanString$91:	; if £temporary1455 == -1 goto 101
370:		cmp a934, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1460 = return_value
392:	

scanString$97:	; input = £temporary1460
393:		mov [bp + 12], t936
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1463 = precision
411:		mov t937, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1463 <= 0 goto 124
417:		cmp t937, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1465 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov a938, [bp + 12]
425:		and a938, 255
427:		cmp a938, 0
428:		jge scanString$108
429:		neg a938
431:		neg a938
433:	

scanString$108:	; parameter £temporary1465, offset 6
434:		mov [bp + 21], a938
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1466 = return_value
449:	

scanString$112:	; if £temporary1466 != 0 goto 124
450:		cmp t940, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1469 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov a941, [bp + 12]
456:		and a941, 255
458:		cmp a941, 0
459:		jge scanString$114
460:		neg a941
462:		neg a941
464:	

scanString$114:	; if £temporary1469 == -1 goto 124
465:		cmp a941, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1475 = return_value
487:	

scanString$120:	; input = £temporary1475
488:		mov [bp + 12], t943
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov t944, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp t944
519:	

scanString$129:	; function end scanString
1:	

digitToValue:	; call header integral zero 0 stack zero 0
3:	

digitToValue$1:	; £temporary1486 = int_to_int input (Signed_Char -> Signed_Int)
4:		mov a945, [bp + 6]
6:		and a945, 255
8:		cmp a945, 0
9:		jge digitToValue$2
10:		neg a945
12:		neg a945
14:	

digitToValue$2:	; parameter £temporary1486, offset 6
15:		mov [bp + 13], a945
17:	

digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

digitToValue$4:	; post call
25:	

digitToValue$5:	; £temporary1487 = return_value
30:	

digitToValue$6:	; if £temporary1487 == 0 goto 11
31:		cmp t947, 0
32:		je digitToValue$11
34:	

digitToValue$7:	; £temporary1488 = input - 48
35:		mov a948, [bp + 6]
36:		sub a948, 48
38:	

digitToValue$8:	; £temporary1489 = int_to_int £temporary1488 (Signed_Char -> Unsigned_Long_Int)
40:		and a948, 255
42:	

digitToValue$9:	; return_value = £temporary1489
44:	

digitToValue$10:	; return
45:		mov t949, [bp]
46:		mov di, [bp + 4]
47:		mov bp, [bp + 2]
48:		jmp t949
50:	

digitToValue$11:	; call header integral zero 0 stack zero 0
52:	

digitToValue$12:	; £temporary1490 = int_to_int input (Signed_Char -> Signed_Int)
53:		mov a950, [bp + 6]
55:		and a950, 255
57:		cmp a950, 0
58:		jge digitToValue$13
59:		neg a950
61:		neg a950
63:	

digitToValue$13:	; parameter £temporary1490, offset 6
64:		mov [bp + 13], a950
66:	

digitToValue$14:	; call function noellipse-noellipse islower
67:		mov word [bp + 7], digitToValue$15
68:		mov [bp + 9], bp
69:		add bp, 7
70:		jmp islower
72:	

digitToValue$15:	; post call
74:	

digitToValue$16:	; £temporary1491 = return_value
79:	

digitToValue$17:	; if £temporary1491 == 0 goto 23
80:		cmp t952, 0
81:		je digitToValue$23
83:	

digitToValue$18:	; £temporary1492 = input - 97
84:		mov a953, [bp + 6]
85:		sub a953, 97
87:	

digitToValue$19:	; £temporary1493 = int_to_int £temporary1492 (Signed_Char -> Unsigned_Long_Int)
89:		and a953, 255
91:	

digitToValue$20:	; £temporary1494 = £temporary1493 + 10
92:		add a953, 10
94:	

digitToValue$21:	; return_value = £temporary1494
96:	

digitToValue$22:	; return
97:		mov t954, [bp]
98:		mov di, [bp + 4]
99:		mov bp, [bp + 2]
100:		jmp t954
102:	

digitToValue$23:	; £temporary1495 = input - 65
103:		mov a955, [bp + 6]
104:		sub a955, 65
106:	

digitToValue$24:	; £temporary1496 = int_to_int £temporary1495 (Signed_Char -> Unsigned_Long_Int)
108:		and a955, 255
110:	

digitToValue$25:	; £temporary1497 = £temporary1496 + 10
111:		add a955, 10
113:	

digitToValue$26:	; return_value = £temporary1497
115:	

digitToValue$27:	; return
116:		mov t956, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp t956
121:	

digitToValue$28:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 6], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 10], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 12], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 14], scanLongInt$5
14:		mov [bp + 16], bp
15:		add bp, 14
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1502 = return_value
25:	

scanLongInt$7:	; input = £temporary1502
26:		mov [bp + 14], t958
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1503 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov a959, [bp + 14]
33:		and a959, 255
35:		cmp a959, 0
36:		jge scanLongInt$10
37:		neg a959
39:		neg a959
41:	

scanLongInt$10:	; parameter £temporary1503, offset 6
42:		mov [bp + 21], a959
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 15], scanLongInt$12
46:		mov [bp + 17], bp
47:		add bp, 15
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1504 = return_value
57:	

scanLongInt$14:	; if £temporary1504 == 0 goto 21
58:		cmp t961, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 15], scanLongInt$17
65:		mov [bp + 17], bp
66:		add bp, 15
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1505 = return_value
76:	

scanLongInt$19:	; input = £temporary1505
77:		mov [bp + 14], t963
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 14], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 15], scanLongInt$24
90:		mov [bp + 17], bp
91:		add bp, 15
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1508 = return_value
101:	

scanLongInt$26:	; input = £temporary1508
102:		mov [bp + 14], t965
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 14], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 10], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 15], scanLongInt$32
118:		mov [bp + 17], bp
119:		add bp, 15
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1510 = return_value
129:	

scanLongInt$34:	; input = £temporary1510
130:		mov [bp + 14], t967
132:	

scanLongInt$35:	; call header integral zero 0 stack zero 0
134:	

scanLongInt$36:	; £temporary1511 = int_to_int input (Signed_Char -> Signed_Int)
135:		mov a968, [bp + 14]
137:		and a968, 255
139:		cmp a968, 0
140:		jge scanLongInt$37
141:		neg a968
143:		neg a968
145:	

scanLongInt$37:	; parameter £temporary1511, offset 6
146:		mov [bp + 21], a968
148:	

scanLongInt$38:	; call function noellipse-noellipse isdigit
149:		mov word [bp + 15], scanLongInt$39
150:		mov [bp + 17], bp
151:		add bp, 15
152:		jmp isdigit
154:	

scanLongInt$39:	; post call
156:	

scanLongInt$40:	; £temporary1512 = return_value
161:	

scanLongInt$41:	; if £temporary1512 == 0 goto 53
162:		cmp t970, 0
163:		je scanLongInt$53
165:	

scanLongInt$42:	; £temporary1513 = longValue * 10
166:		mov a971, [bp + 6]
168:		xor edx, edx
169:		imul dword [int4$10#]
175:	

scanLongInt$43:	; £temporary1514 = input - 48
176:		mov a975, [bp + 14]
177:		sub a975, 48
179:	

scanLongInt$44:	; £temporary1515 = int_to_int £temporary1514 (Signed_Char -> Signed_Long_Int)
181:		and a975, 255
183:		cmp a975, 0
184:		jge scanLongInt$45
185:		neg a975
187:		neg a975
189:	

scanLongInt$45:	; longValue = £temporary1513 + £temporary1515
190:		add t974, a975
191:		mov [bp + 6], t974
193:	

scanLongInt$46:	; call header integral zero 0 stack zero 0
195:	

scanLongInt$47:	; call function noellipse-noellipse scanChar
196:		mov word [bp + 15], scanLongInt$48
197:		mov [bp + 17], bp
198:		add bp, 15
199:		jmp scanChar
201:	

scanLongInt$48:	; post call
203:	

scanLongInt$49:	; £temporary1517 = return_value
208:	

scanLongInt$50:	; input = £temporary1517
209:		mov [bp + 14], t977
211:	

scanLongInt$51:	; found = 1
212:		mov word [bp + 12], 1
214:	

scanLongInt$52:	; goto 35
215:		jmp scanLongInt$35
217:	

scanLongInt$53:	; if minus == 0 goto 56
218:		cmp word [bp + 10], 0
219:		je scanLongInt$56
221:	

scanLongInt$54:	; £temporary1519 = -longValue
222:		mov a978, [bp + 6]
223:		neg a978
225:	

scanLongInt$55:	; longValue = £temporary1519
226:		mov [bp + 6], a978
228:	

scanLongInt$56:	; if found == 0 goto 58
229:		cmp word [bp + 12], 0
230:		je scanLongInt$58
232:	

scanLongInt$57:	; ++g_inCount
233:		inc word [g_inCount]
235:	

scanLongInt$58:	; call header integral zero 0 stack zero 0
237:	

scanLongInt$59:	; parameter input, offset 6
238:		mov a979, [bp + 14]
239:		mov [bp + 21], a979
241:	

scanLongInt$60:	; call function noellipse-noellipse unscanChar
242:		mov word [bp + 15], scanLongInt$61
243:		mov [bp + 17], bp
244:		add bp, 15
245:		jmp unscanChar
247:	

scanLongInt$61:	; post call
249:	

scanLongInt$62:	; return_value = longValue
250:		mov a980, [bp + 6]
252:	

scanLongInt$63:	; return
253:		mov t981, [bp]
254:		mov di, [bp + 4]
255:		mov bp, [bp + 2]
256:		jmp t981
258:	

scanLongInt$64:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 10], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 18], scanUnsignedLongInt$3
8:		mov [bp + 20], bp
9:		add bp, 18
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1527 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1527
20:		mov [bp + 18], t983
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 19], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1528 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a984, [bp + 18]
30:		and a984, 255
32:		cmp a984, 0
33:		jge scanUnsignedLongInt$9
34:		neg a984
36:		neg a984
38:	

scanUnsignedLongInt$9:	; parameter £temporary1528, offset 6
39:		mov [bp + 27], a984
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 21], scanUnsignedLongInt$11
43:		mov [bp + 23], bp
44:		add bp, 21
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1529 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1529 == 0 goto 20
55:		cmp t986, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 21], scanUnsignedLongInt$16
62:		mov [bp + 23], bp
63:		add bp, 21
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1530 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1530
74:		mov [bp + 18], t988
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 48 goto 49
80:		cmp byte [bp + 18], 48
81:		jne scanUnsignedLongInt$49
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 21], scanUnsignedLongInt$23
87:		mov [bp + 23], bp
88:		add bp, 21
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1533 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1533
99:		mov [bp + 18], t990
101:	

scanUnsignedLongInt$26:	; call header integral zero 0 stack zero 0
103:	

scanUnsignedLongInt$27:	; £temporary1534 = int_to_int input (Signed_Char -> Signed_Int)
104:		mov a991, [bp + 18]
106:		and a991, 255
108:		cmp a991, 0
109:		jge scanUnsignedLongInt$28
110:		neg a991
112:		neg a991
114:	

scanUnsignedLongInt$28:	; parameter £temporary1534, offset 6
115:		mov [bp + 27], a991
117:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse tolower
118:		mov word [bp + 21], scanUnsignedLongInt$30
119:		mov [bp + 23], bp
120:		add bp, 21
121:		jmp tolower
123:	

scanUnsignedLongInt$30:	; post call
125:	

scanUnsignedLongInt$31:	; £temporary1535 = return_value
130:	

scanUnsignedLongInt$32:	; if £temporary1535 != 120 goto 44
131:		cmp t993, 120
132:		jne scanUnsignedLongInt$44
134:	

scanUnsignedLongInt$33:	; if base != 0 goto 36
135:		cmp dword [bp + 6], 0
136:		jne scanUnsignedLongInt$36
138:	

scanUnsignedLongInt$34:	; £temporary1541 = 16
139:		mov t994, 16
141:	

scanUnsignedLongInt$35:	; goto 37
142:		jmp scanUnsignedLongInt$37
144:	

scanUnsignedLongInt$36:	; £temporary1541 = base
145:		mov t995, [bp + 6]
147:	

scanUnsignedLongInt$37:	; base = £temporary1541
148:		mov [bp + 6], t995
150:	

scanUnsignedLongInt$38:	; call header integral zero 0 stack zero 0
152:	

scanUnsignedLongInt$39:	; call function noellipse-noellipse scanChar
153:		mov word [bp + 21], scanUnsignedLongInt$40
154:		mov [bp + 23], bp
155:		add bp, 21
156:		jmp scanChar
158:	

scanUnsignedLongInt$40:	; post call
160:	

scanUnsignedLongInt$41:	; £temporary1542 = return_value
165:	

scanUnsignedLongInt$42:	; input = £temporary1542
166:		mov [bp + 18], t997
168:	

scanUnsignedLongInt$43:	; goto 49
169:		jmp scanUnsignedLongInt$49
171:	

scanUnsignedLongInt$44:	; if base != 0 goto 47
172:		cmp dword [bp + 6], 0
173:		jne scanUnsignedLongInt$47
175:	

scanUnsignedLongInt$45:	; £temporary1547 = 8
176:		mov t998, 8
178:	

scanUnsignedLongInt$46:	; goto 48
179:		jmp scanUnsignedLongInt$48
181:	

scanUnsignedLongInt$47:	; £temporary1547 = base
182:		mov t999, [bp + 6]
184:	

scanUnsignedLongInt$48:	; base = £temporary1547
185:		mov [bp + 6], t999
187:	

scanUnsignedLongInt$49:	; if base != 0 goto 51
188:		cmp dword [bp + 6], 0
189:		jne scanUnsignedLongInt$51
191:	

scanUnsignedLongInt$50:	; base = 10
192:		mov dword [bp + 6], 10
194:	

scanUnsignedLongInt$51:	; call header integral zero 0 stack zero 0
196:	

scanUnsignedLongInt$52:	; £temporary1549 = int_to_int input (Signed_Char -> Signed_Int)
197:		mov a1000, [bp + 18]
199:		and a1000, 255
201:		cmp a1000, 0
202:		jge scanUnsignedLongInt$53
203:		neg a1000
205:		neg a1000
207:	

scanUnsignedLongInt$53:	; parameter £temporary1549, offset 6
208:		mov [bp + 27], a1000
210:	

scanUnsignedLongInt$54:	; call function noellipse-noellipse isxdigit
211:		mov word [bp + 21], scanUnsignedLongInt$55
212:		mov [bp + 23], bp
213:		add bp, 21
214:		jmp isxdigit
216:	

scanUnsignedLongInt$55:	; post call
218:	

scanUnsignedLongInt$56:	; £temporary1550 = return_value
223:	

scanUnsignedLongInt$57:	; if £temporary1550 == 0 goto 74
224:		cmp t1002, 0
225:		je scanUnsignedLongInt$74
227:	

scanUnsignedLongInt$58:	; call header integral zero 0 stack zero 0
229:	

scanUnsignedLongInt$59:	; parameter input, offset 6
230:		mov a1003, [bp + 18]
231:		mov [bp + 27], a1003
233:	

scanUnsignedLongInt$60:	; call function noellipse-noellipse digitToValue
234:		mov word [bp + 21], scanUnsignedLongInt$61
235:		mov [bp + 23], bp
236:		add bp, 21
237:		jmp digitToValue
239:	

scanUnsignedLongInt$61:	; post call
241:	

scanUnsignedLongInt$62:	; £temporary1551 = return_value
246:	

scanUnsignedLongInt$63:	; digit = £temporary1551
247:		mov [bp + 14], t1005
249:	

scanUnsignedLongInt$64:	; if digit >= base goto 74
250:		mov a1006, [bp + 6]
251:		cmp [bp + 14], a1006
252:		jae scanUnsignedLongInt$74
254:	

scanUnsignedLongInt$65:	; £temporary1553 = unsignedLongValue * base
255:		mov a1007, [bp + 10]
257:		xor edx, edx
258:		mul dword [bp + 6]
264:	

scanUnsignedLongInt$66:	; unsignedLongValue = £temporary1553 + digit
265:		add t1010, [bp + 14]
266:		mov [bp + 10], t1010
268:	

scanUnsignedLongInt$67:	; found = 1
269:		mov word [bp + 19], 1
271:	

scanUnsignedLongInt$68:	; call header integral zero 0 stack zero 0
273:	

scanUnsignedLongInt$69:	; call function noellipse-noellipse scanChar
274:		mov word [bp + 21], scanUnsignedLongInt$70
275:		mov [bp + 23], bp
276:		add bp, 21
277:		jmp scanChar
279:	

scanUnsignedLongInt$70:	; post call
281:	

scanUnsignedLongInt$71:	; £temporary1555 = return_value
286:	

scanUnsignedLongInt$72:	; input = £temporary1555
287:		mov [bp + 18], t1012
289:	

scanUnsignedLongInt$73:	; goto 51
290:		jmp scanUnsignedLongInt$51
292:	

scanUnsignedLongInt$74:	; if found == 0 goto 76
293:		cmp word [bp + 19], 0
294:		je scanUnsignedLongInt$76
296:	

scanUnsignedLongInt$75:	; ++g_inCount
297:		inc word [g_inCount]
299:	

scanUnsignedLongInt$76:	; call header integral zero 0 stack zero 0
301:	

scanUnsignedLongInt$77:	; parameter input, offset 6
302:		mov a1013, [bp + 18]
303:		mov [bp + 27], a1013
305:	

scanUnsignedLongInt$78:	; call function noellipse-noellipse unscanChar
306:		mov word [bp + 21], scanUnsignedLongInt$79
307:		mov [bp + 23], bp
308:		add bp, 21
309:		jmp unscanChar
311:	

scanUnsignedLongInt$79:	; post call
313:	

scanUnsignedLongInt$80:	; return_value = unsignedLongValue
314:		mov a1014, [bp + 10]
316:	

scanUnsignedLongInt$81:	; return
317:		mov t1015, [bp]
318:		mov di, [bp + 4]
319:		mov bp, [bp + 2]
320:		jmp t1015
322:	

scanUnsignedLongInt$82:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1565 = return_value
34:	

scanLongDouble$10:	; input = £temporary1565
35:		mov [bp + 26], t1017
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1566 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov a1018, [bp + 26]
42:		and a1018, 255
44:		cmp a1018, 0
45:		jge scanLongDouble$13
46:		neg a1018
48:		neg a1018
50:	

scanLongDouble$13:	; parameter £temporary1566, offset 6
51:		mov [bp + 33], a1018
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1567 = return_value
66:	

scanLongDouble$17:	; if £temporary1567 == 0 goto 24
67:		cmp t1020, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1568 = return_value
85:	

scanLongDouble$22:	; input = £temporary1568
86:		mov [bp + 26], t1022
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1571 = return_value
110:	

scanLongDouble$29:	; input = £temporary1571
111:		mov [bp + 26], t1024
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1573 = return_value
138:	

scanLongDouble$37:	; input = £temporary1573
139:		mov [bp + 26], t1026
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1574 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov a1027, [bp + 26]
146:		and a1027, 255
148:		cmp a1027, 0
149:		jge scanLongDouble$40
150:		neg a1027
152:		neg a1027
154:	

scanLongDouble$40:	; parameter £temporary1574, offset 6
155:		mov [bp + 33], a1027
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1575 = return_value
170:	

scanLongDouble$44:	; if £temporary1575 == 0 goto 60
171:		cmp t1029, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1576 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1577 = input - 48
184:		mov a1030, [bp + 26]
185:		sub a1030, 48
187:	

scanLongDouble$49:	; £temporary1579 = int_to_int £temporary1577 (Signed_Char -> Signed_Int)
189:		and a1030, 255
191:		cmp a1030, 0
192:		jge scanLongDouble$50
193:		neg a1030
195:		neg a1030
197:	

scanLongDouble$50:	; £temporary1578 = int_to_float £temporary1579 (Signed_Int -> Long_Double)
198:		mov [container2bytes#], a1030
199:		fild word [container2bytes#]
201:	

scanLongDouble$51:	; £temporary1580 = £temporary1576 + £temporary1578
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1581 = return_value
222:	

scanLongDouble$57:	; input = £temporary1581
223:		mov [bp + 26], t1032
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1584 = return_value
250:	

scanLongDouble$65:	; input = £temporary1584
251:		mov [bp + 26], t1034
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1585 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov a1035, [bp + 26]
258:		and a1035, 255
260:		cmp a1035, 0
261:		jge scanLongDouble$68
262:		neg a1035
264:		neg a1035
266:	

scanLongDouble$68:	; parameter £temporary1585, offset 6
267:		mov [bp + 33], a1035
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1586 = return_value
282:	

scanLongDouble$72:	; if £temporary1586 == 0 goto 92
283:		cmp t1037, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1587 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1588 = input - 48
305:		mov a1038, [bp + 26]
306:		sub a1038, 48
308:	

scanLongDouble$80:	; £temporary1590 = int_to_int £temporary1588 (Signed_Char -> Signed_Int)
310:		and a1038, 255
312:		cmp a1038, 0
313:		jge scanLongDouble$81
314:		neg a1038
316:		neg a1038
318:	

scanLongDouble$81:	; £temporary1589 = int_to_float £temporary1590 (Signed_Int -> Long_Double)
319:		mov [container2bytes#], a1038
320:		fild word [container2bytes#]
322:	

scanLongDouble$82:	; £temporary1591 = factor * £temporary1589
323:		fmul
325:	

scanLongDouble$83:	; £temporary1592 = value + £temporary1591
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1593 = return_value
346:	

scanLongDouble$89:	; input = £temporary1593
347:		mov [bp + 26], t1040
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; parameter input, offset 6
358:		mov a1041, [bp + 26]
359:		mov [bp + 33], a1041
361:	

scanLongDouble$94:	; call function noellipse-noellipse unscanChar
362:		mov word [bp + 27], scanLongDouble$95
363:		mov [bp + 29], bp
364:		add bp, 27
365:		jmp unscanChar
367:	

scanLongDouble$95:	; post call
369:	

scanLongDouble$96:	; call header integral zero 0 stack zero 0
371:	

scanLongDouble$97:	; £temporary1596 = int_to_int input (Signed_Char -> Signed_Int)
372:		mov a1042, [bp + 26]
374:		and a1042, 255
376:		cmp a1042, 0
377:		jge scanLongDouble$98
378:		neg a1042
380:		neg a1042
382:	

scanLongDouble$98:	; parameter £temporary1596, offset 6
383:		mov [bp + 33], a1042
385:	

scanLongDouble$99:	; call function noellipse-noellipse tolower
386:		mov word [bp + 27], scanLongDouble$100
387:		mov [bp + 29], bp
388:		add bp, 27
389:		jmp tolower
391:	

scanLongDouble$100:	; post call
393:	

scanLongDouble$101:	; £temporary1597 = return_value
398:	

scanLongDouble$102:	; if £temporary1597 != 101 goto 121
399:		cmp t1044, 101
400:		jne scanLongDouble$121
402:	

scanLongDouble$103:	; call header integral zero 0 stack zero 0
404:	

scanLongDouble$104:	; call function noellipse-noellipse scanLongInt
405:		mov word [bp + 27], scanLongDouble$105
406:		mov [bp + 29], bp
407:		add bp, 27
408:		jmp scanLongInt
410:	

scanLongDouble$105:	; post call
412:	

scanLongDouble$106:	; £temporary1599 = return_value
417:	

scanLongDouble$107:	; £temporary1600 = int_to_float £temporary1599 (Signed_Long_Int -> Double)
418:		mov [container4bytes#], t1046
419:		fild dword [container4bytes#]
421:	

scanLongDouble$108:	; pop float exponent
422:		fstp qword [bp + 27]
424:	

scanLongDouble$109:	; push float value
425:		fld qword [bp + 10]
427:	

scanLongDouble$110:	; call header integral zero 0 stack no zero 1
428:		fstp qword [bp + 35]
430:	

scanLongDouble$111:	; push float 10.0
431:		fld qword [float8$10.0#]
433:	

scanLongDouble$112:	; parameter 10.0, offset 6
434:		fstp qword [bp + 49]
436:	

scanLongDouble$113:	; push float exponent
437:		fld qword [bp + 27]
439:	

scanLongDouble$114:	; parameter exponent, offset 14
440:		fstp qword [bp + 57]
442:	

scanLongDouble$115:	; call function noellipse-noellipse pow
443:		mov word [bp + 43], scanLongDouble$116
444:		mov [bp + 45], bp
445:		add bp, 43
446:		jmp pow
448:	

scanLongDouble$116:	; post call
449:		fstp qword [bp + 43]
450:		fld qword [bp + 35]
451:		fld qword [bp + 43]
453:	

scanLongDouble$117:	; £temporary1601 = return_value
455:	

scanLongDouble$118:	; £temporary1602 = value * £temporary1601
456:		fmul
458:	

scanLongDouble$119:	; pop float value
459:		fstp qword [bp + 10]
461:	

scanLongDouble$120:	; goto 125
462:		jmp scanLongDouble$125
464:	

scanLongDouble$121:	; call header integral zero 0 stack zero 0
466:	

scanLongDouble$122:	; parameter input, offset 6
467:		mov a1047, [bp + 26]
468:		mov [bp + 33], a1047
470:	

scanLongDouble$123:	; call function noellipse-noellipse unscanChar
471:		mov word [bp + 27], scanLongDouble$124
472:		mov [bp + 29], bp
473:		add bp, 27
474:		jmp unscanChar
476:	

scanLongDouble$124:	; post call
478:	

scanLongDouble$125:	; if minus == 0 goto 129
479:		cmp word [bp + 6], 0
480:		je scanLongDouble$129
482:	

scanLongDouble$126:	; push float value
483:		fld qword [bp + 10]
485:	

scanLongDouble$127:	; £temporary1604 = -value
486:		fchs
488:	

scanLongDouble$128:	; pop float value
489:		fstp qword [bp + 10]
491:	

scanLongDouble$129:	; if found == 0 goto 131
492:		cmp word [bp + 8], 0
493:		je scanLongDouble$131
495:	

scanLongDouble$130:	; ++g_inCount
496:		inc word [g_inCount]
498:	

scanLongDouble$131:	; push float value
499:		fld qword [bp + 10]
501:	

scanLongDouble$132:	; return_value = value
503:	

scanLongDouble$133:	; return
504:		mov t1048, [bp]
505:		mov di, [bp + 4]
506:		mov bp, [bp + 2]
507:		jmp t1048
509:	

scanLongDouble$134:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1617 = format + index
26:		mov a1049, [bp + 6]
27:		add a1049, [bp + 31]
29:	

scanFormat$9:	; £temporary1616 -> £temporary1617 = *£temporary1617
31:	

scanFormat$10:	; if £temporary1616 -> £temporary1617 == 0 goto 325
32:		cmp byte [a1049], 0
33:		je scanFormat$325
35:	

scanFormat$11:	; £temporary1621 = format + index
36:		mov a1050, [bp + 6]
37:		add a1050, [bp + 31]
39:	

scanFormat$12:	; £temporary1620 -> £temporary1621 = *£temporary1621
41:	

scanFormat$13:	; c = £temporary1620 -> £temporary1621
42:		mov t1051, [a1050]
43:		mov [bp + 10], t1051
45:	

scanFormat$14:	; £temporary1622 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov a1052, [bp + 10]
48:		and a1052, 255
50:		cmp a1052, 0
51:		jge scanFormat$15
52:		neg a1052
54:		neg a1052
56:	

scanFormat$15:	; d = £temporary1622 + 1
57:		add a1052, 1
58:		mov [bp + 55], a1052
60:	

scanFormat$16:	; if percent == 0 goto 317
61:		cmp word [bp + 13], 0
62:		je scanFormat$317
64:	

scanFormat$17:	; £temporary1624 = d - 1
65:		mov a1053, [bp + 55]
66:		sub a1053, 1
68:	

scanFormat$18:	; case £temporary1624 == 104 goto 36
69:		cmp a1053, 104
70:		je scanFormat$36
72:	

scanFormat$19:	; case £temporary1624 == 108 goto 38
73:		cmp a1053, 108
74:		je scanFormat$38
76:	

scanFormat$20:	; case £temporary1624 == 76 goto 40
77:		cmp a1053, 76
78:		je scanFormat$40
80:	

scanFormat$21:	; case £temporary1624 == 42 goto 42
81:		cmp a1053, 42
82:		je scanFormat$42
84:	

scanFormat$22:	; case £temporary1624 == 99 goto 44
85:		cmp a1053, 99
86:		je scanFormat$44
88:	

scanFormat$23:	; case £temporary1624 == 115 goto 62
89:		cmp a1053, 115
90:		je scanFormat$62
92:	

scanFormat$24:	; case £temporary1624 == 100 goto 81
93:		cmp a1053, 100
94:		je scanFormat$81
96:	

scanFormat$25:	; case £temporary1624 == 105 goto 81
97:		cmp a1053, 105
98:		je scanFormat$81
100:	

scanFormat$26:	; case £temporary1624 == 111 goto 116
101:		cmp a1053, 111
102:		je scanFormat$116
104:	

scanFormat$27:	; case £temporary1624 == 120 goto 152
105:		cmp a1053, 120
106:		je scanFormat$152
108:	

scanFormat$28:	; case £temporary1624 == 117 goto 188
109:		cmp a1053, 117
110:		je scanFormat$188
112:	

scanFormat$29:	; case £temporary1624 == 103 goto 224
113:		cmp a1053, 103
114:		je scanFormat$224
116:	

scanFormat$30:	; case £temporary1624 == 102 goto 224
117:		cmp a1053, 102
118:		je scanFormat$224
120:	

scanFormat$31:	; case £temporary1624 == 101 goto 224
121:		cmp a1053, 101
122:		je scanFormat$224
124:	

scanFormat$32:	; case £temporary1624 == 91 goto 260
125:		cmp a1053, 91
126:		je scanFormat$260
128:	

scanFormat$33:	; case £temporary1624 == 110 goto 301
129:		cmp a1053, 110
130:		je scanFormat$301
132:	

scanFormat$34:	; case end £temporary1624
134:	

scanFormat$35:	; goto 310
135:		jmp scanFormat$310
137:	

scanFormat$36:	; shortInt = 1
138:		mov word [bp + 15], 1
140:	

scanFormat$37:	; goto 323
141:		jmp scanFormat$323
143:	

scanFormat$38:	; longIntOrDouble = 1
144:		mov word [bp + 17], 1
146:	

scanFormat$39:	; goto 323
147:		jmp scanFormat$323
149:	

scanFormat$40:	; longDouble = 1
150:		mov word [bp + 19], 1
152:	

scanFormat$41:	; goto 323
153:		jmp scanFormat$323
155:	

scanFormat$42:	; star = 1
156:		mov word [bp + 21], 1
158:	

scanFormat$43:	; goto 323
159:		jmp scanFormat$323
161:	

scanFormat$44:	; call header integral zero 0 stack zero 0
163:	

scanFormat$45:	; call function noellipse-noellipse scanChar
164:		mov word [bp + 57], scanFormat$46
165:		mov [bp + 59], bp
166:		add bp, 57
167:		jmp scanChar
169:	

scanFormat$46:	; post call
171:	

scanFormat$47:	; £temporary1625 = return_value
176:	

scanFormat$48:	; charValue = £temporary1625
177:		mov [bp + 57], t1055
179:	

scanFormat$49:	; if star != 0 goto 57
180:		cmp word [bp + 21], 0
181:		jne scanFormat$57
183:	

scanFormat$50:	; arg_list = arg_list + 2
184:		add word [bp + 8], 2
186:	

scanFormat$51:	; £temporary1629 = arg_list - 2
187:		mov a1056, [bp + 8]
188:		sub a1056, 2
190:	

scanFormat$52:	; £temporary1630 = int_to_int £temporary1629 (Signed_Int -> Pointer)
193:	

scanFormat$53:	; £temporary1631 -> £temporary1630 = *£temporary1630
195:	

scanFormat$54:	; charPtr = £temporary1631 -> £temporary1630
196:		mov t1057, [a1056]
197:		mov [bp + 11], t1057
199:	

scanFormat$55:	; £temporary1632 -> charPtr = *charPtr
200:		mov a1058, [bp + 11]
202:	

scanFormat$56:	; £temporary1632 -> charPtr = charValue
203:		mov a1059, [bp + 57]
204:		mov [a1058], a1059
206:	

scanFormat$57:	; percent = 0
207:		mov word [bp + 13], 0
209:	

scanFormat$58:	; £temporary1633 = int_to_int charValue (Signed_Char -> Signed_Int)
210:		mov a1060, [bp + 57]
212:		and a1060, 255
214:		cmp a1060, 0
215:		jge scanFormat$59
216:		neg a1060
218:		neg a1060
220:	

scanFormat$59:	; if £temporary1633 == -1 goto 323
221:		cmp a1060, -1
222:		je scanFormat$323
224:	

scanFormat$60:	; ++g_inCount
225:		inc word [g_inCount]
227:	

scanFormat$61:	; goto 323
228:		jmp scanFormat$323
230:	

scanFormat$62:	; if star != 0 goto 74
231:		cmp word [bp + 21], 0
232:		jne scanFormat$74
234:	

scanFormat$63:	; arg_list = arg_list + 2
235:		add word [bp + 8], 2
237:	

scanFormat$64:	; £temporary1639 = arg_list - 2
238:		mov a1061, [bp + 8]
239:		sub a1061, 2
241:	

scanFormat$65:	; £temporary1640 = int_to_int £temporary1639 (Signed_Int -> Pointer)
244:	

scanFormat$66:	; £temporary1641 -> £temporary1640 = *£temporary1640
246:	

scanFormat$67:	; charPtr = £temporary1641 -> £temporary1640
247:		mov t1062, [a1061]
248:		mov [bp + 11], t1062
250:	

scanFormat$68:	; call header integral zero 0 stack zero 0
252:	

scanFormat$69:	; parameter charPtr, offset 6
253:		mov a1063, [bp + 11]
254:		mov [bp + 63], a1063
256:	

scanFormat$70:	; parameter 0, offset 8
257:		mov word [bp + 65], 0
259:	

scanFormat$71:	; call function noellipse-noellipse scanString
260:		mov word [bp + 57], scanFormat$72
261:		mov [bp + 59], bp
262:		add bp, 57
263:		jmp scanString
265:	

scanFormat$72:	; post call
267:	

scanFormat$73:	; goto 79
268:		jmp scanFormat$79
270:	

scanFormat$74:	; call header integral zero 0 stack zero 0
272:	

scanFormat$75:	; parameter 0, offset 6
273:		mov word [bp + 63], 0
275:	

scanFormat$76:	; parameter 0, offset 8
276:		mov word [bp + 65], 0
278:	

scanFormat$77:	; call function noellipse-noellipse scanString
279:		mov word [bp + 57], scanFormat$78
280:		mov [bp + 59], bp
281:		add bp, 57
282:		jmp scanString
284:	

scanFormat$78:	; post call
286:	

scanFormat$79:	; percent = 0
287:		mov word [bp + 13], 0
289:	

scanFormat$80:	; goto 323
290:		jmp scanFormat$323
292:	

scanFormat$81:	; call header integral zero 0 stack zero 0
294:	

scanFormat$82:	; call function noellipse-noellipse scanLongInt
295:		mov word [bp + 57], scanFormat$83
296:		mov [bp + 59], bp
297:		add bp, 57
298:		jmp scanLongInt
300:	

scanFormat$83:	; post call
302:	

scanFormat$84:	; £temporary1644 = return_value
307:	

scanFormat$85:	; longValue = £temporary1644
308:		mov [bp + 23], t1065
310:	

scanFormat$86:	; if star != 0 goto 114
311:		cmp word [bp + 21], 0
312:		jne scanFormat$114
314:	

scanFormat$87:	; if shortInt == 0 goto 97
315:		cmp word [bp + 15], 0
316:		je scanFormat$97
318:	

scanFormat$88:	; arg_list = arg_list + 2
319:		add word [bp + 8], 2
321:	

scanFormat$89:	; £temporary1648 = arg_list - 2
322:		mov a1066, [bp + 8]
323:		sub a1066, 2
325:	

scanFormat$90:	; £temporary1649 = int_to_int £temporary1648 (Signed_Int -> Pointer)
328:	

scanFormat$91:	; £temporary1650 -> £temporary1649 = *£temporary1649
330:	

scanFormat$92:	; shortPtr = £temporary1650 -> £temporary1649
331:		mov t1067, [a1066]
332:		mov [bp + 29], t1067
334:	

scanFormat$93:	; £temporary1651 -> shortPtr = *shortPtr
335:		mov a1068, [bp + 29]
337:	

scanFormat$94:	; £temporary1652 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
338:		mov a1069, [bp + 23]
341:		cmp a1069, 0
342:		jge scanFormat$95
343:		neg a1069
345:		neg a1069
347:	

scanFormat$95:	; £temporary1651 -> shortPtr = £temporary1652
348:		mov [a1068], a1069
350:	

scanFormat$96:	; goto 114
351:		jmp scanFormat$114
353:	

scanFormat$97:	; if longIntOrDouble != 0 goto 107
354:		cmp word [bp + 17], 0
355:		jne scanFormat$107
357:	

scanFormat$98:	; arg_list = arg_list + 2
358:		add word [bp + 8], 2
360:	

scanFormat$99:	; £temporary1656 = arg_list - 2
361:		mov a1070, [bp + 8]
362:		sub a1070, 2
364:	

scanFormat$100:	; £temporary1657 = int_to_int £temporary1656 (Signed_Int -> Pointer)
367:	

scanFormat$101:	; £temporary1658 -> £temporary1657 = *£temporary1657
369:	

scanFormat$102:	; intPtr = £temporary1658 -> £temporary1657
370:		mov t1071, [a1070]
371:		mov [bp + 33], t1071
373:	

scanFormat$103:	; £temporary1659 -> intPtr = *intPtr
374:		mov a1072, [bp + 33]
376:	

scanFormat$104:	; £temporary1660 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
377:		mov a1073, [bp + 23]
380:		cmp a1073, 0
381:		jge scanFormat$105
382:		neg a1073
384:		neg a1073
386:	

scanFormat$105:	; £temporary1659 -> intPtr = £temporary1660
387:		mov [a1072], a1073
389:	

scanFormat$106:	; goto 114
390:		jmp scanFormat$114
392:	

scanFormat$107:	; arg_list = arg_list + 2
393:		add word [bp + 8], 2
395:	

scanFormat$108:	; £temporary1662 = arg_list - 2
396:		mov a1074, [bp + 8]
397:		sub a1074, 2
399:	

scanFormat$109:	; £temporary1663 = int_to_int £temporary1662 (Signed_Int -> Pointer)
402:	

scanFormat$110:	; £temporary1664 -> £temporary1663 = *£temporary1663
404:	

scanFormat$111:	; longPtr = £temporary1664 -> £temporary1663
405:		mov t1075, [a1074]
406:		mov [bp + 27], t1075
408:	

scanFormat$112:	; £temporary1665 -> longPtr = *longPtr
409:		mov a1076, [bp + 27]
411:	

scanFormat$113:	; £temporary1665 -> longPtr = longValue
412:		mov a1077, [bp + 23]
413:		mov [a1076], a1077
415:	

scanFormat$114:	; percent = 0
416:		mov word [bp + 13], 0
418:	

scanFormat$115:	; goto 323
419:		jmp scanFormat$323
421:	

scanFormat$116:	; call header integral zero 0 stack zero 0
423:	

scanFormat$117:	; parameter 8, offset 6
424:		mov dword [bp + 63], 8
426:	

scanFormat$118:	; call function noellipse-noellipse scanUnsignedLongInt
427:		mov word [bp + 57], scanFormat$119
428:		mov [bp + 59], bp
429:		add bp, 57
430:		jmp scanUnsignedLongInt
432:	

scanFormat$119:	; post call
434:	

scanFormat$120:	; £temporary1667 = return_value
439:	

scanFormat$121:	; unsignedLongValue = £temporary1667
440:		mov [bp + 37], t1079
442:	

scanFormat$122:	; if star != 0 goto 150
443:		cmp word [bp + 21], 0
444:		jne scanFormat$150
446:	

scanFormat$123:	; if shortInt == 0 goto 133
447:		cmp word [bp + 15], 0
448:		je scanFormat$133
450:	

scanFormat$124:	; arg_list = arg_list + 2
451:		add word [bp + 8], 2
453:	

scanFormat$125:	; £temporary1671 = arg_list - 2
454:		mov a1080, [bp + 8]
455:		sub a1080, 2
457:	

scanFormat$126:	; £temporary1672 = int_to_int £temporary1671 (Signed_Int -> Pointer)
460:	

scanFormat$127:	; £temporary1673 -> £temporary1672 = *£temporary1672
462:	

scanFormat$128:	; unsignedShortPtr = £temporary1673 -> £temporary1672
463:		mov t1081, [a1080]
464:		mov [bp + 43], t1081
466:	

scanFormat$129:	; £temporary1674 -> unsignedShortPtr = *unsignedShortPtr
467:		mov a1082, [bp + 43]
469:	

scanFormat$130:	; £temporary1675 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
470:		mov a1083, [bp + 37]
473:	

scanFormat$131:	; £temporary1674 -> unsignedShortPtr = £temporary1675
474:		mov [a1082], a1083
476:	

scanFormat$132:	; goto 150
477:		jmp scanFormat$150
479:	

scanFormat$133:	; if longIntOrDouble != 0 goto 143
480:		cmp word [bp + 17], 0
481:		jne scanFormat$143
483:	

scanFormat$134:	; arg_list = arg_list + 2
484:		add word [bp + 8], 2
486:	

scanFormat$135:	; £temporary1679 = arg_list - 2
487:		mov a1084, [bp + 8]
488:		sub a1084, 2
490:	

scanFormat$136:	; £temporary1680 = int_to_int £temporary1679 (Signed_Int -> Pointer)
493:	

scanFormat$137:	; £temporary1681 -> £temporary1680 = *£temporary1680
495:	

scanFormat$138:	; unsignedIntPtr = £temporary1681 -> £temporary1680
496:		mov t1085, [a1084]
497:		mov [bp + 45], t1085
499:	

scanFormat$139:	; £temporary1682 -> unsignedIntPtr = *unsignedIntPtr
500:		mov a1086, [bp + 45]
502:	

scanFormat$140:	; £temporary1683 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
503:		mov a1087, [bp + 37]
506:	

scanFormat$141:	; £temporary1682 -> unsignedIntPtr = £temporary1683
507:		mov [a1086], a1087
509:	

scanFormat$142:	; goto 150
510:		jmp scanFormat$150
512:	

scanFormat$143:	; arg_list = arg_list + 2
513:		add word [bp + 8], 2
515:	

scanFormat$144:	; £temporary1685 = arg_list - 2
516:		mov a1088, [bp + 8]
517:		sub a1088, 2
519:	

scanFormat$145:	; £temporary1686 = int_to_int £temporary1685 (Signed_Int -> Pointer)
522:	

scanFormat$146:	; £temporary1687 -> £temporary1686 = *£temporary1686
524:	

scanFormat$147:	; unsignedLongPtr = £temporary1687 -> £temporary1686
525:		mov t1089, [a1088]
526:		mov [bp + 41], t1089
528:	

scanFormat$148:	; £temporary1688 -> unsignedLongPtr = *unsignedLongPtr
529:		mov a1090, [bp + 41]
531:	

scanFormat$149:	; £temporary1688 -> unsignedLongPtr = unsignedLongValue
532:		mov a1091, [bp + 37]
533:		mov [a1090], a1091
535:	

scanFormat$150:	; percent = 0
536:		mov word [bp + 13], 0
538:	

scanFormat$151:	; goto 323
539:		jmp scanFormat$323
541:	

scanFormat$152:	; call header integral zero 0 stack zero 0
543:	

scanFormat$153:	; parameter 16, offset 6
544:		mov dword [bp + 63], 16
546:	

scanFormat$154:	; call function noellipse-noellipse scanUnsignedLongInt
547:		mov word [bp + 57], scanFormat$155
548:		mov [bp + 59], bp
549:		add bp, 57
550:		jmp scanUnsignedLongInt
552:	

scanFormat$155:	; post call
554:	

scanFormat$156:	; £temporary1690 = return_value
559:	

scanFormat$157:	; unsignedLongValue = £temporary1690
560:		mov [bp + 37], t1093
562:	

scanFormat$158:	; if star != 0 goto 186
563:		cmp word [bp + 21], 0
564:		jne scanFormat$186
566:	

scanFormat$159:	; if shortInt == 0 goto 169
567:		cmp word [bp + 15], 0
568:		je scanFormat$169
570:	

scanFormat$160:	; arg_list = arg_list + 2
571:		add word [bp + 8], 2
573:	

scanFormat$161:	; £temporary1694 = arg_list - 2
574:		mov a1094, [bp + 8]
575:		sub a1094, 2
577:	

scanFormat$162:	; £temporary1695 = int_to_int £temporary1694 (Signed_Int -> Pointer)
580:	

scanFormat$163:	; £temporary1696 -> £temporary1695 = *£temporary1695
582:	

scanFormat$164:	; unsignedShortPtr = £temporary1696 -> £temporary1695
583:		mov t1095, [a1094]
584:		mov [bp + 43], t1095
586:	

scanFormat$165:	; £temporary1697 -> unsignedShortPtr = *unsignedShortPtr
587:		mov a1096, [bp + 43]
589:	

scanFormat$166:	; £temporary1698 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
590:		mov a1097, [bp + 37]
593:	

scanFormat$167:	; £temporary1697 -> unsignedShortPtr = £temporary1698
594:		mov [a1096], a1097
596:	

scanFormat$168:	; goto 186
597:		jmp scanFormat$186
599:	

scanFormat$169:	; if longIntOrDouble != 0 goto 179
600:		cmp word [bp + 17], 0
601:		jne scanFormat$179
603:	

scanFormat$170:	; arg_list = arg_list + 2
604:		add word [bp + 8], 2
606:	

scanFormat$171:	; £temporary1702 = arg_list - 2
607:		mov a1098, [bp + 8]
608:		sub a1098, 2
610:	

scanFormat$172:	; £temporary1703 = int_to_int £temporary1702 (Signed_Int -> Pointer)
613:	

scanFormat$173:	; £temporary1704 -> £temporary1703 = *£temporary1703
615:	

scanFormat$174:	; unsignedIntPtr = £temporary1704 -> £temporary1703
616:		mov t1099, [a1098]
617:		mov [bp + 45], t1099
619:	

scanFormat$175:	; £temporary1705 -> unsignedIntPtr = *unsignedIntPtr
620:		mov a1100, [bp + 45]
622:	

scanFormat$176:	; £temporary1706 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
623:		mov a1101, [bp + 37]
626:	

scanFormat$177:	; £temporary1705 -> unsignedIntPtr = £temporary1706
627:		mov [a1100], a1101
629:	

scanFormat$178:	; goto 186
630:		jmp scanFormat$186
632:	

scanFormat$179:	; arg_list = arg_list + 2
633:		add word [bp + 8], 2
635:	

scanFormat$180:	; £temporary1708 = arg_list - 2
636:		mov a1102, [bp + 8]
637:		sub a1102, 2
639:	

scanFormat$181:	; £temporary1709 = int_to_int £temporary1708 (Signed_Int -> Pointer)
642:	

scanFormat$182:	; £temporary1710 -> £temporary1709 = *£temporary1709
644:	

scanFormat$183:	; unsignedLongPtr = £temporary1710 -> £temporary1709
645:		mov t1103, [a1102]
646:		mov [bp + 41], t1103
648:	

scanFormat$184:	; £temporary1711 -> unsignedLongPtr = *unsignedLongPtr
649:		mov a1104, [bp + 41]
651:	

scanFormat$185:	; £temporary1711 -> unsignedLongPtr = unsignedLongValue
652:		mov a1105, [bp + 37]
653:		mov [a1104], a1105
655:	

scanFormat$186:	; percent = 0
656:		mov word [bp + 13], 0
658:	

scanFormat$187:	; goto 323
659:		jmp scanFormat$323
661:	

scanFormat$188:	; call header integral zero 0 stack zero 0
663:	

scanFormat$189:	; parameter 0, offset 6
664:		mov dword [bp + 63], 0
666:	

scanFormat$190:	; call function noellipse-noellipse scanUnsignedLongInt
667:		mov word [bp + 57], scanFormat$191
668:		mov [bp + 59], bp
669:		add bp, 57
670:		jmp scanUnsignedLongInt
672:	

scanFormat$191:	; post call
674:	

scanFormat$192:	; £temporary1713 = return_value
679:	

scanFormat$193:	; unsignedLongValue = £temporary1713
680:		mov [bp + 37], t1107
682:	

scanFormat$194:	; if star != 0 goto 222
683:		cmp word [bp + 21], 0
684:		jne scanFormat$222
686:	

scanFormat$195:	; if shortInt == 0 goto 205
687:		cmp word [bp + 15], 0
688:		je scanFormat$205
690:	

scanFormat$196:	; arg_list = arg_list + 2
691:		add word [bp + 8], 2
693:	

scanFormat$197:	; £temporary1717 = arg_list - 2
694:		mov a1108, [bp + 8]
695:		sub a1108, 2
697:	

scanFormat$198:	; £temporary1718 = int_to_int £temporary1717 (Signed_Int -> Pointer)
700:	

scanFormat$199:	; £temporary1719 -> £temporary1718 = *£temporary1718
702:	

scanFormat$200:	; unsignedShortPtr = £temporary1719 -> £temporary1718
703:		mov t1109, [a1108]
704:		mov [bp + 43], t1109
706:	

scanFormat$201:	; £temporary1720 -> unsignedShortPtr = *unsignedShortPtr
707:		mov a1110, [bp + 43]
709:	

scanFormat$202:	; £temporary1721 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
710:		mov a1111, [bp + 37]
713:	

scanFormat$203:	; £temporary1720 -> unsignedShortPtr = £temporary1721
714:		mov [a1110], a1111
716:	

scanFormat$204:	; goto 222
717:		jmp scanFormat$222
719:	

scanFormat$205:	; if longIntOrDouble != 0 goto 215
720:		cmp word [bp + 17], 0
721:		jne scanFormat$215
723:	

scanFormat$206:	; arg_list = arg_list + 2
724:		add word [bp + 8], 2
726:	

scanFormat$207:	; £temporary1725 = arg_list - 2
727:		mov a1112, [bp + 8]
728:		sub a1112, 2
730:	

scanFormat$208:	; £temporary1726 = int_to_int £temporary1725 (Signed_Int -> Pointer)
733:	

scanFormat$209:	; £temporary1727 -> £temporary1726 = *£temporary1726
735:	

scanFormat$210:	; unsignedIntPtr = £temporary1727 -> £temporary1726
736:		mov t1113, [a1112]
737:		mov [bp + 45], t1113
739:	

scanFormat$211:	; £temporary1728 -> unsignedIntPtr = *unsignedIntPtr
740:		mov a1114, [bp + 45]
742:	

scanFormat$212:	; £temporary1729 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
743:		mov a1115, [bp + 37]
746:	

scanFormat$213:	; £temporary1728 -> unsignedIntPtr = £temporary1729
747:		mov [a1114], a1115
749:	

scanFormat$214:	; goto 222
750:		jmp scanFormat$222
752:	

scanFormat$215:	; arg_list = arg_list + 2
753:		add word [bp + 8], 2
755:	

scanFormat$216:	; £temporary1731 = arg_list - 2
756:		mov a1116, [bp + 8]
757:		sub a1116, 2
759:	

scanFormat$217:	; £temporary1732 = int_to_int £temporary1731 (Signed_Int -> Pointer)
762:	

scanFormat$218:	; £temporary1733 -> £temporary1732 = *£temporary1732
764:	

scanFormat$219:	; unsignedLongPtr = £temporary1733 -> £temporary1732
765:		mov t1117, [a1116]
766:		mov [bp + 41], t1117
768:	

scanFormat$220:	; £temporary1734 -> unsignedLongPtr = *unsignedLongPtr
769:		mov a1118, [bp + 41]
771:	

scanFormat$221:	; £temporary1734 -> unsignedLongPtr = unsignedLongValue
772:		mov a1119, [bp + 37]
773:		mov [a1118], a1119
775:	

scanFormat$222:	; percent = 0
776:		mov word [bp + 13], 0
778:	

scanFormat$223:	; goto 323
779:		jmp scanFormat$323
781:	

scanFormat$224:	; call header integral zero 0 stack zero 0
783:	

scanFormat$225:	; call function noellipse-noellipse scanLongDouble
784:		mov word [bp + 57], scanFormat$226
785:		mov [bp + 59], bp
786:		add bp, 57
787:		jmp scanLongDouble
789:	

scanFormat$226:	; post call
791:	

scanFormat$227:	; £temporary1736 = return_value
793:	

scanFormat$228:	; pop float longDoubleValue
794:		fstp qword [bp + 47]
796:	

scanFormat$229:	; if star != 0 goto 258
797:		cmp word [bp + 21], 0
798:		jne scanFormat$258
800:	

scanFormat$230:	; if longIntOrDouble == 0 goto 240
801:		cmp word [bp + 17], 0
802:		je scanFormat$240
804:	

scanFormat$231:	; arg_list = arg_list + 2
805:		add word [bp + 8], 2
807:	

scanFormat$232:	; £temporary1740 = arg_list - 2
808:		mov a1120, [bp + 8]
809:		sub a1120, 2
811:	

scanFormat$233:	; £temporary1741 = int_to_int £temporary1740 (Signed_Int -> Pointer)
814:	

scanFormat$234:	; £temporary1742 -> £temporary1741 = *£temporary1741
816:	

scanFormat$235:	; doublePtr = £temporary1742 -> £temporary1741
817:		mov t1121, [a1120]
818:		mov [bp + 57], t1121
820:	

scanFormat$236:	; £temporary1743 -> doublePtr = *doublePtr
821:		mov a1122, [bp + 57]
823:	

scanFormat$237:	; push float longDoubleValue
824:		fld qword [bp + 47]
826:	

scanFormat$238:	; pop float £temporary1743 -> doublePtr
827:		fstp qword [a1122]
829:	

scanFormat$239:	; goto 258
830:		jmp scanFormat$258
832:	

scanFormat$240:	; if longDouble == 0 goto 250
833:		cmp word [bp + 19], 0
834:		je scanFormat$250
836:	

scanFormat$241:	; arg_list = arg_list + 2
837:		add word [bp + 8], 2
839:	

scanFormat$242:	; £temporary1746 = arg_list - 2
840:		mov a1123, [bp + 8]
841:		sub a1123, 2
843:	

scanFormat$243:	; £temporary1747 = int_to_int £temporary1746 (Signed_Int -> Pointer)
846:	

scanFormat$244:	; £temporary1748 -> £temporary1747 = *£temporary1747
848:	

scanFormat$245:	; longDoublePtr = £temporary1748 -> £temporary1747
849:		mov t1124, [a1123]
850:		mov [bp + 57], t1124
852:	

scanFormat$246:	; £temporary1749 -> longDoublePtr = *longDoublePtr
853:		mov a1125, [bp + 57]
855:	

scanFormat$247:	; push float longDoubleValue
856:		fld qword [bp + 47]
858:	

scanFormat$248:	; pop float £temporary1749 -> longDoublePtr
859:		fstp qword [a1125]
861:	

scanFormat$249:	; goto 258
862:		jmp scanFormat$258
864:	

scanFormat$250:	; arg_list = arg_list + 2
865:		add word [bp + 8], 2
867:	

scanFormat$251:	; £temporary1751 = arg_list - 2
868:		mov a1126, [bp + 8]
869:		sub a1126, 2
871:	

scanFormat$252:	; £temporary1752 = int_to_int £temporary1751 (Signed_Int -> Pointer)
874:	

scanFormat$253:	; £temporary1753 -> £temporary1752 = *£temporary1752
876:	

scanFormat$254:	; floatPtr = £temporary1753 -> £temporary1752
877:		mov t1127, [a1126]
878:		mov [bp + 57], t1127
880:	

scanFormat$255:	; £temporary1754 -> floatPtr = *floatPtr
881:		mov a1128, [bp + 57]
883:	

scanFormat$256:	; push float longDoubleValue
884:		fld qword [bp + 47]
886:	

scanFormat$257:	; pop float £temporary1754 -> floatPtr
887:		fstp dword [a1128]
889:	

scanFormat$258:	; percent = 0
890:		mov word [bp + 13], 0
892:	

scanFormat$259:	; goto 323
893:		jmp scanFormat$323
895:	

scanFormat$260:	; not = 0
896:		mov word [bp + 57], 0
898:	

scanFormat$261:	; ++index
899:		inc word [bp + 31]
901:	

scanFormat$262:	; £temporary1760 = format + index
902:		mov a1129, [bp + 6]
903:		add a1129, [bp + 31]
905:	

scanFormat$263:	; £temporary1759 -> £temporary1760 = *£temporary1760
907:	

scanFormat$264:	; if £temporary1759 -> £temporary1760 != 94 goto 267
908:		cmp byte [a1129], 94
909:		jne scanFormat$267
911:	

scanFormat$265:	; not = 1
912:		mov word [bp + 57], 1
914:	

scanFormat$266:	; startIndex = index + 1
915:		mov a1130, [bp + 31]
916:		add a1130, 1
917:		mov [bp + 59], a1130
919:	

scanFormat$267:	; £temporary1764 = format + index
920:		mov a1131, [bp + 6]
921:		add a1131, [bp + 31]
923:	

scanFormat$268:	; £temporary1763 -> £temporary1764 = *£temporary1764
925:	

scanFormat$269:	; if £temporary1763 -> £temporary1764 == 93 goto 272
926:		cmp byte [a1131], 93
927:		je scanFormat$272
929:	

scanFormat$270:	; ++index
930:		inc word [bp + 31]
932:	

scanFormat$271:	; goto 267
933:		jmp scanFormat$267
935:	

scanFormat$272:	; £temporary1768 = format + index
936:		mov a1132, [bp + 6]
937:		add a1132, [bp + 31]
939:	

scanFormat$273:	; £temporary1767 -> £temporary1768 = *£temporary1768
941:	

scanFormat$274:	; £temporary1767 -> £temporary1768 = 0
942:		mov byte [a1132], 0
944:	

scanFormat$275:	; if star != 0 goto 291
945:		cmp word [bp + 21], 0
946:		jne scanFormat$291
948:	

scanFormat$276:	; arg_list = arg_list + 2
949:		add word [bp + 8], 2
951:	

scanFormat$277:	; £temporary1772 = arg_list - 2
952:		mov a1133, [bp + 8]
953:		sub a1133, 2
955:	

scanFormat$278:	; £temporary1773 = int_to_int £temporary1772 (Signed_Int -> Pointer)
958:	

scanFormat$279:	; £temporary1774 -> £temporary1773 = *£temporary1773
960:	

scanFormat$280:	; string = £temporary1774 -> £temporary1773
961:		mov t1134, [a1133]
962:		mov [bp + 61], t1134
964:	

scanFormat$281:	; call header integral zero 0 stack zero 0
966:	

scanFormat$282:	; parameter string, offset 6
967:		mov a1135, [bp + 61]
968:		mov [bp + 69], a1135
970:	

scanFormat$283:	; £temporary1776 = format + startIndex
971:		mov a1136, [bp + 6]
972:		add a1136, [bp + 59]
974:	

scanFormat$284:	; £temporary1775 -> £temporary1776 = *£temporary1776
976:	

scanFormat$285:	; £temporary1777 = &£temporary1775 -> £temporary1776
978:	

scanFormat$286:	; parameter £temporary1777, offset 8
979:		mov [bp + 71], a1136
981:	

scanFormat$287:	; parameter not, offset 10
982:		mov a1137, [bp + 57]
983:		mov [bp + 73], a1137
985:	

scanFormat$288:	; call function noellipse-noellipse scanPattern
986:		mov word [bp + 63], scanFormat$289
987:		mov [bp + 65], bp
988:		add bp, 63
989:		jmp scanPattern
991:	

scanFormat$289:	; post call
993:	

scanFormat$290:	; goto 323
994:		jmp scanFormat$323
996:	

scanFormat$291:	; call header integral zero 0 stack zero 0
998:	

scanFormat$292:	; parameter 0, offset 6
999:		mov word [bp + 67], 0
1001:	

scanFormat$293:	; £temporary1780 = format + startIndex
1002:		mov a1138, [bp + 6]
1003:		add a1138, [bp + 59]
1005:	

scanFormat$294:	; £temporary1779 -> £temporary1780 = *£temporary1780
1007:	

scanFormat$295:	; £temporary1781 = &£temporary1779 -> £temporary1780
1009:	

scanFormat$296:	; parameter £temporary1781, offset 8
1010:		mov [bp + 69], a1138
1012:	

scanFormat$297:	; parameter not, offset 10
1013:		mov a1139, [bp + 57]
1014:		mov [bp + 71], a1139
1016:	

scanFormat$298:	; call function noellipse-noellipse scanPattern
1017:		mov word [bp + 61], scanFormat$299
1018:		mov [bp + 63], bp
1019:		add bp, 61
1020:		jmp scanPattern
1022:	

scanFormat$299:	; post call
1024:	

scanFormat$300:	; goto 323
1025:		jmp scanFormat$323
1027:	

scanFormat$301:	; arg_list = arg_list + 2
1028:		add word [bp + 8], 2
1030:	

scanFormat$302:	; £temporary1784 = arg_list - 2
1031:		mov a1140, [bp + 8]
1032:		sub a1140, 2
1034:	

scanFormat$303:	; £temporary1785 = int_to_int £temporary1784 (Signed_Int -> Pointer)
1037:	

scanFormat$304:	; £temporary1786 -> £temporary1785 = *£temporary1785
1039:	

scanFormat$305:	; charsPtr = £temporary1786 -> £temporary1785
1040:		mov t1141, [a1140]
1041:		mov [bp + 35], t1141
1043:	

scanFormat$306:	; £temporary1787 -> charsPtr = *charsPtr
1044:		mov a1142, [bp + 35]
1046:	

scanFormat$307:	; £temporary1787 -> charsPtr = g_inChars
1047:		mov a1143, [g_inChars]
1048:		mov [a1142], a1143
1050:	

scanFormat$308:	; percent = 0
1051:		mov word [bp + 13], 0
1053:	

scanFormat$309:	; goto 323
1054:		jmp scanFormat$323
1056:	

scanFormat$310:	; call header integral zero 0 stack zero 0
1058:	

scanFormat$311:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1059:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1061:	

scanFormat$312:	; £temporary1788 = int_to_int c (Signed_Char -> Signed_Int)
1062:		mov a1144, [bp + 10]
1064:		and a1144, 255
1066:		cmp a1144, 0
1067:		jge scanFormat$313
1068:		neg a1144
1070:		neg a1144
1072:	

scanFormat$313:	; parameter £temporary1788, offset 8
1073:		mov [bp + 65], a1144
1075:	

scanFormat$314:	; call function noellipse-ellipse printf, extra 0
1076:		mov word [bp + 57], scanFormat$315
1077:		mov [bp + 59], bp
1078:		add bp, 57
1079:		mov di, bp
1080:		add di, 2
1081:		jmp printf
1083:	

scanFormat$315:	; post call
1085:	

scanFormat$316:	; goto 323
1086:		jmp scanFormat$323
1088:	

scanFormat$317:	; if c != 37 goto 323
1089:		cmp byte [bp + 10], 37
1090:		jne scanFormat$323
1092:	

scanFormat$318:	; percent = 1
1093:		mov word [bp + 13], 1
1095:	

scanFormat$319:	; shortInt = 0
1096:		mov word [bp + 15], 0
1098:	

scanFormat$320:	; longIntOrDouble = 0
1099:		mov word [bp + 17], 0
1101:	

scanFormat$321:	; longDouble = 0
1102:		mov word [bp + 19], 0
1104:	

scanFormat$322:	; star = 0
1105:		mov word [bp + 21], 0
1107:	

scanFormat$323:	; ++index
1108:		inc word [bp + 31]
1110:	

scanFormat$324:	; goto 8
1111:		jmp scanFormat$8
1113:	

scanFormat$325:	; return_value = g_inCount
1114:		mov a1145, [g_inCount]
1116:	

scanFormat$326:	; return
1117:		mov t1146, [bp]
1118:		mov di, [bp + 4]
1119:		mov bp, [bp + 2]
1120:		jmp t1146
1122:	

scanFormat$327:	; function end scanFormat
1:	

scanf:	; £temporary1807 = &format
2:		mov t1147, bp
3:		add t1147, 6
5:	

scanf$1:	; £temporary1808 = int_to_int £temporary1807 (Pointer -> Pointer)
8:	

scanf$2:	; arg_list = £temporary1808 + 2
9:		add t1147, 2
10:		mov [di + 8], t1147
12:	

scanf$3:	; call header integral zero 0 stack zero 0
14:	

scanf$4:	; parameter format, offset 6
15:		mov a1148, [bp + 6]
16:		mov [di + 16], a1148
18:	

scanf$5:	; parameter arg_list, offset 8
19:		mov a1149, [di + 8]
20:		mov [di + 18], a1149
22:	

scanf$6:	; call function ellipse-noellipse vscanf
23:		mov word [di + 10], scanf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vscanf
30:	

scanf$7:	; post call
32:	

scanf$8:	; £temporary1810 = return_value
37:	

scanf$9:	; return_value = £temporary1810
39:	

scanf$10:	; return
40:		mov t1152, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t1152
45:	

scanf$11:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov a1153, [stdin]
5:		mov [bp + 16], a1153
7:	

vscanf$2:	; parameter format, offset 8
8:		mov a1154, [bp + 6]
9:		mov [bp + 18], a1154
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov a1155, [bp + 8]
13:		mov [bp + 20], a1155
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1814 = return_value
28:	

vscanf$7:	; return_value = £temporary1814
30:	

vscanf$8:	; return
31:		mov t1158, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp t1158
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1818 = &format
2:		mov t1159, bp
3:		add t1159, 8
5:	

fscanf$1:	; £temporary1819 = int_to_int £temporary1818 (Pointer -> Pointer)
8:	

fscanf$2:	; arg_list = £temporary1819 + 2
9:		add t1159, 2
10:		mov [di + 10], t1159
12:	

fscanf$3:	; call header integral zero 0 stack zero 0
14:	

fscanf$4:	; parameter inStream, offset 6
15:		mov a1160, [bp + 6]
16:		mov [di + 18], a1160
18:	

fscanf$5:	; parameter format, offset 8
19:		mov a1161, [bp + 8]
20:		mov [di + 20], a1161
22:	

fscanf$6:	; parameter arg_list, offset 10
23:		mov a1162, [di + 10]
24:		mov [di + 22], a1162
26:	

fscanf$7:	; call function ellipse-noellipse vfscanf
27:		mov word [di + 12], fscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfscanf
34:	

fscanf$8:	; post call
36:	

fscanf$9:	; £temporary1821 = return_value
41:	

fscanf$10:	; return_value = £temporary1821
43:	

fscanf$11:	; return
44:		mov t1165, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1165
49:	

fscanf$12:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1826 = int_to_int inStream (Pointer -> Pointer)
5:		mov a1166, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1826
9:		mov [g_inDevice], a1166
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov a1167, [bp + 8]
15:		mov [bp + 18], a1167
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov a1168, [bp + 10]
19:		mov [bp + 20], a1168
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1827 = return_value
34:	

vfscanf$9:	; return_value = £temporary1827
36:	

vfscanf$10:	; return
37:		mov t1171, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1171
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1830 = &format
2:		mov t1172, bp
3:		add t1172, 8
5:	

sscanf$1:	; £temporary1831 = int_to_int £temporary1830 (Pointer -> Pointer)
8:	

sscanf$2:	; arg_list = £temporary1831 + 2
9:		add t1172, 2
10:		mov [di + 10], t1172
12:	

sscanf$3:	; call header integral zero 0 stack zero 0
14:	

sscanf$4:	; parameter inString, offset 6
15:		mov a1173, [bp + 6]
16:		mov [di + 18], a1173
18:	

sscanf$5:	; parameter format, offset 8
19:		mov a1174, [bp + 8]
20:		mov [di + 20], a1174
22:	

sscanf$6:	; parameter arg_list, offset 10
23:		mov a1175, [di + 10]
24:		mov [di + 22], a1175
26:	

sscanf$7:	; call function ellipse-noellipse vsscanf
27:		mov word [di + 12], sscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsscanf
34:	

sscanf$8:	; post call
36:	

sscanf$9:	; £temporary1833 = return_value
41:	

sscanf$10:	; return_value = £temporary1833
43:	

sscanf$11:	; return
44:		mov t1178, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1178
49:	

sscanf$12:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1838 = int_to_int inString (Pointer -> Pointer)
5:		mov a1179, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1838
9:		mov [g_inDevice], a1179
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov a1180, [bp + 8]
15:		mov [bp + 18], a1180
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov a1181, [bp + 10]
19:		mov [bp + 20], a1181
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1839 = return_value
34:	

vsscanf$9:	; return_value = £temporary1839
36:	

vsscanf$10:	; return
37:		mov t1184, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1184
42:	

vsscanf$11:	; function end vsscanf
