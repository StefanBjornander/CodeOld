1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov a848, [g_inStatus]
6:		cmp a848, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp a848, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1240 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov a849, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1240
23:		mov [bp + 7], a849
25:	

scanChar$7:	; £temporary1241 -> stream = *stream, offset 2
26:		mov a850, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1241 -> stream
29:		mov t851, [a850 + 2]
30:		mov [bp + 9], t851
32:	

scanChar$9:	; ah = 63
33:		mov a852, 63
35:	

scanChar$10:	; bx = handle
36:		mov a853, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov a854, 1
41:	

scanChar$12:	; £temporary1246 = &c
42:		mov t855, bp
43:		add t855, 6
45:	

scanChar$13:	; dx = £temporary1246
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov a856, [bp + 6]
56:	

scanChar$17:	; return
57:		mov t857, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp t857
62:	

scanChar$18:	; £temporary1248 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov a858, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1248
67:		mov [bp + 11], a858
69:	

scanChar$20:	; £temporary1249 = g_inChars
70:		mov t859, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1251 = inString + £temporary1249
76:		mov a860, [bp + 11]
77:		add a860, t859
79:	

scanChar$23:	; £temporary1250 -> £temporary1251 = *£temporary1251
81:	

scanChar$24:	; return_value = £temporary1250 -> £temporary1251
82:		mov t861, [a860]
84:	

scanChar$25:	; return
85:		mov t862, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp t862
90:	

scanChar$26:	; return_value = 0
91:		mov a863, 0
93:	

scanChar$27:	; return
94:		mov t864, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp t864
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov a865, [g_inStatus]
3:		cmp a865, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp a865, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov t866, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp t866
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1255 = return_value
19:	

scanPattern$5:	; input = £temporary1255
20:		mov [bp + 14], t868
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1256 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov a869, [bp + 14]
27:		and a869, 255
29:		cmp a869, 0
30:		jge scanPattern$8
31:		neg a869
33:		neg a869
35:	

scanPattern$8:	; parameter £temporary1256, offset 6
36:		mov [bp + 21], a869
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1257 = return_value
51:	

scanPattern$12:	; if £temporary1257 == 0 goto 19
52:		cmp t871, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1258 = return_value
70:	

scanPattern$17:	; input = £temporary1258
71:		mov [bp + 14], t873
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov a874, [bp + 8]
88:		mov [bp + 21], a874
90:	

scanPattern$23:	; £temporary1263 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov a875, [bp + 14]
93:		and a875, 255
95:		cmp a875, 0
96:		jge scanPattern$24
97:		neg a875
99:		neg a875
101:	

scanPattern$24:	; parameter £temporary1263, offset 8
102:		mov [bp + 23], a875
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1264 = return_value
117:	

scanPattern$28:	; if £temporary1264 != 0 goto 38
118:		cmp t877, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov a878, [bp + 8]
129:		mov [bp + 21], a878
131:	

scanPattern$32:	; £temporary1267 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov a879, [bp + 14]
134:		and a879, 255
136:		cmp a879, 0
137:		jge scanPattern$33
138:		neg a879
140:		neg a879
142:	

scanPattern$33:	; parameter £temporary1267, offset 8
143:		mov [bp + 23], a879
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1268 = return_value
158:	

scanPattern$37:	; if £temporary1268 != 0 goto 49
159:		cmp t881, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1274 = index
163:		mov t882, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1276 = string + £temporary1274
169:		mov a883, [bp + 6]
170:		add a883, t882
172:	

scanPattern$41:	; £temporary1275 -> £temporary1276 = *£temporary1276
174:	

scanPattern$42:	; £temporary1275 -> £temporary1276 = input
175:		mov a884, [bp + 14]
176:		mov [a883], a884
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1277 = return_value
193:	

scanPattern$47:	; input = £temporary1277
194:		mov [bp + 14], t886
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1279 = string + index
200:		mov a887, [bp + 6]
201:		add a887, [bp + 12]
203:	

scanPattern$50:	; £temporary1278 -> £temporary1279 = *£temporary1279
205:	

scanPattern$51:	; £temporary1278 -> £temporary1279 = 0
206:		mov byte [a887], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov a888, [bp + 8]
219:		mov [bp + 21], a888
221:	

scanPattern$56:	; £temporary1282 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov a889, [bp + 14]
224:		and a889, 255
226:		cmp a889, 0
227:		jge scanPattern$57
228:		neg a889
230:		neg a889
232:	

scanPattern$57:	; parameter £temporary1282, offset 8
233:		mov [bp + 23], a889
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1283 = return_value
248:	

scanPattern$61:	; if £temporary1283 != 0 goto 71
249:		cmp t891, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov a892, [bp + 8]
260:		mov [bp + 21], a892
262:	

scanPattern$65:	; £temporary1286 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov a893, [bp + 14]
265:		and a893, 255
267:		cmp a893, 0
268:		jge scanPattern$66
269:		neg a893
271:		neg a893
273:	

scanPattern$66:	; parameter £temporary1286, offset 8
274:		mov [bp + 23], a893
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1287 = return_value
289:	

scanPattern$70:	; if £temporary1287 != 0 goto 77
290:		cmp t895, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1293 = return_value
308:	

scanPattern$75:	; input = £temporary1293
309:		mov [bp + 14], t897
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov t898, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp t898
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1303 = return_value
19:	

scanString$5:	; input = £temporary1303
20:		mov [bp + 12], t900
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1304 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a901, [bp + 12]
30:		and a901, 255
32:		cmp a901, 0
33:		jge scanString$9
34:		neg a901
36:		neg a901
38:	

scanString$9:	; parameter £temporary1304, offset 6
39:		mov [bp + 21], a901
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1305 = return_value
54:	

scanString$13:	; if £temporary1305 == 0 goto 20
55:		cmp t903, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1306 = return_value
73:	

scanString$18:	; input = £temporary1306
74:		mov [bp + 12], t905
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1310 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov a906, [bp + 12]
92:		and a906, 255
94:		cmp a906, 0
95:		jge scanString$24
96:		neg a906
98:		neg a906
100:	

scanString$24:	; parameter £temporary1310, offset 6
101:		mov [bp + 21], a906
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1311 = return_value
116:	

scanString$28:	; if £temporary1311 != 0 goto 45
117:		cmp t908, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1314 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov a909, [bp + 12]
123:		and a909, 255
125:		cmp a909, 0
126:		jge scanString$30
127:		neg a909
129:		neg a909
131:	

scanString$30:	; if £temporary1314 == -1 goto 45
132:		cmp a909, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1319 = index
140:		mov t910, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1321 = string + £temporary1319
146:		mov a911, [bp + 6]
147:		add a911, t910
149:	

scanString$35:	; £temporary1320 -> £temporary1321 = *£temporary1321
151:	

scanString$36:	; £temporary1320 -> £temporary1321 = input
152:		mov a912, [bp + 12]
153:		mov [a911], a912
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1322 = return_value
170:	

scanString$41:	; input = £temporary1322
171:		mov [bp + 12], t914
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1325 = string + index
183:		mov a915, [bp + 6]
184:		add a915, [bp + 10]
186:	

scanString$46:	; £temporary1324 -> £temporary1325 = *£temporary1325
188:	

scanString$47:	; £temporary1324 -> £temporary1325 = 0
189:		mov byte [a915], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1327 = precision
198:		mov t916, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1327 <= 0 goto 76
204:		cmp t916, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1329 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov a917, [bp + 12]
212:		and a917, 255
214:		cmp a917, 0
215:		jge scanString$55
216:		neg a917
218:		neg a917
220:	

scanString$55:	; parameter £temporary1329, offset 6
221:		mov [bp + 21], a917
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1330 = return_value
236:	

scanString$59:	; if £temporary1330 != 0 goto 76
237:		cmp t919, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1333 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov a920, [bp + 12]
243:		and a920, 255
245:		cmp a920, 0
246:		jge scanString$61
247:		neg a920
249:		neg a920
251:	

scanString$61:	; if £temporary1333 == -1 goto 76
252:		cmp a920, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1339 = index
260:		mov t921, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1341 = string + £temporary1339
266:		mov a922, [bp + 6]
267:		add a922, t921
269:	

scanString$66:	; £temporary1340 -> £temporary1341 = *£temporary1341
271:	

scanString$67:	; £temporary1340 -> £temporary1341 = input
272:		mov a923, [bp + 12]
273:		mov [a922], a923
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1342 = return_value
290:	

scanString$72:	; input = £temporary1342
291:		mov [bp + 12], t925
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1346 = string + index
307:		mov a926, [bp + 6]
308:		add a926, [bp + 10]
310:	

scanString$78:	; £temporary1345 -> £temporary1346 = *£temporary1346
312:	

scanString$79:	; £temporary1345 -> £temporary1346 = 0
313:		mov byte [a926], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1349 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov a927, [bp + 12]
330:		and a927, 255
332:		cmp a927, 0
333:		jge scanString$85
334:		neg a927
336:		neg a927
338:	

scanString$85:	; parameter £temporary1349, offset 6
339:		mov [bp + 21], a927
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1350 = return_value
354:	

scanString$89:	; if £temporary1350 != 0 goto 101
355:		cmp t929, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1353 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov a930, [bp + 12]
361:		and a930, 255
363:		cmp a930, 0
364:		jge scanString$91
365:		neg a930
367:		neg a930
369:	

scanString$91:	; if £temporary1353 == -1 goto 101
370:		cmp a930, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1358 = return_value
392:	

scanString$97:	; input = £temporary1358
393:		mov [bp + 12], t932
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1361 = precision
411:		mov t933, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1361 <= 0 goto 124
417:		cmp t933, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1363 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov a934, [bp + 12]
425:		and a934, 255
427:		cmp a934, 0
428:		jge scanString$108
429:		neg a934
431:		neg a934
433:	

scanString$108:	; parameter £temporary1363, offset 6
434:		mov [bp + 21], a934
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1364 = return_value
449:	

scanString$112:	; if £temporary1364 != 0 goto 124
450:		cmp t936, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1367 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov a937, [bp + 12]
456:		and a937, 255
458:		cmp a937, 0
459:		jge scanString$114
460:		neg a937
462:		neg a937
464:	

scanString$114:	; if £temporary1367 == -1 goto 124
465:		cmp a937, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1373 = return_value
487:	

scanString$120:	; input = £temporary1373
488:		mov [bp + 12], t939
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov t940, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp t940
519:	

scanString$129:	; function end scanString
1:	

digitToValue:	; call header integral zero 0 stack zero 0
3:	

digitToValue$1:	; £temporary1384 = int_to_int input (Signed_Char -> Signed_Int)
4:		mov a941, [bp + 6]
6:		and a941, 255
8:		cmp a941, 0
9:		jge digitToValue$2
10:		neg a941
12:		neg a941
14:	

digitToValue$2:	; parameter £temporary1384, offset 6
15:		mov [bp + 13], a941
17:	

digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

digitToValue$4:	; post call
25:	

digitToValue$5:	; £temporary1385 = return_value
30:	

digitToValue$6:	; if £temporary1385 == 0 goto 11
31:		cmp t943, 0
32:		je digitToValue$11
34:	

digitToValue$7:	; £temporary1386 = input - 48
35:		mov a944, [bp + 6]
36:		sub a944, 48
38:	

digitToValue$8:	; £temporary1387 = int_to_int £temporary1386 (Signed_Char -> Unsigned_Long_Int)
40:		and a944, 255
42:	

digitToValue$9:	; return_value = £temporary1387
44:	

digitToValue$10:	; return
45:		mov t945, [bp]
46:		mov di, [bp + 4]
47:		mov bp, [bp + 2]
48:		jmp t945
50:	

digitToValue$11:	; call header integral zero 0 stack zero 0
52:	

digitToValue$12:	; £temporary1388 = int_to_int input (Signed_Char -> Signed_Int)
53:		mov a946, [bp + 6]
55:		and a946, 255
57:		cmp a946, 0
58:		jge digitToValue$13
59:		neg a946
61:		neg a946
63:	

digitToValue$13:	; parameter £temporary1388, offset 6
64:		mov [bp + 13], a946
66:	

digitToValue$14:	; call function noellipse-noellipse islower
67:		mov word [bp + 7], digitToValue$15
68:		mov [bp + 9], bp
69:		add bp, 7
70:		jmp islower
72:	

digitToValue$15:	; post call
74:	

digitToValue$16:	; £temporary1389 = return_value
79:	

digitToValue$17:	; if £temporary1389 == 0 goto 23
80:		cmp t948, 0
81:		je digitToValue$23
83:	

digitToValue$18:	; £temporary1390 = input - 97
84:		mov a949, [bp + 6]
85:		sub a949, 97
87:	

digitToValue$19:	; £temporary1391 = int_to_int £temporary1390 (Signed_Char -> Unsigned_Long_Int)
89:		and a949, 255
91:	

digitToValue$20:	; £temporary1392 = £temporary1391 + 10
92:		add a949, 10
94:	

digitToValue$21:	; return_value = £temporary1392
96:	

digitToValue$22:	; return
97:		mov t950, [bp]
98:		mov di, [bp + 4]
99:		mov bp, [bp + 2]
100:		jmp t950
102:	

digitToValue$23:	; £temporary1393 = input - 65
103:		mov a951, [bp + 6]
104:		sub a951, 65
106:	

digitToValue$24:	; £temporary1394 = int_to_int £temporary1393 (Signed_Char -> Unsigned_Long_Int)
108:		and a951, 255
110:	

digitToValue$25:	; £temporary1395 = £temporary1394 + 10
111:		add a951, 10
113:	

digitToValue$26:	; return_value = £temporary1395
115:	

digitToValue$27:	; return
116:		mov t952, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp t952
121:	

digitToValue$28:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 6], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 10], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 12], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 14], scanLongInt$5
14:		mov [bp + 16], bp
15:		add bp, 14
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1400 = return_value
25:	

scanLongInt$7:	; input = £temporary1400
26:		mov [bp + 14], t954
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1401 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov a955, [bp + 14]
33:		and a955, 255
35:		cmp a955, 0
36:		jge scanLongInt$10
37:		neg a955
39:		neg a955
41:	

scanLongInt$10:	; parameter £temporary1401, offset 6
42:		mov [bp + 21], a955
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 15], scanLongInt$12
46:		mov [bp + 17], bp
47:		add bp, 15
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1402 = return_value
57:	

scanLongInt$14:	; if £temporary1402 == 0 goto 21
58:		cmp t957, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 15], scanLongInt$17
65:		mov [bp + 17], bp
66:		add bp, 15
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1403 = return_value
76:	

scanLongInt$19:	; input = £temporary1403
77:		mov [bp + 14], t959
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 14], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 15], scanLongInt$24
90:		mov [bp + 17], bp
91:		add bp, 15
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1406 = return_value
101:	

scanLongInt$26:	; input = £temporary1406
102:		mov [bp + 14], t961
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 14], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 10], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 15], scanLongInt$32
118:		mov [bp + 17], bp
119:		add bp, 15
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1408 = return_value
129:	

scanLongInt$34:	; input = £temporary1408
130:		mov [bp + 14], t963
132:	

scanLongInt$35:	; call header integral zero 0 stack zero 0
134:	

scanLongInt$36:	; £temporary1409 = int_to_int input (Signed_Char -> Signed_Int)
135:		mov a964, [bp + 14]
137:		and a964, 255
139:		cmp a964, 0
140:		jge scanLongInt$37
141:		neg a964
143:		neg a964
145:	

scanLongInt$37:	; parameter £temporary1409, offset 6
146:		mov [bp + 21], a964
148:	

scanLongInt$38:	; call function noellipse-noellipse isdigit
149:		mov word [bp + 15], scanLongInt$39
150:		mov [bp + 17], bp
151:		add bp, 15
152:		jmp isdigit
154:	

scanLongInt$39:	; post call
156:	

scanLongInt$40:	; £temporary1410 = return_value
161:	

scanLongInt$41:	; if £temporary1410 == 0 goto 53
162:		cmp t966, 0
163:		je scanLongInt$53
165:	

scanLongInt$42:	; £temporary1411 = longValue * 10
166:		mov a967, [bp + 6]
168:		xor edx, edx
169:		imul dword [int4$10#]
175:	

scanLongInt$43:	; £temporary1412 = input - 48
176:		mov a971, [bp + 14]
177:		sub a971, 48
179:	

scanLongInt$44:	; £temporary1413 = int_to_int £temporary1412 (Signed_Char -> Signed_Long_Int)
181:		and a971, 255
183:		cmp a971, 0
184:		jge scanLongInt$45
185:		neg a971
187:		neg a971
189:	

scanLongInt$45:	; longValue = £temporary1411 + £temporary1413
190:		add t970, a971
191:		mov [bp + 6], t970
193:	

scanLongInt$46:	; call header integral zero 0 stack zero 0
195:	

scanLongInt$47:	; call function noellipse-noellipse scanChar
196:		mov word [bp + 15], scanLongInt$48
197:		mov [bp + 17], bp
198:		add bp, 15
199:		jmp scanChar
201:	

scanLongInt$48:	; post call
203:	

scanLongInt$49:	; £temporary1415 = return_value
208:	

scanLongInt$50:	; input = £temporary1415
209:		mov [bp + 14], t973
211:	

scanLongInt$51:	; found = 1
212:		mov word [bp + 12], 1
214:	

scanLongInt$52:	; goto 35
215:		jmp scanLongInt$35
217:	

scanLongInt$53:	; if minus == 0 goto 56
218:		cmp word [bp + 10], 0
219:		je scanLongInt$56
221:	

scanLongInt$54:	; £temporary1417 = -longValue
222:		mov a974, [bp + 6]
223:		neg a974
225:	

scanLongInt$55:	; longValue = £temporary1417
226:		mov [bp + 6], a974
228:	

scanLongInt$56:	; if found == 0 goto 58
229:		cmp word [bp + 12], 0
230:		je scanLongInt$58
232:	

scanLongInt$57:	; ++g_inCount
233:		inc word [g_inCount]
235:	

scanLongInt$58:	; call header integral zero 0 stack zero 0
237:	

scanLongInt$59:	; parameter input, offset 6
238:		mov a975, [bp + 14]
239:		mov [bp + 21], a975
241:	

scanLongInt$60:	; call function noellipse-noellipse unscanChar
242:		mov word [bp + 15], scanLongInt$61
243:		mov [bp + 17], bp
244:		add bp, 15
245:		jmp unscanChar
247:	

scanLongInt$61:	; post call
249:	

scanLongInt$62:	; return_value = longValue
250:		mov a976, [bp + 6]
252:	

scanLongInt$63:	; return
253:		mov t977, [bp]
254:		mov di, [bp + 4]
255:		mov bp, [bp + 2]
256:		jmp t977
258:	

scanLongInt$64:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 10], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 18], scanUnsignedLongInt$3
8:		mov [bp + 20], bp
9:		add bp, 18
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1425 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1425
20:		mov [bp + 18], t979
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 19], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1426 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a980, [bp + 18]
30:		and a980, 255
32:		cmp a980, 0
33:		jge scanUnsignedLongInt$9
34:		neg a980
36:		neg a980
38:	

scanUnsignedLongInt$9:	; parameter £temporary1426, offset 6
39:		mov [bp + 27], a980
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 21], scanUnsignedLongInt$11
43:		mov [bp + 23], bp
44:		add bp, 21
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1427 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1427 == 0 goto 20
55:		cmp t982, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 21], scanUnsignedLongInt$16
62:		mov [bp + 23], bp
63:		add bp, 21
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1428 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1428
74:		mov [bp + 18], t984
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 48 goto 49
80:		cmp byte [bp + 18], 48
81:		jne scanUnsignedLongInt$49
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 21], scanUnsignedLongInt$23
87:		mov [bp + 23], bp
88:		add bp, 21
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1431 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1431
99:		mov [bp + 18], t986
101:	

scanUnsignedLongInt$26:	; call header integral zero 0 stack zero 0
103:	

scanUnsignedLongInt$27:	; £temporary1432 = int_to_int input (Signed_Char -> Signed_Int)
104:		mov a987, [bp + 18]
106:		and a987, 255
108:		cmp a987, 0
109:		jge scanUnsignedLongInt$28
110:		neg a987
112:		neg a987
114:	

scanUnsignedLongInt$28:	; parameter £temporary1432, offset 6
115:		mov [bp + 27], a987
117:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse tolower
118:		mov word [bp + 21], scanUnsignedLongInt$30
119:		mov [bp + 23], bp
120:		add bp, 21
121:		jmp tolower
123:	

scanUnsignedLongInt$30:	; post call
125:	

scanUnsignedLongInt$31:	; £temporary1433 = return_value
130:	

scanUnsignedLongInt$32:	; if £temporary1433 != 120 goto 44
131:		cmp t989, 120
132:		jne scanUnsignedLongInt$44
134:	

scanUnsignedLongInt$33:	; if base != 0 goto 36
135:		cmp dword [bp + 6], 0
136:		jne scanUnsignedLongInt$36
138:	

scanUnsignedLongInt$34:	; £temporary1439 = 16
139:		mov t990, 16
141:	

scanUnsignedLongInt$35:	; goto 37
142:		jmp scanUnsignedLongInt$37
144:	

scanUnsignedLongInt$36:	; £temporary1439 = base
145:		mov t991, [bp + 6]
147:	

scanUnsignedLongInt$37:	; base = £temporary1439
148:		mov [bp + 6], t991
150:	

scanUnsignedLongInt$38:	; call header integral zero 0 stack zero 0
152:	

scanUnsignedLongInt$39:	; call function noellipse-noellipse scanChar
153:		mov word [bp + 21], scanUnsignedLongInt$40
154:		mov [bp + 23], bp
155:		add bp, 21
156:		jmp scanChar
158:	

scanUnsignedLongInt$40:	; post call
160:	

scanUnsignedLongInt$41:	; £temporary1440 = return_value
165:	

scanUnsignedLongInt$42:	; input = £temporary1440
166:		mov [bp + 18], t993
168:	

scanUnsignedLongInt$43:	; goto 49
169:		jmp scanUnsignedLongInt$49
171:	

scanUnsignedLongInt$44:	; if base != 0 goto 47
172:		cmp dword [bp + 6], 0
173:		jne scanUnsignedLongInt$47
175:	

scanUnsignedLongInt$45:	; £temporary1445 = 8
176:		mov t994, 8
178:	

scanUnsignedLongInt$46:	; goto 48
179:		jmp scanUnsignedLongInt$48
181:	

scanUnsignedLongInt$47:	; £temporary1445 = base
182:		mov t995, [bp + 6]
184:	

scanUnsignedLongInt$48:	; base = £temporary1445
185:		mov [bp + 6], t995
187:	

scanUnsignedLongInt$49:	; if base != 0 goto 51
188:		cmp dword [bp + 6], 0
189:		jne scanUnsignedLongInt$51
191:	

scanUnsignedLongInt$50:	; base = 10
192:		mov dword [bp + 6], 10
194:	

scanUnsignedLongInt$51:	; call header integral zero 0 stack zero 0
196:	

scanUnsignedLongInt$52:	; £temporary1447 = int_to_int input (Signed_Char -> Signed_Int)
197:		mov a996, [bp + 18]
199:		and a996, 255
201:		cmp a996, 0
202:		jge scanUnsignedLongInt$53
203:		neg a996
205:		neg a996
207:	

scanUnsignedLongInt$53:	; parameter £temporary1447, offset 6
208:		mov [bp + 27], a996
210:	

scanUnsignedLongInt$54:	; call function noellipse-noellipse isxdigit
211:		mov word [bp + 21], scanUnsignedLongInt$55
212:		mov [bp + 23], bp
213:		add bp, 21
214:		jmp isxdigit
216:	

scanUnsignedLongInt$55:	; post call
218:	

scanUnsignedLongInt$56:	; £temporary1448 = return_value
223:	

scanUnsignedLongInt$57:	; if £temporary1448 == 0 goto 74
224:		cmp t998, 0
225:		je scanUnsignedLongInt$74
227:	

scanUnsignedLongInt$58:	; call header integral zero 0 stack zero 0
229:	

scanUnsignedLongInt$59:	; parameter input, offset 6
230:		mov a999, [bp + 18]
231:		mov [bp + 27], a999
233:	

scanUnsignedLongInt$60:	; call function noellipse-noellipse digitToValue
234:		mov word [bp + 21], scanUnsignedLongInt$61
235:		mov [bp + 23], bp
236:		add bp, 21
237:		jmp digitToValue
239:	

scanUnsignedLongInt$61:	; post call
241:	

scanUnsignedLongInt$62:	; £temporary1449 = return_value
246:	

scanUnsignedLongInt$63:	; digit = £temporary1449
247:		mov [bp + 14], t1001
249:	

scanUnsignedLongInt$64:	; if digit >= base goto 74
250:		mov a1002, [bp + 6]
251:		cmp [bp + 14], a1002
252:		jae scanUnsignedLongInt$74
254:	

scanUnsignedLongInt$65:	; £temporary1451 = unsignedLongValue * base
255:		mov a1003, [bp + 10]
257:		xor edx, edx
258:		mul dword [bp + 6]
264:	

scanUnsignedLongInt$66:	; unsignedLongValue = £temporary1451 + digit
265:		add t1006, [bp + 14]
266:		mov [bp + 10], t1006
268:	

scanUnsignedLongInt$67:	; found = 1
269:		mov word [bp + 19], 1
271:	

scanUnsignedLongInt$68:	; call header integral zero 0 stack zero 0
273:	

scanUnsignedLongInt$69:	; call function noellipse-noellipse scanChar
274:		mov word [bp + 21], scanUnsignedLongInt$70
275:		mov [bp + 23], bp
276:		add bp, 21
277:		jmp scanChar
279:	

scanUnsignedLongInt$70:	; post call
281:	

scanUnsignedLongInt$71:	; £temporary1453 = return_value
286:	

scanUnsignedLongInt$72:	; input = £temporary1453
287:		mov [bp + 18], t1008
289:	

scanUnsignedLongInt$73:	; goto 51
290:		jmp scanUnsignedLongInt$51
292:	

scanUnsignedLongInt$74:	; if found == 0 goto 76
293:		cmp word [bp + 19], 0
294:		je scanUnsignedLongInt$76
296:	

scanUnsignedLongInt$75:	; ++g_inCount
297:		inc word [g_inCount]
299:	

scanUnsignedLongInt$76:	; call header integral zero 0 stack zero 0
301:	

scanUnsignedLongInt$77:	; parameter input, offset 6
302:		mov a1009, [bp + 18]
303:		mov [bp + 27], a1009
305:	

scanUnsignedLongInt$78:	; call function noellipse-noellipse unscanChar
306:		mov word [bp + 21], scanUnsignedLongInt$79
307:		mov [bp + 23], bp
308:		add bp, 21
309:		jmp unscanChar
311:	

scanUnsignedLongInt$79:	; post call
313:	

scanUnsignedLongInt$80:	; return_value = unsignedLongValue
314:		mov a1010, [bp + 10]
316:	

scanUnsignedLongInt$81:	; return
317:		mov t1011, [bp]
318:		mov di, [bp + 4]
319:		mov bp, [bp + 2]
320:		jmp t1011
322:	

scanUnsignedLongInt$82:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1463 = return_value
34:	

scanLongDouble$10:	; input = £temporary1463
35:		mov [bp + 26], t1013
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1464 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov a1014, [bp + 26]
42:		and a1014, 255
44:		cmp a1014, 0
45:		jge scanLongDouble$13
46:		neg a1014
48:		neg a1014
50:	

scanLongDouble$13:	; parameter £temporary1464, offset 6
51:		mov [bp + 33], a1014
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1465 = return_value
66:	

scanLongDouble$17:	; if £temporary1465 == 0 goto 24
67:		cmp t1016, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1466 = return_value
85:	

scanLongDouble$22:	; input = £temporary1466
86:		mov [bp + 26], t1018
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1469 = return_value
110:	

scanLongDouble$29:	; input = £temporary1469
111:		mov [bp + 26], t1020
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1471 = return_value
138:	

scanLongDouble$37:	; input = £temporary1471
139:		mov [bp + 26], t1022
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1472 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov a1023, [bp + 26]
146:		and a1023, 255
148:		cmp a1023, 0
149:		jge scanLongDouble$40
150:		neg a1023
152:		neg a1023
154:	

scanLongDouble$40:	; parameter £temporary1472, offset 6
155:		mov [bp + 33], a1023
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1473 = return_value
170:	

scanLongDouble$44:	; if £temporary1473 == 0 goto 60
171:		cmp t1025, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1474 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1475 = input - 48
184:		mov a1026, [bp + 26]
185:		sub a1026, 48
187:	

scanLongDouble$49:	; £temporary1477 = int_to_int £temporary1475 (Signed_Char -> Signed_Int)
189:		and a1026, 255
191:		cmp a1026, 0
192:		jge scanLongDouble$50
193:		neg a1026
195:		neg a1026
197:	

scanLongDouble$50:	; £temporary1476 = int_to_float £temporary1477 (Signed_Int -> Long_Double)
198:		mov [container2bytes#], a1026
199:		fild word [container2bytes#]
201:	

scanLongDouble$51:	; £temporary1478 = £temporary1474 + £temporary1476
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1479 = return_value
222:	

scanLongDouble$57:	; input = £temporary1479
223:		mov [bp + 26], t1028
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1482 = return_value
250:	

scanLongDouble$65:	; input = £temporary1482
251:		mov [bp + 26], t1030
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1483 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov a1031, [bp + 26]
258:		and a1031, 255
260:		cmp a1031, 0
261:		jge scanLongDouble$68
262:		neg a1031
264:		neg a1031
266:	

scanLongDouble$68:	; parameter £temporary1483, offset 6
267:		mov [bp + 33], a1031
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1484 = return_value
282:	

scanLongDouble$72:	; if £temporary1484 == 0 goto 92
283:		cmp t1033, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1485 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1486 = input - 48
305:		mov a1034, [bp + 26]
306:		sub a1034, 48
308:	

scanLongDouble$80:	; £temporary1488 = int_to_int £temporary1486 (Signed_Char -> Signed_Int)
310:		and a1034, 255
312:		cmp a1034, 0
313:		jge scanLongDouble$81
314:		neg a1034
316:		neg a1034
318:	

scanLongDouble$81:	; £temporary1487 = int_to_float £temporary1488 (Signed_Int -> Long_Double)
319:		mov [container2bytes#], a1034
320:		fild word [container2bytes#]
322:	

scanLongDouble$82:	; £temporary1489 = factor * £temporary1487
323:		fmul
325:	

scanLongDouble$83:	; £temporary1490 = value + £temporary1489
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1491 = return_value
346:	

scanLongDouble$89:	; input = £temporary1491
347:		mov [bp + 26], t1036
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; parameter input, offset 6
358:		mov a1037, [bp + 26]
359:		mov [bp + 33], a1037
361:	

scanLongDouble$94:	; call function noellipse-noellipse unscanChar
362:		mov word [bp + 27], scanLongDouble$95
363:		mov [bp + 29], bp
364:		add bp, 27
365:		jmp unscanChar
367:	

scanLongDouble$95:	; post call
369:	

scanLongDouble$96:	; call header integral zero 0 stack zero 0
371:	

scanLongDouble$97:	; £temporary1494 = int_to_int input (Signed_Char -> Signed_Int)
372:		mov a1038, [bp + 26]
374:		and a1038, 255
376:		cmp a1038, 0
377:		jge scanLongDouble$98
378:		neg a1038
380:		neg a1038
382:	

scanLongDouble$98:	; parameter £temporary1494, offset 6
383:		mov [bp + 33], a1038
385:	

scanLongDouble$99:	; call function noellipse-noellipse tolower
386:		mov word [bp + 27], scanLongDouble$100
387:		mov [bp + 29], bp
388:		add bp, 27
389:		jmp tolower
391:	

scanLongDouble$100:	; post call
393:	

scanLongDouble$101:	; £temporary1495 = return_value
398:	

scanLongDouble$102:	; if £temporary1495 != 101 goto 121
399:		cmp t1040, 101
400:		jne scanLongDouble$121
402:	

scanLongDouble$103:	; call header integral zero 0 stack zero 0
404:	

scanLongDouble$104:	; call function noellipse-noellipse scanLongInt
405:		mov word [bp + 27], scanLongDouble$105
406:		mov [bp + 29], bp
407:		add bp, 27
408:		jmp scanLongInt
410:	

scanLongDouble$105:	; post call
412:	

scanLongDouble$106:	; £temporary1497 = return_value
417:	

scanLongDouble$107:	; £temporary1498 = int_to_float £temporary1497 (Signed_Long_Int -> Double)
418:		mov [container4bytes#], t1042
419:		fild dword [container4bytes#]
421:	

scanLongDouble$108:	; pop float exponent
422:		fstp qword [bp + 27]
424:	

scanLongDouble$109:	; push float value
425:		fld qword [bp + 10]
427:	

scanLongDouble$110:	; call header integral zero 0 stack no zero 1
428:		fstp qword [bp + 35]
430:	

scanLongDouble$111:	; push float 10.0
431:		fld qword [float8$10.0#]
433:	

scanLongDouble$112:	; parameter 10.0, offset 6
434:		fstp qword [bp + 49]
436:	

scanLongDouble$113:	; push float exponent
437:		fld qword [bp + 27]
439:	

scanLongDouble$114:	; parameter exponent, offset 14
440:		fstp qword [bp + 57]
442:	

scanLongDouble$115:	; call function noellipse-noellipse pow
443:		mov word [bp + 43], scanLongDouble$116
444:		mov [bp + 45], bp
445:		add bp, 43
446:		jmp pow
448:	

scanLongDouble$116:	; post call
449:		fstp qword [bp + 43]
450:		fld qword [bp + 35]
451:		fld qword [bp + 43]
453:	

scanLongDouble$117:	; £temporary1499 = return_value
455:	

scanLongDouble$118:	; £temporary1500 = value * £temporary1499
456:		fmul
458:	

scanLongDouble$119:	; pop float value
459:		fstp qword [bp + 10]
461:	

scanLongDouble$120:	; goto 125
462:		jmp scanLongDouble$125
464:	

scanLongDouble$121:	; call header integral zero 0 stack zero 0
466:	

scanLongDouble$122:	; parameter input, offset 6
467:		mov a1043, [bp + 26]
468:		mov [bp + 33], a1043
470:	

scanLongDouble$123:	; call function noellipse-noellipse unscanChar
471:		mov word [bp + 27], scanLongDouble$124
472:		mov [bp + 29], bp
473:		add bp, 27
474:		jmp unscanChar
476:	

scanLongDouble$124:	; post call
478:	

scanLongDouble$125:	; if minus == 0 goto 129
479:		cmp word [bp + 6], 0
480:		je scanLongDouble$129
482:	

scanLongDouble$126:	; push float value
483:		fld qword [bp + 10]
485:	

scanLongDouble$127:	; £temporary1502 = -value
486:		fchs
488:	

scanLongDouble$128:	; pop float value
489:		fstp qword [bp + 10]
491:	

scanLongDouble$129:	; if found == 0 goto 131
492:		cmp word [bp + 8], 0
493:		je scanLongDouble$131
495:	

scanLongDouble$130:	; ++g_inCount
496:		inc word [g_inCount]
498:	

scanLongDouble$131:	; push float value
499:		fld qword [bp + 10]
501:	

scanLongDouble$132:	; return_value = value
503:	

scanLongDouble$133:	; return
504:		mov t1044, [bp]
505:		mov di, [bp + 4]
506:		mov bp, [bp + 2]
507:		jmp t1044
509:	

scanLongDouble$134:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1515 = format + index
26:		mov a1045, [bp + 6]
27:		add a1045, [bp + 31]
29:	

scanFormat$9:	; £temporary1514 -> £temporary1515 = *£temporary1515
31:	

scanFormat$10:	; if £temporary1514 -> £temporary1515 == 0 goto 325
32:		cmp byte [a1045], 0
33:		je scanFormat$325
35:	

scanFormat$11:	; £temporary1519 = format + index
36:		mov a1046, [bp + 6]
37:		add a1046, [bp + 31]
39:	

scanFormat$12:	; £temporary1518 -> £temporary1519 = *£temporary1519
41:	

scanFormat$13:	; c = £temporary1518 -> £temporary1519
42:		mov t1047, [a1046]
43:		mov [bp + 10], t1047
45:	

scanFormat$14:	; £temporary1520 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov a1048, [bp + 10]
48:		and a1048, 255
50:		cmp a1048, 0
51:		jge scanFormat$15
52:		neg a1048
54:		neg a1048
56:	

scanFormat$15:	; d = £temporary1520 + 1
57:		add a1048, 1
58:		mov [bp + 55], a1048
60:	

scanFormat$16:	; if percent == 0 goto 317
61:		cmp word [bp + 13], 0
62:		je scanFormat$317
64:	

scanFormat$17:	; £temporary1522 = d - 1
65:		mov a1049, [bp + 55]
66:		sub a1049, 1
68:	

scanFormat$18:	; case £temporary1522 == 104 goto 36
69:		cmp a1049, 104
70:		je scanFormat$36
72:	

scanFormat$19:	; case £temporary1522 == 108 goto 38
73:		cmp a1049, 108
74:		je scanFormat$38
76:	

scanFormat$20:	; case £temporary1522 == 76 goto 40
77:		cmp a1049, 76
78:		je scanFormat$40
80:	

scanFormat$21:	; case £temporary1522 == 42 goto 42
81:		cmp a1049, 42
82:		je scanFormat$42
84:	

scanFormat$22:	; case £temporary1522 == 99 goto 44
85:		cmp a1049, 99
86:		je scanFormat$44
88:	

scanFormat$23:	; case £temporary1522 == 115 goto 62
89:		cmp a1049, 115
90:		je scanFormat$62
92:	

scanFormat$24:	; case £temporary1522 == 100 goto 81
93:		cmp a1049, 100
94:		je scanFormat$81
96:	

scanFormat$25:	; case £temporary1522 == 105 goto 81
97:		cmp a1049, 105
98:		je scanFormat$81
100:	

scanFormat$26:	; case £temporary1522 == 111 goto 116
101:		cmp a1049, 111
102:		je scanFormat$116
104:	

scanFormat$27:	; case £temporary1522 == 120 goto 152
105:		cmp a1049, 120
106:		je scanFormat$152
108:	

scanFormat$28:	; case £temporary1522 == 117 goto 188
109:		cmp a1049, 117
110:		je scanFormat$188
112:	

scanFormat$29:	; case £temporary1522 == 103 goto 224
113:		cmp a1049, 103
114:		je scanFormat$224
116:	

scanFormat$30:	; case £temporary1522 == 102 goto 224
117:		cmp a1049, 102
118:		je scanFormat$224
120:	

scanFormat$31:	; case £temporary1522 == 101 goto 224
121:		cmp a1049, 101
122:		je scanFormat$224
124:	

scanFormat$32:	; case £temporary1522 == 91 goto 260
125:		cmp a1049, 91
126:		je scanFormat$260
128:	

scanFormat$33:	; case £temporary1522 == 110 goto 301
129:		cmp a1049, 110
130:		je scanFormat$301
132:	

scanFormat$34:	; case end £temporary1522
134:	

scanFormat$35:	; goto 310
135:		jmp scanFormat$310
137:	

scanFormat$36:	; shortInt = 1
138:		mov word [bp + 15], 1
140:	

scanFormat$37:	; goto 323
141:		jmp scanFormat$323
143:	

scanFormat$38:	; longIntOrDouble = 1
144:		mov word [bp + 17], 1
146:	

scanFormat$39:	; goto 323
147:		jmp scanFormat$323
149:	

scanFormat$40:	; longDouble = 1
150:		mov word [bp + 19], 1
152:	

scanFormat$41:	; goto 323
153:		jmp scanFormat$323
155:	

scanFormat$42:	; star = 1
156:		mov word [bp + 21], 1
158:	

scanFormat$43:	; goto 323
159:		jmp scanFormat$323
161:	

scanFormat$44:	; call header integral zero 0 stack zero 0
163:	

scanFormat$45:	; call function noellipse-noellipse scanChar
164:		mov word [bp + 57], scanFormat$46
165:		mov [bp + 59], bp
166:		add bp, 57
167:		jmp scanChar
169:	

scanFormat$46:	; post call
171:	

scanFormat$47:	; £temporary1523 = return_value
176:	

scanFormat$48:	; charValue = £temporary1523
177:		mov [bp + 57], t1051
179:	

scanFormat$49:	; if star != 0 goto 57
180:		cmp word [bp + 21], 0
181:		jne scanFormat$57
183:	

scanFormat$50:	; arg_list = arg_list + 2
184:		add word [bp + 8], 2
186:	

scanFormat$51:	; £temporary1527 = arg_list - 2
187:		mov a1052, [bp + 8]
188:		sub a1052, 2
190:	

scanFormat$52:	; £temporary1528 = int_to_int £temporary1527 (Signed_Int -> Pointer)
193:	

scanFormat$53:	; £temporary1529 -> £temporary1528 = *£temporary1528
195:	

scanFormat$54:	; charPtr = £temporary1529 -> £temporary1528
196:		mov t1053, [a1052]
197:		mov [bp + 11], t1053
199:	

scanFormat$55:	; £temporary1530 -> charPtr = *charPtr
200:		mov a1054, [bp + 11]
202:	

scanFormat$56:	; £temporary1530 -> charPtr = charValue
203:		mov a1055, [bp + 57]
204:		mov [a1054], a1055
206:	

scanFormat$57:	; percent = 0
207:		mov word [bp + 13], 0
209:	

scanFormat$58:	; £temporary1531 = int_to_int charValue (Signed_Char -> Signed_Int)
210:		mov a1056, [bp + 57]
212:		and a1056, 255
214:		cmp a1056, 0
215:		jge scanFormat$59
216:		neg a1056
218:		neg a1056
220:	

scanFormat$59:	; if £temporary1531 == -1 goto 323
221:		cmp a1056, -1
222:		je scanFormat$323
224:	

scanFormat$60:	; ++g_inCount
225:		inc word [g_inCount]
227:	

scanFormat$61:	; goto 323
228:		jmp scanFormat$323
230:	

scanFormat$62:	; if star != 0 goto 74
231:		cmp word [bp + 21], 0
232:		jne scanFormat$74
234:	

scanFormat$63:	; arg_list = arg_list + 2
235:		add word [bp + 8], 2
237:	

scanFormat$64:	; £temporary1537 = arg_list - 2
238:		mov a1057, [bp + 8]
239:		sub a1057, 2
241:	

scanFormat$65:	; £temporary1538 = int_to_int £temporary1537 (Signed_Int -> Pointer)
244:	

scanFormat$66:	; £temporary1539 -> £temporary1538 = *£temporary1538
246:	

scanFormat$67:	; charPtr = £temporary1539 -> £temporary1538
247:		mov t1058, [a1057]
248:		mov [bp + 11], t1058
250:	

scanFormat$68:	; call header integral zero 0 stack zero 0
252:	

scanFormat$69:	; parameter charPtr, offset 6
253:		mov a1059, [bp + 11]
254:		mov [bp + 63], a1059
256:	

scanFormat$70:	; parameter 0, offset 8
257:		mov word [bp + 65], 0
259:	

scanFormat$71:	; call function noellipse-noellipse scanString
260:		mov word [bp + 57], scanFormat$72
261:		mov [bp + 59], bp
262:		add bp, 57
263:		jmp scanString
265:	

scanFormat$72:	; post call
267:	

scanFormat$73:	; goto 79
268:		jmp scanFormat$79
270:	

scanFormat$74:	; call header integral zero 0 stack zero 0
272:	

scanFormat$75:	; parameter 0, offset 6
273:		mov word [bp + 63], 0
275:	

scanFormat$76:	; parameter 0, offset 8
276:		mov word [bp + 65], 0
278:	

scanFormat$77:	; call function noellipse-noellipse scanString
279:		mov word [bp + 57], scanFormat$78
280:		mov [bp + 59], bp
281:		add bp, 57
282:		jmp scanString
284:	

scanFormat$78:	; post call
286:	

scanFormat$79:	; percent = 0
287:		mov word [bp + 13], 0
289:	

scanFormat$80:	; goto 323
290:		jmp scanFormat$323
292:	

scanFormat$81:	; call header integral zero 0 stack zero 0
294:	

scanFormat$82:	; call function noellipse-noellipse scanLongInt
295:		mov word [bp + 57], scanFormat$83
296:		mov [bp + 59], bp
297:		add bp, 57
298:		jmp scanLongInt
300:	

scanFormat$83:	; post call
302:	

scanFormat$84:	; £temporary1542 = return_value
307:	

scanFormat$85:	; longValue = £temporary1542
308:		mov [bp + 23], t1061
310:	

scanFormat$86:	; if star != 0 goto 114
311:		cmp word [bp + 21], 0
312:		jne scanFormat$114
314:	

scanFormat$87:	; if shortInt == 0 goto 97
315:		cmp word [bp + 15], 0
316:		je scanFormat$97
318:	

scanFormat$88:	; arg_list = arg_list + 2
319:		add word [bp + 8], 2
321:	

scanFormat$89:	; £temporary1546 = arg_list - 2
322:		mov a1062, [bp + 8]
323:		sub a1062, 2
325:	

scanFormat$90:	; £temporary1547 = int_to_int £temporary1546 (Signed_Int -> Pointer)
328:	

scanFormat$91:	; £temporary1548 -> £temporary1547 = *£temporary1547
330:	

scanFormat$92:	; shortPtr = £temporary1548 -> £temporary1547
331:		mov t1063, [a1062]
332:		mov [bp + 29], t1063
334:	

scanFormat$93:	; £temporary1549 -> shortPtr = *shortPtr
335:		mov a1064, [bp + 29]
337:	

scanFormat$94:	; £temporary1550 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
338:		mov a1065, [bp + 23]
341:		cmp a1065, 0
342:		jge scanFormat$95
343:		neg a1065
345:		neg a1065
347:	

scanFormat$95:	; £temporary1549 -> shortPtr = £temporary1550
348:		mov [a1064], a1065
350:	

scanFormat$96:	; goto 114
351:		jmp scanFormat$114
353:	

scanFormat$97:	; if longIntOrDouble != 0 goto 107
354:		cmp word [bp + 17], 0
355:		jne scanFormat$107
357:	

scanFormat$98:	; arg_list = arg_list + 2
358:		add word [bp + 8], 2
360:	

scanFormat$99:	; £temporary1554 = arg_list - 2
361:		mov a1066, [bp + 8]
362:		sub a1066, 2
364:	

scanFormat$100:	; £temporary1555 = int_to_int £temporary1554 (Signed_Int -> Pointer)
367:	

scanFormat$101:	; £temporary1556 -> £temporary1555 = *£temporary1555
369:	

scanFormat$102:	; intPtr = £temporary1556 -> £temporary1555
370:		mov t1067, [a1066]
371:		mov [bp + 33], t1067
373:	

scanFormat$103:	; £temporary1557 -> intPtr = *intPtr
374:		mov a1068, [bp + 33]
376:	

scanFormat$104:	; £temporary1558 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
377:		mov a1069, [bp + 23]
380:		cmp a1069, 0
381:		jge scanFormat$105
382:		neg a1069
384:		neg a1069
386:	

scanFormat$105:	; £temporary1557 -> intPtr = £temporary1558
387:		mov [a1068], a1069
389:	

scanFormat$106:	; goto 114
390:		jmp scanFormat$114
392:	

scanFormat$107:	; arg_list = arg_list + 2
393:		add word [bp + 8], 2
395:	

scanFormat$108:	; £temporary1560 = arg_list - 2
396:		mov a1070, [bp + 8]
397:		sub a1070, 2
399:	

scanFormat$109:	; £temporary1561 = int_to_int £temporary1560 (Signed_Int -> Pointer)
402:	

scanFormat$110:	; £temporary1562 -> £temporary1561 = *£temporary1561
404:	

scanFormat$111:	; longPtr = £temporary1562 -> £temporary1561
405:		mov t1071, [a1070]
406:		mov [bp + 27], t1071
408:	

scanFormat$112:	; £temporary1563 -> longPtr = *longPtr
409:		mov a1072, [bp + 27]
411:	

scanFormat$113:	; £temporary1563 -> longPtr = longValue
412:		mov a1073, [bp + 23]
413:		mov [a1072], a1073
415:	

scanFormat$114:	; percent = 0
416:		mov word [bp + 13], 0
418:	

scanFormat$115:	; goto 323
419:		jmp scanFormat$323
421:	

scanFormat$116:	; call header integral zero 0 stack zero 0
423:	

scanFormat$117:	; parameter 8, offset 6
424:		mov dword [bp + 63], 8
426:	

scanFormat$118:	; call function noellipse-noellipse scanUnsignedLongInt
427:		mov word [bp + 57], scanFormat$119
428:		mov [bp + 59], bp
429:		add bp, 57
430:		jmp scanUnsignedLongInt
432:	

scanFormat$119:	; post call
434:	

scanFormat$120:	; £temporary1565 = return_value
439:	

scanFormat$121:	; unsignedLongValue = £temporary1565
440:		mov [bp + 37], t1075
442:	

scanFormat$122:	; if star != 0 goto 150
443:		cmp word [bp + 21], 0
444:		jne scanFormat$150
446:	

scanFormat$123:	; if shortInt == 0 goto 133
447:		cmp word [bp + 15], 0
448:		je scanFormat$133
450:	

scanFormat$124:	; arg_list = arg_list + 2
451:		add word [bp + 8], 2
453:	

scanFormat$125:	; £temporary1569 = arg_list - 2
454:		mov a1076, [bp + 8]
455:		sub a1076, 2
457:	

scanFormat$126:	; £temporary1570 = int_to_int £temporary1569 (Signed_Int -> Pointer)
460:	

scanFormat$127:	; £temporary1571 -> £temporary1570 = *£temporary1570
462:	

scanFormat$128:	; unsignedShortPtr = £temporary1571 -> £temporary1570
463:		mov t1077, [a1076]
464:		mov [bp + 43], t1077
466:	

scanFormat$129:	; £temporary1572 -> unsignedShortPtr = *unsignedShortPtr
467:		mov a1078, [bp + 43]
469:	

scanFormat$130:	; £temporary1573 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
470:		mov a1079, [bp + 37]
473:	

scanFormat$131:	; £temporary1572 -> unsignedShortPtr = £temporary1573
474:		mov [a1078], a1079
476:	

scanFormat$132:	; goto 150
477:		jmp scanFormat$150
479:	

scanFormat$133:	; if longIntOrDouble != 0 goto 143
480:		cmp word [bp + 17], 0
481:		jne scanFormat$143
483:	

scanFormat$134:	; arg_list = arg_list + 2
484:		add word [bp + 8], 2
486:	

scanFormat$135:	; £temporary1577 = arg_list - 2
487:		mov a1080, [bp + 8]
488:		sub a1080, 2
490:	

scanFormat$136:	; £temporary1578 = int_to_int £temporary1577 (Signed_Int -> Pointer)
493:	

scanFormat$137:	; £temporary1579 -> £temporary1578 = *£temporary1578
495:	

scanFormat$138:	; unsignedIntPtr = £temporary1579 -> £temporary1578
496:		mov t1081, [a1080]
497:		mov [bp + 45], t1081
499:	

scanFormat$139:	; £temporary1580 -> unsignedIntPtr = *unsignedIntPtr
500:		mov a1082, [bp + 45]
502:	

scanFormat$140:	; £temporary1581 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
503:		mov a1083, [bp + 37]
506:	

scanFormat$141:	; £temporary1580 -> unsignedIntPtr = £temporary1581
507:		mov [a1082], a1083
509:	

scanFormat$142:	; goto 150
510:		jmp scanFormat$150
512:	

scanFormat$143:	; arg_list = arg_list + 2
513:		add word [bp + 8], 2
515:	

scanFormat$144:	; £temporary1583 = arg_list - 2
516:		mov a1084, [bp + 8]
517:		sub a1084, 2
519:	

scanFormat$145:	; £temporary1584 = int_to_int £temporary1583 (Signed_Int -> Pointer)
522:	

scanFormat$146:	; £temporary1585 -> £temporary1584 = *£temporary1584
524:	

scanFormat$147:	; unsignedLongPtr = £temporary1585 -> £temporary1584
525:		mov t1085, [a1084]
526:		mov [bp + 41], t1085
528:	

scanFormat$148:	; £temporary1586 -> unsignedLongPtr = *unsignedLongPtr
529:		mov a1086, [bp + 41]
531:	

scanFormat$149:	; £temporary1586 -> unsignedLongPtr = unsignedLongValue
532:		mov a1087, [bp + 37]
533:		mov [a1086], a1087
535:	

scanFormat$150:	; percent = 0
536:		mov word [bp + 13], 0
538:	

scanFormat$151:	; goto 323
539:		jmp scanFormat$323
541:	

scanFormat$152:	; call header integral zero 0 stack zero 0
543:	

scanFormat$153:	; parameter 16, offset 6
544:		mov dword [bp + 63], 16
546:	

scanFormat$154:	; call function noellipse-noellipse scanUnsignedLongInt
547:		mov word [bp + 57], scanFormat$155
548:		mov [bp + 59], bp
549:		add bp, 57
550:		jmp scanUnsignedLongInt
552:	

scanFormat$155:	; post call
554:	

scanFormat$156:	; £temporary1588 = return_value
559:	

scanFormat$157:	; unsignedLongValue = £temporary1588
560:		mov [bp + 37], t1089
562:	

scanFormat$158:	; if star != 0 goto 186
563:		cmp word [bp + 21], 0
564:		jne scanFormat$186
566:	

scanFormat$159:	; if shortInt == 0 goto 169
567:		cmp word [bp + 15], 0
568:		je scanFormat$169
570:	

scanFormat$160:	; arg_list = arg_list + 2
571:		add word [bp + 8], 2
573:	

scanFormat$161:	; £temporary1592 = arg_list - 2
574:		mov a1090, [bp + 8]
575:		sub a1090, 2
577:	

scanFormat$162:	; £temporary1593 = int_to_int £temporary1592 (Signed_Int -> Pointer)
580:	

scanFormat$163:	; £temporary1594 -> £temporary1593 = *£temporary1593
582:	

scanFormat$164:	; unsignedShortPtr = £temporary1594 -> £temporary1593
583:		mov t1091, [a1090]
584:		mov [bp + 43], t1091
586:	

scanFormat$165:	; £temporary1595 -> unsignedShortPtr = *unsignedShortPtr
587:		mov a1092, [bp + 43]
589:	

scanFormat$166:	; £temporary1596 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
590:		mov a1093, [bp + 37]
593:	

scanFormat$167:	; £temporary1595 -> unsignedShortPtr = £temporary1596
594:		mov [a1092], a1093
596:	

scanFormat$168:	; goto 186
597:		jmp scanFormat$186
599:	

scanFormat$169:	; if longIntOrDouble != 0 goto 179
600:		cmp word [bp + 17], 0
601:		jne scanFormat$179
603:	

scanFormat$170:	; arg_list = arg_list + 2
604:		add word [bp + 8], 2
606:	

scanFormat$171:	; £temporary1600 = arg_list - 2
607:		mov a1094, [bp + 8]
608:		sub a1094, 2
610:	

scanFormat$172:	; £temporary1601 = int_to_int £temporary1600 (Signed_Int -> Pointer)
613:	

scanFormat$173:	; £temporary1602 -> £temporary1601 = *£temporary1601
615:	

scanFormat$174:	; unsignedIntPtr = £temporary1602 -> £temporary1601
616:		mov t1095, [a1094]
617:		mov [bp + 45], t1095
619:	

scanFormat$175:	; £temporary1603 -> unsignedIntPtr = *unsignedIntPtr
620:		mov a1096, [bp + 45]
622:	

scanFormat$176:	; £temporary1604 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
623:		mov a1097, [bp + 37]
626:	

scanFormat$177:	; £temporary1603 -> unsignedIntPtr = £temporary1604
627:		mov [a1096], a1097
629:	

scanFormat$178:	; goto 186
630:		jmp scanFormat$186
632:	

scanFormat$179:	; arg_list = arg_list + 2
633:		add word [bp + 8], 2
635:	

scanFormat$180:	; £temporary1606 = arg_list - 2
636:		mov a1098, [bp + 8]
637:		sub a1098, 2
639:	

scanFormat$181:	; £temporary1607 = int_to_int £temporary1606 (Signed_Int -> Pointer)
642:	

scanFormat$182:	; £temporary1608 -> £temporary1607 = *£temporary1607
644:	

scanFormat$183:	; unsignedLongPtr = £temporary1608 -> £temporary1607
645:		mov t1099, [a1098]
646:		mov [bp + 41], t1099
648:	

scanFormat$184:	; £temporary1609 -> unsignedLongPtr = *unsignedLongPtr
649:		mov a1100, [bp + 41]
651:	

scanFormat$185:	; £temporary1609 -> unsignedLongPtr = unsignedLongValue
652:		mov a1101, [bp + 37]
653:		mov [a1100], a1101
655:	

scanFormat$186:	; percent = 0
656:		mov word [bp + 13], 0
658:	

scanFormat$187:	; goto 323
659:		jmp scanFormat$323
661:	

scanFormat$188:	; call header integral zero 0 stack zero 0
663:	

scanFormat$189:	; parameter 0, offset 6
664:		mov dword [bp + 63], 0
666:	

scanFormat$190:	; call function noellipse-noellipse scanUnsignedLongInt
667:		mov word [bp + 57], scanFormat$191
668:		mov [bp + 59], bp
669:		add bp, 57
670:		jmp scanUnsignedLongInt
672:	

scanFormat$191:	; post call
674:	

scanFormat$192:	; £temporary1611 = return_value
679:	

scanFormat$193:	; unsignedLongValue = £temporary1611
680:		mov [bp + 37], t1103
682:	

scanFormat$194:	; if star != 0 goto 222
683:		cmp word [bp + 21], 0
684:		jne scanFormat$222
686:	

scanFormat$195:	; if shortInt == 0 goto 205
687:		cmp word [bp + 15], 0
688:		je scanFormat$205
690:	

scanFormat$196:	; arg_list = arg_list + 2
691:		add word [bp + 8], 2
693:	

scanFormat$197:	; £temporary1615 = arg_list - 2
694:		mov a1104, [bp + 8]
695:		sub a1104, 2
697:	

scanFormat$198:	; £temporary1616 = int_to_int £temporary1615 (Signed_Int -> Pointer)
700:	

scanFormat$199:	; £temporary1617 -> £temporary1616 = *£temporary1616
702:	

scanFormat$200:	; unsignedShortPtr = £temporary1617 -> £temporary1616
703:		mov t1105, [a1104]
704:		mov [bp + 43], t1105
706:	

scanFormat$201:	; £temporary1618 -> unsignedShortPtr = *unsignedShortPtr
707:		mov a1106, [bp + 43]
709:	

scanFormat$202:	; £temporary1619 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
710:		mov a1107, [bp + 37]
713:	

scanFormat$203:	; £temporary1618 -> unsignedShortPtr = £temporary1619
714:		mov [a1106], a1107
716:	

scanFormat$204:	; goto 222
717:		jmp scanFormat$222
719:	

scanFormat$205:	; if longIntOrDouble != 0 goto 215
720:		cmp word [bp + 17], 0
721:		jne scanFormat$215
723:	

scanFormat$206:	; arg_list = arg_list + 2
724:		add word [bp + 8], 2
726:	

scanFormat$207:	; £temporary1623 = arg_list - 2
727:		mov a1108, [bp + 8]
728:		sub a1108, 2
730:	

scanFormat$208:	; £temporary1624 = int_to_int £temporary1623 (Signed_Int -> Pointer)
733:	

scanFormat$209:	; £temporary1625 -> £temporary1624 = *£temporary1624
735:	

scanFormat$210:	; unsignedIntPtr = £temporary1625 -> £temporary1624
736:		mov t1109, [a1108]
737:		mov [bp + 45], t1109
739:	

scanFormat$211:	; £temporary1626 -> unsignedIntPtr = *unsignedIntPtr
740:		mov a1110, [bp + 45]
742:	

scanFormat$212:	; £temporary1627 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
743:		mov a1111, [bp + 37]
746:	

scanFormat$213:	; £temporary1626 -> unsignedIntPtr = £temporary1627
747:		mov [a1110], a1111
749:	

scanFormat$214:	; goto 222
750:		jmp scanFormat$222
752:	

scanFormat$215:	; arg_list = arg_list + 2
753:		add word [bp + 8], 2
755:	

scanFormat$216:	; £temporary1629 = arg_list - 2
756:		mov a1112, [bp + 8]
757:		sub a1112, 2
759:	

scanFormat$217:	; £temporary1630 = int_to_int £temporary1629 (Signed_Int -> Pointer)
762:	

scanFormat$218:	; £temporary1631 -> £temporary1630 = *£temporary1630
764:	

scanFormat$219:	; unsignedLongPtr = £temporary1631 -> £temporary1630
765:		mov t1113, [a1112]
766:		mov [bp + 41], t1113
768:	

scanFormat$220:	; £temporary1632 -> unsignedLongPtr = *unsignedLongPtr
769:		mov a1114, [bp + 41]
771:	

scanFormat$221:	; £temporary1632 -> unsignedLongPtr = unsignedLongValue
772:		mov a1115, [bp + 37]
773:		mov [a1114], a1115
775:	

scanFormat$222:	; percent = 0
776:		mov word [bp + 13], 0
778:	

scanFormat$223:	; goto 323
779:		jmp scanFormat$323
781:	

scanFormat$224:	; call header integral zero 0 stack zero 0
783:	

scanFormat$225:	; call function noellipse-noellipse scanLongDouble
784:		mov word [bp + 57], scanFormat$226
785:		mov [bp + 59], bp
786:		add bp, 57
787:		jmp scanLongDouble
789:	

scanFormat$226:	; post call
791:	

scanFormat$227:	; £temporary1634 = return_value
793:	

scanFormat$228:	; pop float longDoubleValue
794:		fstp qword [bp + 47]
796:	

scanFormat$229:	; if star != 0 goto 258
797:		cmp word [bp + 21], 0
798:		jne scanFormat$258
800:	

scanFormat$230:	; if longIntOrDouble == 0 goto 240
801:		cmp word [bp + 17], 0
802:		je scanFormat$240
804:	

scanFormat$231:	; arg_list = arg_list + 2
805:		add word [bp + 8], 2
807:	

scanFormat$232:	; £temporary1638 = arg_list - 2
808:		mov a1116, [bp + 8]
809:		sub a1116, 2
811:	

scanFormat$233:	; £temporary1639 = int_to_int £temporary1638 (Signed_Int -> Pointer)
814:	

scanFormat$234:	; £temporary1640 -> £temporary1639 = *£temporary1639
816:	

scanFormat$235:	; doublePtr = £temporary1640 -> £temporary1639
817:		mov t1117, [a1116]
818:		mov [bp + 57], t1117
820:	

scanFormat$236:	; £temporary1641 -> doublePtr = *doublePtr
821:		mov a1118, [bp + 57]
823:	

scanFormat$237:	; push float longDoubleValue
824:		fld qword [bp + 47]
826:	

scanFormat$238:	; pop float £temporary1641 -> doublePtr
827:		fstp qword [a1118]
829:	

scanFormat$239:	; goto 258
830:		jmp scanFormat$258
832:	

scanFormat$240:	; if longDouble == 0 goto 250
833:		cmp word [bp + 19], 0
834:		je scanFormat$250
836:	

scanFormat$241:	; arg_list = arg_list + 2
837:		add word [bp + 8], 2
839:	

scanFormat$242:	; £temporary1644 = arg_list - 2
840:		mov a1119, [bp + 8]
841:		sub a1119, 2
843:	

scanFormat$243:	; £temporary1645 = int_to_int £temporary1644 (Signed_Int -> Pointer)
846:	

scanFormat$244:	; £temporary1646 -> £temporary1645 = *£temporary1645
848:	

scanFormat$245:	; longDoublePtr = £temporary1646 -> £temporary1645
849:		mov t1120, [a1119]
850:		mov [bp + 57], t1120
852:	

scanFormat$246:	; £temporary1647 -> longDoublePtr = *longDoublePtr
853:		mov a1121, [bp + 57]
855:	

scanFormat$247:	; push float longDoubleValue
856:		fld qword [bp + 47]
858:	

scanFormat$248:	; pop float £temporary1647 -> longDoublePtr
859:		fstp qword [a1121]
861:	

scanFormat$249:	; goto 258
862:		jmp scanFormat$258
864:	

scanFormat$250:	; arg_list = arg_list + 2
865:		add word [bp + 8], 2
867:	

scanFormat$251:	; £temporary1649 = arg_list - 2
868:		mov a1122, [bp + 8]
869:		sub a1122, 2
871:	

scanFormat$252:	; £temporary1650 = int_to_int £temporary1649 (Signed_Int -> Pointer)
874:	

scanFormat$253:	; £temporary1651 -> £temporary1650 = *£temporary1650
876:	

scanFormat$254:	; floatPtr = £temporary1651 -> £temporary1650
877:		mov t1123, [a1122]
878:		mov [bp + 57], t1123
880:	

scanFormat$255:	; £temporary1652 -> floatPtr = *floatPtr
881:		mov a1124, [bp + 57]
883:	

scanFormat$256:	; push float longDoubleValue
884:		fld qword [bp + 47]
886:	

scanFormat$257:	; pop float £temporary1652 -> floatPtr
887:		fstp dword [a1124]
889:	

scanFormat$258:	; percent = 0
890:		mov word [bp + 13], 0
892:	

scanFormat$259:	; goto 323
893:		jmp scanFormat$323
895:	

scanFormat$260:	; not = 0
896:		mov word [bp + 57], 0
898:	

scanFormat$261:	; ++index
899:		inc word [bp + 31]
901:	

scanFormat$262:	; £temporary1658 = format + index
902:		mov a1125, [bp + 6]
903:		add a1125, [bp + 31]
905:	

scanFormat$263:	; £temporary1657 -> £temporary1658 = *£temporary1658
907:	

scanFormat$264:	; if £temporary1657 -> £temporary1658 != 94 goto 267
908:		cmp byte [a1125], 94
909:		jne scanFormat$267
911:	

scanFormat$265:	; not = 1
912:		mov word [bp + 57], 1
914:	

scanFormat$266:	; startIndex = index + 1
915:		mov a1126, [bp + 31]
916:		add a1126, 1
917:		mov [bp + 59], a1126
919:	

scanFormat$267:	; £temporary1662 = format + index
920:		mov a1127, [bp + 6]
921:		add a1127, [bp + 31]
923:	

scanFormat$268:	; £temporary1661 -> £temporary1662 = *£temporary1662
925:	

scanFormat$269:	; if £temporary1661 -> £temporary1662 == 93 goto 272
926:		cmp byte [a1127], 93
927:		je scanFormat$272
929:	

scanFormat$270:	; ++index
930:		inc word [bp + 31]
932:	

scanFormat$271:	; goto 267
933:		jmp scanFormat$267
935:	

scanFormat$272:	; £temporary1666 = format + index
936:		mov a1128, [bp + 6]
937:		add a1128, [bp + 31]
939:	

scanFormat$273:	; £temporary1665 -> £temporary1666 = *£temporary1666
941:	

scanFormat$274:	; £temporary1665 -> £temporary1666 = 0
942:		mov byte [a1128], 0
944:	

scanFormat$275:	; if star != 0 goto 291
945:		cmp word [bp + 21], 0
946:		jne scanFormat$291
948:	

scanFormat$276:	; arg_list = arg_list + 2
949:		add word [bp + 8], 2
951:	

scanFormat$277:	; £temporary1670 = arg_list - 2
952:		mov a1129, [bp + 8]
953:		sub a1129, 2
955:	

scanFormat$278:	; £temporary1671 = int_to_int £temporary1670 (Signed_Int -> Pointer)
958:	

scanFormat$279:	; £temporary1672 -> £temporary1671 = *£temporary1671
960:	

scanFormat$280:	; string = £temporary1672 -> £temporary1671
961:		mov t1130, [a1129]
962:		mov [bp + 61], t1130
964:	

scanFormat$281:	; call header integral zero 0 stack zero 0
966:	

scanFormat$282:	; parameter string, offset 6
967:		mov a1131, [bp + 61]
968:		mov [bp + 69], a1131
970:	

scanFormat$283:	; £temporary1674 = format + startIndex
971:		mov a1132, [bp + 6]
972:		add a1132, [bp + 59]
974:	

scanFormat$284:	; £temporary1673 -> £temporary1674 = *£temporary1674
976:	

scanFormat$285:	; £temporary1675 = &£temporary1673 -> £temporary1674
978:	

scanFormat$286:	; parameter £temporary1675, offset 8
979:		mov [bp + 71], a1132
981:	

scanFormat$287:	; parameter not, offset 10
982:		mov a1133, [bp + 57]
983:		mov [bp + 73], a1133
985:	

scanFormat$288:	; call function noellipse-noellipse scanPattern
986:		mov word [bp + 63], scanFormat$289
987:		mov [bp + 65], bp
988:		add bp, 63
989:		jmp scanPattern
991:	

scanFormat$289:	; post call
993:	

scanFormat$290:	; goto 323
994:		jmp scanFormat$323
996:	

scanFormat$291:	; call header integral zero 0 stack zero 0
998:	

scanFormat$292:	; parameter 0, offset 6
999:		mov word [bp + 67], 0
1001:	

scanFormat$293:	; £temporary1678 = format + startIndex
1002:		mov a1134, [bp + 6]
1003:		add a1134, [bp + 59]
1005:	

scanFormat$294:	; £temporary1677 -> £temporary1678 = *£temporary1678
1007:	

scanFormat$295:	; £temporary1679 = &£temporary1677 -> £temporary1678
1009:	

scanFormat$296:	; parameter £temporary1679, offset 8
1010:		mov [bp + 69], a1134
1012:	

scanFormat$297:	; parameter not, offset 10
1013:		mov a1135, [bp + 57]
1014:		mov [bp + 71], a1135
1016:	

scanFormat$298:	; call function noellipse-noellipse scanPattern
1017:		mov word [bp + 61], scanFormat$299
1018:		mov [bp + 63], bp
1019:		add bp, 61
1020:		jmp scanPattern
1022:	

scanFormat$299:	; post call
1024:	

scanFormat$300:	; goto 323
1025:		jmp scanFormat$323
1027:	

scanFormat$301:	; arg_list = arg_list + 2
1028:		add word [bp + 8], 2
1030:	

scanFormat$302:	; £temporary1682 = arg_list - 2
1031:		mov a1136, [bp + 8]
1032:		sub a1136, 2
1034:	

scanFormat$303:	; £temporary1683 = int_to_int £temporary1682 (Signed_Int -> Pointer)
1037:	

scanFormat$304:	; £temporary1684 -> £temporary1683 = *£temporary1683
1039:	

scanFormat$305:	; charsPtr = £temporary1684 -> £temporary1683
1040:		mov t1137, [a1136]
1041:		mov [bp + 35], t1137
1043:	

scanFormat$306:	; £temporary1685 -> charsPtr = *charsPtr
1044:		mov a1138, [bp + 35]
1046:	

scanFormat$307:	; £temporary1685 -> charsPtr = g_inChars
1047:		mov a1139, [g_inChars]
1048:		mov [a1138], a1139
1050:	

scanFormat$308:	; percent = 0
1051:		mov word [bp + 13], 0
1053:	

scanFormat$309:	; goto 323
1054:		jmp scanFormat$323
1056:	

scanFormat$310:	; call header integral zero 0 stack zero 0
1058:	

scanFormat$311:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1059:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1061:	

scanFormat$312:	; £temporary1686 = int_to_int c (Signed_Char -> Signed_Int)
1062:		mov a1140, [bp + 10]
1064:		and a1140, 255
1066:		cmp a1140, 0
1067:		jge scanFormat$313
1068:		neg a1140
1070:		neg a1140
1072:	

scanFormat$313:	; parameter £temporary1686, offset 8
1073:		mov [bp + 65], a1140
1075:	

scanFormat$314:	; call function noellipse-ellipse printf, extra 0
1076:		mov word [bp + 57], scanFormat$315
1077:		mov [bp + 59], bp
1078:		add bp, 57
1079:		mov di, bp
1080:		add di, 2
1081:		jmp printf
1083:	

scanFormat$315:	; post call
1085:	

scanFormat$316:	; goto 323
1086:		jmp scanFormat$323
1088:	

scanFormat$317:	; if c != 37 goto 323
1089:		cmp byte [bp + 10], 37
1090:		jne scanFormat$323
1092:	

scanFormat$318:	; percent = 1
1093:		mov word [bp + 13], 1
1095:	

scanFormat$319:	; shortInt = 0
1096:		mov word [bp + 15], 0
1098:	

scanFormat$320:	; longIntOrDouble = 0
1099:		mov word [bp + 17], 0
1101:	

scanFormat$321:	; longDouble = 0
1102:		mov word [bp + 19], 0
1104:	

scanFormat$322:	; star = 0
1105:		mov word [bp + 21], 0
1107:	

scanFormat$323:	; ++index
1108:		inc word [bp + 31]
1110:	

scanFormat$324:	; goto 8
1111:		jmp scanFormat$8
1113:	

scanFormat$325:	; return_value = g_inCount
1114:		mov a1141, [g_inCount]
1116:	

scanFormat$326:	; return
1117:		mov t1142, [bp]
1118:		mov di, [bp + 4]
1119:		mov bp, [bp + 2]
1120:		jmp t1142
1122:	

scanFormat$327:	; function end scanFormat
1:	

scanf:	; £temporary1705 = &format
2:		mov t1143, bp
3:		add t1143, 6
5:	

scanf$1:	; £temporary1706 = int_to_int £temporary1705 (Pointer -> Pointer)
8:	

scanf$2:	; arg_list = £temporary1706 + 2
9:		add t1143, 2
10:		mov [di + 8], t1143
12:	

scanf$3:	; call header integral zero 0 stack zero 0
14:	

scanf$4:	; parameter format, offset 6
15:		mov a1144, [bp + 6]
16:		mov [di + 16], a1144
18:	

scanf$5:	; parameter arg_list, offset 8
19:		mov a1145, [di + 8]
20:		mov [di + 18], a1145
22:	

scanf$6:	; call function ellipse-noellipse vscanf
23:		mov word [di + 10], scanf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vscanf
30:	

scanf$7:	; post call
32:	

scanf$8:	; £temporary1708 = return_value
37:	

scanf$9:	; return_value = £temporary1708
39:	

scanf$10:	; return
40:		mov t1148, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t1148
45:	

scanf$11:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov a1149, [stdin]
5:		mov [bp + 16], a1149
7:	

vscanf$2:	; parameter format, offset 8
8:		mov a1150, [bp + 6]
9:		mov [bp + 18], a1150
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov a1151, [bp + 8]
13:		mov [bp + 20], a1151
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1712 = return_value
28:	

vscanf$7:	; return_value = £temporary1712
30:	

vscanf$8:	; return
31:		mov t1154, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp t1154
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1716 = &format
2:		mov t1155, bp
3:		add t1155, 8
5:	

fscanf$1:	; £temporary1717 = int_to_int £temporary1716 (Pointer -> Pointer)
8:	

fscanf$2:	; arg_list = £temporary1717 + 2
9:		add t1155, 2
10:		mov [di + 10], t1155
12:	

fscanf$3:	; call header integral zero 0 stack zero 0
14:	

fscanf$4:	; parameter inStream, offset 6
15:		mov a1156, [bp + 6]
16:		mov [di + 18], a1156
18:	

fscanf$5:	; parameter format, offset 8
19:		mov a1157, [bp + 8]
20:		mov [di + 20], a1157
22:	

fscanf$6:	; parameter arg_list, offset 10
23:		mov a1158, [di + 10]
24:		mov [di + 22], a1158
26:	

fscanf$7:	; call function ellipse-noellipse vfscanf
27:		mov word [di + 12], fscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfscanf
34:	

fscanf$8:	; post call
36:	

fscanf$9:	; £temporary1719 = return_value
41:	

fscanf$10:	; return_value = £temporary1719
43:	

fscanf$11:	; return
44:		mov t1161, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1161
49:	

fscanf$12:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1724 = int_to_int inStream (Pointer -> Pointer)
5:		mov a1162, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1724
9:		mov [g_inDevice], a1162
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov a1163, [bp + 8]
15:		mov [bp + 18], a1163
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov a1164, [bp + 10]
19:		mov [bp + 20], a1164
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1725 = return_value
34:	

vfscanf$9:	; return_value = £temporary1725
36:	

vfscanf$10:	; return
37:		mov t1167, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1167
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1728 = &format
2:		mov t1168, bp
3:		add t1168, 8
5:	

sscanf$1:	; £temporary1729 = int_to_int £temporary1728 (Pointer -> Pointer)
8:	

sscanf$2:	; arg_list = £temporary1729 + 2
9:		add t1168, 2
10:		mov [di + 10], t1168
12:	

sscanf$3:	; call header integral zero 0 stack zero 0
14:	

sscanf$4:	; parameter inString, offset 6
15:		mov a1169, [bp + 6]
16:		mov [di + 18], a1169
18:	

sscanf$5:	; parameter format, offset 8
19:		mov a1170, [bp + 8]
20:		mov [di + 20], a1170
22:	

sscanf$6:	; parameter arg_list, offset 10
23:		mov a1171, [di + 10]
24:		mov [di + 22], a1171
26:	

sscanf$7:	; call function ellipse-noellipse vsscanf
27:		mov word [di + 12], sscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsscanf
34:	

sscanf$8:	; post call
36:	

sscanf$9:	; £temporary1731 = return_value
41:	

sscanf$10:	; return_value = £temporary1731
43:	

sscanf$11:	; return
44:		mov t1174, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1174
49:	

sscanf$12:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1736 = int_to_int inString (Pointer -> Pointer)
5:		mov a1175, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1736
9:		mov [g_inDevice], a1175
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov a1176, [bp + 8]
15:		mov [bp + 18], a1176
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov a1177, [bp + 10]
19:		mov [bp + 20], a1177
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1737 = return_value
34:	

vsscanf$9:	; return_value = £temporary1737
36:	

vsscanf$10:	; return
37:		mov t1180, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1180
42:	

vsscanf$11:	; function end vsscanf
