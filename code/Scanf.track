1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov a834, [g_inStatus]
6:		cmp a834, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp a834, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1235 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov a835, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1235
23:		mov [bp + 7], a835
25:	

scanChar$7:	; £temporary1236 -> stream = *stream, offset 2
26:		mov a836, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1236 -> stream
29:		mov t837, [a836 + 2]
30:		mov [bp + 9], t837
32:	

scanChar$9:	; ah = 63
33:		mov a838, 63
35:	

scanChar$10:	; bx = handle
36:		mov a839, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov a840, 1
41:	

scanChar$12:	; £temporary1241 = &c
42:		mov t841, bp
43:		add t841, 6
45:	

scanChar$13:	; dx = £temporary1241
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov a842, [bp + 6]
56:	

scanChar$17:	; return
57:		mov t843, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp t843
62:	

scanChar$18:	; £temporary1243 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov a844, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1243
67:		mov [bp + 11], a844
69:	

scanChar$20:	; £temporary1244 = g_inChars
70:		mov t845, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1246 = inString + £temporary1244
76:		mov a846, [bp + 11]
77:		add a846, t845
79:	

scanChar$23:	; £temporary1245 -> £temporary1246 = *£temporary1246
81:	

scanChar$24:	; return_value = £temporary1245 -> £temporary1246
82:		mov t847, [a846]
84:	

scanChar$25:	; return
85:		mov t848, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp t848
90:	

scanChar$26:	; return_value = 0
91:		mov a849, 0
93:	

scanChar$27:	; return
94:		mov t850, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp t850
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov a851, [g_inStatus]
3:		cmp a851, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp a851, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov t852, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp t852
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1250 = return_value
19:	

scanPattern$5:	; input = £temporary1250
20:		mov [bp + 14], t854
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1251 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov a855, [bp + 14]
27:		and a855, 255
29:		cmp a855, 0
30:		jge scanPattern$8
31:		neg a855
33:		neg a855
35:	

scanPattern$8:	; parameter £temporary1251, offset 6
36:		mov [bp + 21], a855
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1252 = return_value
51:	

scanPattern$12:	; if £temporary1252 == 0 goto 19
52:		cmp t857, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1253 = return_value
70:	

scanPattern$17:	; input = £temporary1253
71:		mov [bp + 14], t859
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov a860, [bp + 8]
88:		mov [bp + 21], a860
90:	

scanPattern$23:	; £temporary1258 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov a861, [bp + 14]
93:		and a861, 255
95:		cmp a861, 0
96:		jge scanPattern$24
97:		neg a861
99:		neg a861
101:	

scanPattern$24:	; parameter £temporary1258, offset 8
102:		mov [bp + 23], a861
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1259 = return_value
117:	

scanPattern$28:	; if £temporary1259 != 0 goto 38
118:		cmp t863, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov a864, [bp + 8]
129:		mov [bp + 21], a864
131:	

scanPattern$32:	; £temporary1262 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov a865, [bp + 14]
134:		and a865, 255
136:		cmp a865, 0
137:		jge scanPattern$33
138:		neg a865
140:		neg a865
142:	

scanPattern$33:	; parameter £temporary1262, offset 8
143:		mov [bp + 23], a865
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1263 = return_value
158:	

scanPattern$37:	; if £temporary1263 != 0 goto 49
159:		cmp t867, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1269 = index
163:		mov t868, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1271 = string + £temporary1269
169:		mov a869, [bp + 6]
170:		add a869, t868
172:	

scanPattern$41:	; £temporary1270 -> £temporary1271 = *£temporary1271
174:	

scanPattern$42:	; £temporary1270 -> £temporary1271 = input
175:		mov a870, [bp + 14]
176:		mov [a869], a870
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1272 = return_value
193:	

scanPattern$47:	; input = £temporary1272
194:		mov [bp + 14], t872
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1274 = string + index
200:		mov a873, [bp + 6]
201:		add a873, [bp + 12]
203:	

scanPattern$50:	; £temporary1273 -> £temporary1274 = *£temporary1274
205:	

scanPattern$51:	; £temporary1273 -> £temporary1274 = 0
206:		mov byte [a873], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov a874, [bp + 8]
219:		mov [bp + 21], a874
221:	

scanPattern$56:	; £temporary1277 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov a875, [bp + 14]
224:		and a875, 255
226:		cmp a875, 0
227:		jge scanPattern$57
228:		neg a875
230:		neg a875
232:	

scanPattern$57:	; parameter £temporary1277, offset 8
233:		mov [bp + 23], a875
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1278 = return_value
248:	

scanPattern$61:	; if £temporary1278 != 0 goto 71
249:		cmp t877, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov a878, [bp + 8]
260:		mov [bp + 21], a878
262:	

scanPattern$65:	; £temporary1281 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov a879, [bp + 14]
265:		and a879, 255
267:		cmp a879, 0
268:		jge scanPattern$66
269:		neg a879
271:		neg a879
273:	

scanPattern$66:	; parameter £temporary1281, offset 8
274:		mov [bp + 23], a879
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1282 = return_value
289:	

scanPattern$70:	; if £temporary1282 != 0 goto 77
290:		cmp t881, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1288 = return_value
308:	

scanPattern$75:	; input = £temporary1288
309:		mov [bp + 14], t883
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov t884, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp t884
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1298 = return_value
19:	

scanString$5:	; input = £temporary1298
20:		mov [bp + 12], t886
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1299 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a887, [bp + 12]
30:		and a887, 255
32:		cmp a887, 0
33:		jge scanString$9
34:		neg a887
36:		neg a887
38:	

scanString$9:	; parameter £temporary1299, offset 6
39:		mov [bp + 21], a887
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1300 = return_value
54:	

scanString$13:	; if £temporary1300 == 0 goto 20
55:		cmp t889, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1301 = return_value
73:	

scanString$18:	; input = £temporary1301
74:		mov [bp + 12], t891
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1305 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov a892, [bp + 12]
92:		and a892, 255
94:		cmp a892, 0
95:		jge scanString$24
96:		neg a892
98:		neg a892
100:	

scanString$24:	; parameter £temporary1305, offset 6
101:		mov [bp + 21], a892
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1306 = return_value
116:	

scanString$28:	; if £temporary1306 != 0 goto 45
117:		cmp t894, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1309 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov a895, [bp + 12]
123:		and a895, 255
125:		cmp a895, 0
126:		jge scanString$30
127:		neg a895
129:		neg a895
131:	

scanString$30:	; if £temporary1309 == -1 goto 45
132:		cmp a895, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1314 = index
140:		mov t896, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1316 = string + £temporary1314
146:		mov a897, [bp + 6]
147:		add a897, t896
149:	

scanString$35:	; £temporary1315 -> £temporary1316 = *£temporary1316
151:	

scanString$36:	; £temporary1315 -> £temporary1316 = input
152:		mov a898, [bp + 12]
153:		mov [a897], a898
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1317 = return_value
170:	

scanString$41:	; input = £temporary1317
171:		mov [bp + 12], t900
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1320 = string + index
183:		mov a901, [bp + 6]
184:		add a901, [bp + 10]
186:	

scanString$46:	; £temporary1319 -> £temporary1320 = *£temporary1320
188:	

scanString$47:	; £temporary1319 -> £temporary1320 = 0
189:		mov byte [a901], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1322 = precision
198:		mov t902, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1322 <= 0 goto 76
204:		cmp t902, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1324 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov a903, [bp + 12]
212:		and a903, 255
214:		cmp a903, 0
215:		jge scanString$55
216:		neg a903
218:		neg a903
220:	

scanString$55:	; parameter £temporary1324, offset 6
221:		mov [bp + 21], a903
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1325 = return_value
236:	

scanString$59:	; if £temporary1325 != 0 goto 76
237:		cmp t905, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1328 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov a906, [bp + 12]
243:		and a906, 255
245:		cmp a906, 0
246:		jge scanString$61
247:		neg a906
249:		neg a906
251:	

scanString$61:	; if £temporary1328 == -1 goto 76
252:		cmp a906, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1334 = index
260:		mov t907, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1336 = string + £temporary1334
266:		mov a908, [bp + 6]
267:		add a908, t907
269:	

scanString$66:	; £temporary1335 -> £temporary1336 = *£temporary1336
271:	

scanString$67:	; £temporary1335 -> £temporary1336 = input
272:		mov a909, [bp + 12]
273:		mov [a908], a909
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1337 = return_value
290:	

scanString$72:	; input = £temporary1337
291:		mov [bp + 12], t911
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1341 = string + index
307:		mov a912, [bp + 6]
308:		add a912, [bp + 10]
310:	

scanString$78:	; £temporary1340 -> £temporary1341 = *£temporary1341
312:	

scanString$79:	; £temporary1340 -> £temporary1341 = 0
313:		mov byte [a912], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1344 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov a913, [bp + 12]
330:		and a913, 255
332:		cmp a913, 0
333:		jge scanString$85
334:		neg a913
336:		neg a913
338:	

scanString$85:	; parameter £temporary1344, offset 6
339:		mov [bp + 21], a913
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1345 = return_value
354:	

scanString$89:	; if £temporary1345 != 0 goto 101
355:		cmp t915, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1348 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov a916, [bp + 12]
361:		and a916, 255
363:		cmp a916, 0
364:		jge scanString$91
365:		neg a916
367:		neg a916
369:	

scanString$91:	; if £temporary1348 == -1 goto 101
370:		cmp a916, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1353 = return_value
392:	

scanString$97:	; input = £temporary1353
393:		mov [bp + 12], t918
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1356 = precision
411:		mov t919, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1356 <= 0 goto 124
417:		cmp t919, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1358 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov a920, [bp + 12]
425:		and a920, 255
427:		cmp a920, 0
428:		jge scanString$108
429:		neg a920
431:		neg a920
433:	

scanString$108:	; parameter £temporary1358, offset 6
434:		mov [bp + 21], a920
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1359 = return_value
449:	

scanString$112:	; if £temporary1359 != 0 goto 124
450:		cmp t922, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1362 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov a923, [bp + 12]
456:		and a923, 255
458:		cmp a923, 0
459:		jge scanString$114
460:		neg a923
462:		neg a923
464:	

scanString$114:	; if £temporary1362 == -1 goto 124
465:		cmp a923, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1368 = return_value
487:	

scanString$120:	; input = £temporary1368
488:		mov [bp + 12], t925
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov t926, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp t926
519:	

scanString$129:	; function end scanString
1:	

digitToValue:	; call header integral zero 0 stack zero 0
3:	

digitToValue$1:	; £temporary1379 = int_to_int input (Signed_Char -> Signed_Int)
4:		mov a927, [bp + 6]
6:		and a927, 255
8:		cmp a927, 0
9:		jge digitToValue$2
10:		neg a927
12:		neg a927
14:	

digitToValue$2:	; parameter £temporary1379, offset 6
15:		mov [bp + 13], a927
17:	

digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

digitToValue$4:	; post call
25:	

digitToValue$5:	; £temporary1380 = return_value
30:	

digitToValue$6:	; if £temporary1380 == 0 goto 11
31:		cmp t929, 0
32:		je digitToValue$11
34:	

digitToValue$7:	; £temporary1381 = input - 48
35:		mov a930, [bp + 6]
36:		sub a930, 48
38:	

digitToValue$8:	; £temporary1382 = int_to_int £temporary1381 (Signed_Char -> Unsigned_Long_Int)
40:		and a930, 255
42:	

digitToValue$9:	; return_value = £temporary1382
44:	

digitToValue$10:	; return
45:		mov t931, [bp]
46:		mov di, [bp + 4]
47:		mov bp, [bp + 2]
48:		jmp t931
50:	

digitToValue$11:	; call header integral zero 0 stack zero 0
52:	

digitToValue$12:	; £temporary1383 = int_to_int input (Signed_Char -> Signed_Int)
53:		mov a932, [bp + 6]
55:		and a932, 255
57:		cmp a932, 0
58:		jge digitToValue$13
59:		neg a932
61:		neg a932
63:	

digitToValue$13:	; parameter £temporary1383, offset 6
64:		mov [bp + 13], a932
66:	

digitToValue$14:	; call function noellipse-noellipse islower
67:		mov word [bp + 7], digitToValue$15
68:		mov [bp + 9], bp
69:		add bp, 7
70:		jmp islower
72:	

digitToValue$15:	; post call
74:	

digitToValue$16:	; £temporary1384 = return_value
79:	

digitToValue$17:	; if £temporary1384 == 0 goto 23
80:		cmp t934, 0
81:		je digitToValue$23
83:	

digitToValue$18:	; £temporary1385 = input - 97
84:		mov a935, [bp + 6]
85:		sub a935, 97
87:	

digitToValue$19:	; £temporary1386 = int_to_int £temporary1385 (Signed_Char -> Unsigned_Long_Int)
89:		and a935, 255
91:	

digitToValue$20:	; £temporary1387 = £temporary1386 + 10
92:		add a935, 10
94:	

digitToValue$21:	; return_value = £temporary1387
96:	

digitToValue$22:	; return
97:		mov t936, [bp]
98:		mov di, [bp + 4]
99:		mov bp, [bp + 2]
100:		jmp t936
102:	

digitToValue$23:	; £temporary1388 = input - 65
103:		mov a937, [bp + 6]
104:		sub a937, 65
106:	

digitToValue$24:	; £temporary1389 = int_to_int £temporary1388 (Signed_Char -> Unsigned_Long_Int)
108:		and a937, 255
110:	

digitToValue$25:	; £temporary1390 = £temporary1389 + 10
111:		add a937, 10
113:	

digitToValue$26:	; return_value = £temporary1390
115:	

digitToValue$27:	; return
116:		mov t938, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp t938
121:	

digitToValue$28:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 6], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 10], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 12], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 14], scanLongInt$5
14:		mov [bp + 16], bp
15:		add bp, 14
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1395 = return_value
25:	

scanLongInt$7:	; input = £temporary1395
26:		mov [bp + 14], t940
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1396 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov a941, [bp + 14]
33:		and a941, 255
35:		cmp a941, 0
36:		jge scanLongInt$10
37:		neg a941
39:		neg a941
41:	

scanLongInt$10:	; parameter £temporary1396, offset 6
42:		mov [bp + 21], a941
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 15], scanLongInt$12
46:		mov [bp + 17], bp
47:		add bp, 15
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1397 = return_value
57:	

scanLongInt$14:	; if £temporary1397 == 0 goto 21
58:		cmp t943, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 15], scanLongInt$17
65:		mov [bp + 17], bp
66:		add bp, 15
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1398 = return_value
76:	

scanLongInt$19:	; input = £temporary1398
77:		mov [bp + 14], t945
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 14], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 15], scanLongInt$24
90:		mov [bp + 17], bp
91:		add bp, 15
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1401 = return_value
101:	

scanLongInt$26:	; input = £temporary1401
102:		mov [bp + 14], t947
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 14], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 10], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 15], scanLongInt$32
118:		mov [bp + 17], bp
119:		add bp, 15
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1403 = return_value
129:	

scanLongInt$34:	; input = £temporary1403
130:		mov [bp + 14], t949
132:	

scanLongInt$35:	; call header integral zero 0 stack zero 0
134:	

scanLongInt$36:	; £temporary1404 = int_to_int input (Signed_Char -> Signed_Int)
135:		mov a950, [bp + 14]
137:		and a950, 255
139:		cmp a950, 0
140:		jge scanLongInt$37
141:		neg a950
143:		neg a950
145:	

scanLongInt$37:	; parameter £temporary1404, offset 6
146:		mov [bp + 21], a950
148:	

scanLongInt$38:	; call function noellipse-noellipse isdigit
149:		mov word [bp + 15], scanLongInt$39
150:		mov [bp + 17], bp
151:		add bp, 15
152:		jmp isdigit
154:	

scanLongInt$39:	; post call
156:	

scanLongInt$40:	; £temporary1405 = return_value
161:	

scanLongInt$41:	; if £temporary1405 == 0 goto 53
162:		cmp t952, 0
163:		je scanLongInt$53
165:	

scanLongInt$42:	; £temporary1406 = longValue * 10
166:		mov a953, [bp + 6]
168:		xor edx, edx
169:		imul dword [int4$10#]
175:	

scanLongInt$43:	; £temporary1407 = input - 48
176:		mov a957, [bp + 14]
177:		sub a957, 48
179:	

scanLongInt$44:	; £temporary1408 = int_to_int £temporary1407 (Signed_Char -> Signed_Long_Int)
181:		and a957, 255
183:		cmp a957, 0
184:		jge scanLongInt$45
185:		neg a957
187:		neg a957
189:	

scanLongInt$45:	; longValue = £temporary1406 + £temporary1408
190:		add t956, a957
191:		mov [bp + 6], t956
193:	

scanLongInt$46:	; call header integral zero 0 stack zero 0
195:	

scanLongInt$47:	; call function noellipse-noellipse scanChar
196:		mov word [bp + 15], scanLongInt$48
197:		mov [bp + 17], bp
198:		add bp, 15
199:		jmp scanChar
201:	

scanLongInt$48:	; post call
203:	

scanLongInt$49:	; £temporary1410 = return_value
208:	

scanLongInt$50:	; input = £temporary1410
209:		mov [bp + 14], t959
211:	

scanLongInt$51:	; found = 1
212:		mov word [bp + 12], 1
214:	

scanLongInt$52:	; goto 35
215:		jmp scanLongInt$35
217:	

scanLongInt$53:	; if minus == 0 goto 56
218:		cmp word [bp + 10], 0
219:		je scanLongInt$56
221:	

scanLongInt$54:	; £temporary1412 = -longValue
222:		mov a960, [bp + 6]
223:		neg a960
225:	

scanLongInt$55:	; longValue = £temporary1412
226:		mov [bp + 6], a960
228:	

scanLongInt$56:	; if found == 0 goto 58
229:		cmp word [bp + 12], 0
230:		je scanLongInt$58
232:	

scanLongInt$57:	; ++g_inCount
233:		inc word [g_inCount]
235:	

scanLongInt$58:	; call header integral zero 0 stack zero 0
237:	

scanLongInt$59:	; parameter input, offset 6
238:		mov a961, [bp + 14]
239:		mov [bp + 21], a961
241:	

scanLongInt$60:	; call function noellipse-noellipse unscanChar
242:		mov word [bp + 15], scanLongInt$61
243:		mov [bp + 17], bp
244:		add bp, 15
245:		jmp unscanChar
247:	

scanLongInt$61:	; post call
249:	

scanLongInt$62:	; return_value = longValue
250:		mov a962, [bp + 6]
252:	

scanLongInt$63:	; return
253:		mov t963, [bp]
254:		mov di, [bp + 4]
255:		mov bp, [bp + 2]
256:		jmp t963
258:	

scanLongInt$64:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 10], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 18], scanUnsignedLongInt$3
8:		mov [bp + 20], bp
9:		add bp, 18
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1420 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1420
20:		mov [bp + 18], t965
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 19], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1421 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov a966, [bp + 18]
30:		and a966, 255
32:		cmp a966, 0
33:		jge scanUnsignedLongInt$9
34:		neg a966
36:		neg a966
38:	

scanUnsignedLongInt$9:	; parameter £temporary1421, offset 6
39:		mov [bp + 27], a966
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 21], scanUnsignedLongInt$11
43:		mov [bp + 23], bp
44:		add bp, 21
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1422 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1422 == 0 goto 20
55:		cmp t968, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 21], scanUnsignedLongInt$16
62:		mov [bp + 23], bp
63:		add bp, 21
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1423 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1423
74:		mov [bp + 18], t970
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 48 goto 49
80:		cmp byte [bp + 18], 48
81:		jne scanUnsignedLongInt$49
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 21], scanUnsignedLongInt$23
87:		mov [bp + 23], bp
88:		add bp, 21
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1426 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1426
99:		mov [bp + 18], t972
101:	

scanUnsignedLongInt$26:	; call header integral zero 0 stack zero 0
103:	

scanUnsignedLongInt$27:	; £temporary1427 = int_to_int input (Signed_Char -> Signed_Int)
104:		mov a973, [bp + 18]
106:		and a973, 255
108:		cmp a973, 0
109:		jge scanUnsignedLongInt$28
110:		neg a973
112:		neg a973
114:	

scanUnsignedLongInt$28:	; parameter £temporary1427, offset 6
115:		mov [bp + 27], a973
117:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse tolower
118:		mov word [bp + 21], scanUnsignedLongInt$30
119:		mov [bp + 23], bp
120:		add bp, 21
121:		jmp tolower
123:	

scanUnsignedLongInt$30:	; post call
125:	

scanUnsignedLongInt$31:	; £temporary1428 = return_value
130:	

scanUnsignedLongInt$32:	; if £temporary1428 != 120 goto 44
131:		cmp t975, 120
132:		jne scanUnsignedLongInt$44
134:	

scanUnsignedLongInt$33:	; if base != 0 goto 36
135:		cmp dword [bp + 6], 0
136:		jne scanUnsignedLongInt$36
138:	

scanUnsignedLongInt$34:	; £temporary1434 = 16
139:		mov t976, 16
141:	

scanUnsignedLongInt$35:	; goto 37
142:		jmp scanUnsignedLongInt$37
144:	

scanUnsignedLongInt$36:	; £temporary1434 = base
145:		mov t977, [bp + 6]
147:	

scanUnsignedLongInt$37:	; base = £temporary1434
148:		mov [bp + 6], t977
150:	

scanUnsignedLongInt$38:	; call header integral zero 0 stack zero 0
152:	

scanUnsignedLongInt$39:	; call function noellipse-noellipse scanChar
153:		mov word [bp + 21], scanUnsignedLongInt$40
154:		mov [bp + 23], bp
155:		add bp, 21
156:		jmp scanChar
158:	

scanUnsignedLongInt$40:	; post call
160:	

scanUnsignedLongInt$41:	; £temporary1435 = return_value
165:	

scanUnsignedLongInt$42:	; input = £temporary1435
166:		mov [bp + 18], t979
168:	

scanUnsignedLongInt$43:	; goto 49
169:		jmp scanUnsignedLongInt$49
171:	

scanUnsignedLongInt$44:	; if base != 0 goto 47
172:		cmp dword [bp + 6], 0
173:		jne scanUnsignedLongInt$47
175:	

scanUnsignedLongInt$45:	; £temporary1440 = 8
176:		mov t980, 8
178:	

scanUnsignedLongInt$46:	; goto 48
179:		jmp scanUnsignedLongInt$48
181:	

scanUnsignedLongInt$47:	; £temporary1440 = base
182:		mov t981, [bp + 6]
184:	

scanUnsignedLongInt$48:	; base = £temporary1440
185:		mov [bp + 6], t981
187:	

scanUnsignedLongInt$49:	; if base != 0 goto 51
188:		cmp dword [bp + 6], 0
189:		jne scanUnsignedLongInt$51
191:	

scanUnsignedLongInt$50:	; base = 10
192:		mov dword [bp + 6], 10
194:	

scanUnsignedLongInt$51:	; call header integral zero 0 stack zero 0
196:	

scanUnsignedLongInt$52:	; £temporary1442 = int_to_int input (Signed_Char -> Signed_Int)
197:		mov a982, [bp + 18]
199:		and a982, 255
201:		cmp a982, 0
202:		jge scanUnsignedLongInt$53
203:		neg a982
205:		neg a982
207:	

scanUnsignedLongInt$53:	; parameter £temporary1442, offset 6
208:		mov [bp + 27], a982
210:	

scanUnsignedLongInt$54:	; call function noellipse-noellipse isxdigit
211:		mov word [bp + 21], scanUnsignedLongInt$55
212:		mov [bp + 23], bp
213:		add bp, 21
214:		jmp isxdigit
216:	

scanUnsignedLongInt$55:	; post call
218:	

scanUnsignedLongInt$56:	; £temporary1443 = return_value
223:	

scanUnsignedLongInt$57:	; if £temporary1443 == 0 goto 74
224:		cmp t984, 0
225:		je scanUnsignedLongInt$74
227:	

scanUnsignedLongInt$58:	; call header integral zero 0 stack zero 0
229:	

scanUnsignedLongInt$59:	; parameter input, offset 6
230:		mov a985, [bp + 18]
231:		mov [bp + 27], a985
233:	

scanUnsignedLongInt$60:	; call function noellipse-noellipse digitToValue
234:		mov word [bp + 21], scanUnsignedLongInt$61
235:		mov [bp + 23], bp
236:		add bp, 21
237:		jmp digitToValue
239:	

scanUnsignedLongInt$61:	; post call
241:	

scanUnsignedLongInt$62:	; £temporary1444 = return_value
246:	

scanUnsignedLongInt$63:	; digit = £temporary1444
247:		mov [bp + 14], t987
249:	

scanUnsignedLongInt$64:	; if digit >= base goto 74
250:		mov a988, [bp + 6]
251:		cmp [bp + 14], a988
252:		jae scanUnsignedLongInt$74
254:	

scanUnsignedLongInt$65:	; £temporary1446 = unsignedLongValue * base
255:		mov a989, [bp + 10]
257:		xor edx, edx
258:		mul dword [bp + 6]
264:	

scanUnsignedLongInt$66:	; unsignedLongValue = £temporary1446 + digit
265:		add t992, [bp + 14]
266:		mov [bp + 10], t992
268:	

scanUnsignedLongInt$67:	; found = 1
269:		mov word [bp + 19], 1
271:	

scanUnsignedLongInt$68:	; call header integral zero 0 stack zero 0
273:	

scanUnsignedLongInt$69:	; call function noellipse-noellipse scanChar
274:		mov word [bp + 21], scanUnsignedLongInt$70
275:		mov [bp + 23], bp
276:		add bp, 21
277:		jmp scanChar
279:	

scanUnsignedLongInt$70:	; post call
281:	

scanUnsignedLongInt$71:	; £temporary1448 = return_value
286:	

scanUnsignedLongInt$72:	; input = £temporary1448
287:		mov [bp + 18], t994
289:	

scanUnsignedLongInt$73:	; goto 51
290:		jmp scanUnsignedLongInt$51
292:	

scanUnsignedLongInt$74:	; if found == 0 goto 76
293:		cmp word [bp + 19], 0
294:		je scanUnsignedLongInt$76
296:	

scanUnsignedLongInt$75:	; ++g_inCount
297:		inc word [g_inCount]
299:	

scanUnsignedLongInt$76:	; call header integral zero 0 stack zero 0
301:	

scanUnsignedLongInt$77:	; parameter input, offset 6
302:		mov a995, [bp + 18]
303:		mov [bp + 27], a995
305:	

scanUnsignedLongInt$78:	; call function noellipse-noellipse unscanChar
306:		mov word [bp + 21], scanUnsignedLongInt$79
307:		mov [bp + 23], bp
308:		add bp, 21
309:		jmp unscanChar
311:	

scanUnsignedLongInt$79:	; post call
313:	

scanUnsignedLongInt$80:	; return_value = unsignedLongValue
314:		mov a996, [bp + 10]
316:	

scanUnsignedLongInt$81:	; return
317:		mov t997, [bp]
318:		mov di, [bp + 4]
319:		mov bp, [bp + 2]
320:		jmp t997
322:	

scanUnsignedLongInt$82:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1458 = return_value
34:	

scanLongDouble$10:	; input = £temporary1458
35:		mov [bp + 26], t999
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1459 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov a1000, [bp + 26]
42:		and a1000, 255
44:		cmp a1000, 0
45:		jge scanLongDouble$13
46:		neg a1000
48:		neg a1000
50:	

scanLongDouble$13:	; parameter £temporary1459, offset 6
51:		mov [bp + 33], a1000
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1460 = return_value
66:	

scanLongDouble$17:	; if £temporary1460 == 0 goto 24
67:		cmp t1002, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1461 = return_value
85:	

scanLongDouble$22:	; input = £temporary1461
86:		mov [bp + 26], t1004
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1464 = return_value
110:	

scanLongDouble$29:	; input = £temporary1464
111:		mov [bp + 26], t1006
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1466 = return_value
138:	

scanLongDouble$37:	; input = £temporary1466
139:		mov [bp + 26], t1008
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1467 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov a1009, [bp + 26]
146:		and a1009, 255
148:		cmp a1009, 0
149:		jge scanLongDouble$40
150:		neg a1009
152:		neg a1009
154:	

scanLongDouble$40:	; parameter £temporary1467, offset 6
155:		mov [bp + 33], a1009
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1468 = return_value
170:	

scanLongDouble$44:	; if £temporary1468 == 0 goto 60
171:		cmp t1011, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1469 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1470 = input - 48
184:		mov a1012, [bp + 26]
185:		sub a1012, 48
187:	

scanLongDouble$49:	; £temporary1472 = int_to_int £temporary1470 (Signed_Char -> Signed_Int)
189:		and a1012, 255
191:		cmp a1012, 0
192:		jge scanLongDouble$50
193:		neg a1012
195:		neg a1012
197:	

scanLongDouble$50:	; £temporary1471 = int_to_float £temporary1472 (Signed_Int -> Long_Double)
198:		mov [container2bytes#], a1012
199:		fild word [container2bytes#]
201:	

scanLongDouble$51:	; £temporary1473 = £temporary1469 + £temporary1471
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1474 = return_value
222:	

scanLongDouble$57:	; input = £temporary1474
223:		mov [bp + 26], t1014
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1477 = return_value
250:	

scanLongDouble$65:	; input = £temporary1477
251:		mov [bp + 26], t1016
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1478 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov a1017, [bp + 26]
258:		and a1017, 255
260:		cmp a1017, 0
261:		jge scanLongDouble$68
262:		neg a1017
264:		neg a1017
266:	

scanLongDouble$68:	; parameter £temporary1478, offset 6
267:		mov [bp + 33], a1017
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1479 = return_value
282:	

scanLongDouble$72:	; if £temporary1479 == 0 goto 92
283:		cmp t1019, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1480 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1481 = input - 48
305:		mov a1020, [bp + 26]
306:		sub a1020, 48
308:	

scanLongDouble$80:	; £temporary1483 = int_to_int £temporary1481 (Signed_Char -> Signed_Int)
310:		and a1020, 255
312:		cmp a1020, 0
313:		jge scanLongDouble$81
314:		neg a1020
316:		neg a1020
318:	

scanLongDouble$81:	; £temporary1482 = int_to_float £temporary1483 (Signed_Int -> Long_Double)
319:		mov [container2bytes#], a1020
320:		fild word [container2bytes#]
322:	

scanLongDouble$82:	; £temporary1484 = factor * £temporary1482
323:		fmul
325:	

scanLongDouble$83:	; £temporary1485 = value + £temporary1484
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1486 = return_value
346:	

scanLongDouble$89:	; input = £temporary1486
347:		mov [bp + 26], t1022
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; parameter input, offset 6
358:		mov a1023, [bp + 26]
359:		mov [bp + 33], a1023
361:	

scanLongDouble$94:	; call function noellipse-noellipse unscanChar
362:		mov word [bp + 27], scanLongDouble$95
363:		mov [bp + 29], bp
364:		add bp, 27
365:		jmp unscanChar
367:	

scanLongDouble$95:	; post call
369:	

scanLongDouble$96:	; call header integral zero 0 stack zero 0
371:	

scanLongDouble$97:	; £temporary1489 = int_to_int input (Signed_Char -> Signed_Int)
372:		mov a1024, [bp + 26]
374:		and a1024, 255
376:		cmp a1024, 0
377:		jge scanLongDouble$98
378:		neg a1024
380:		neg a1024
382:	

scanLongDouble$98:	; parameter £temporary1489, offset 6
383:		mov [bp + 33], a1024
385:	

scanLongDouble$99:	; call function noellipse-noellipse tolower
386:		mov word [bp + 27], scanLongDouble$100
387:		mov [bp + 29], bp
388:		add bp, 27
389:		jmp tolower
391:	

scanLongDouble$100:	; post call
393:	

scanLongDouble$101:	; £temporary1490 = return_value
398:	

scanLongDouble$102:	; if £temporary1490 != 101 goto 121
399:		cmp t1026, 101
400:		jne scanLongDouble$121
402:	

scanLongDouble$103:	; call header integral zero 0 stack zero 0
404:	

scanLongDouble$104:	; call function noellipse-noellipse scanLongInt
405:		mov word [bp + 27], scanLongDouble$105
406:		mov [bp + 29], bp
407:		add bp, 27
408:		jmp scanLongInt
410:	

scanLongDouble$105:	; post call
412:	

scanLongDouble$106:	; £temporary1492 = return_value
417:	

scanLongDouble$107:	; £temporary1493 = int_to_float £temporary1492 (Signed_Long_Int -> Double)
418:		mov [container4bytes#], t1028
419:		fild dword [container4bytes#]
421:	

scanLongDouble$108:	; pop float exponent
422:		fstp qword [bp + 27]
424:	

scanLongDouble$109:	; push float value
425:		fld qword [bp + 10]
427:	

scanLongDouble$110:	; call header integral zero 0 stack no zero 1
428:		fstp qword [bp + 35]
430:	

scanLongDouble$111:	; push float 10.0
431:		fld qword [float8$10.0#]
433:	

scanLongDouble$112:	; parameter 10.0, offset 6
434:		fstp qword [bp + 49]
436:	

scanLongDouble$113:	; push float exponent
437:		fld qword [bp + 27]
439:	

scanLongDouble$114:	; parameter exponent, offset 14
440:		fstp qword [bp + 57]
442:	

scanLongDouble$115:	; call function noellipse-noellipse pow
443:		mov word [bp + 43], scanLongDouble$116
444:		mov [bp + 45], bp
445:		add bp, 43
446:		jmp pow
448:	

scanLongDouble$116:	; post call
449:		fstp qword [bp + 43]
450:		fld qword [bp + 35]
451:		fld qword [bp + 43]
453:	

scanLongDouble$117:	; £temporary1494 = return_value
455:	

scanLongDouble$118:	; £temporary1495 = value * £temporary1494
456:		fmul
458:	

scanLongDouble$119:	; pop float value
459:		fstp qword [bp + 10]
461:	

scanLongDouble$120:	; goto 125
462:		jmp scanLongDouble$125
464:	

scanLongDouble$121:	; call header integral zero 0 stack zero 0
466:	

scanLongDouble$122:	; parameter input, offset 6
467:		mov a1029, [bp + 26]
468:		mov [bp + 33], a1029
470:	

scanLongDouble$123:	; call function noellipse-noellipse unscanChar
471:		mov word [bp + 27], scanLongDouble$124
472:		mov [bp + 29], bp
473:		add bp, 27
474:		jmp unscanChar
476:	

scanLongDouble$124:	; post call
478:	

scanLongDouble$125:	; if minus == 0 goto 129
479:		cmp word [bp + 6], 0
480:		je scanLongDouble$129
482:	

scanLongDouble$126:	; push float value
483:		fld qword [bp + 10]
485:	

scanLongDouble$127:	; £temporary1497 = -value
486:		fchs
488:	

scanLongDouble$128:	; pop float value
489:		fstp qword [bp + 10]
491:	

scanLongDouble$129:	; if found == 0 goto 131
492:		cmp word [bp + 8], 0
493:		je scanLongDouble$131
495:	

scanLongDouble$130:	; ++g_inCount
496:		inc word [g_inCount]
498:	

scanLongDouble$131:	; push float value
499:		fld qword [bp + 10]
501:	

scanLongDouble$132:	; return_value = value
503:	

scanLongDouble$133:	; return
504:		mov t1030, [bp]
505:		mov di, [bp + 4]
506:		mov bp, [bp + 2]
507:		jmp t1030
509:	

scanLongDouble$134:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1510 = format + index
26:		mov a1031, [bp + 6]
27:		add a1031, [bp + 31]
29:	

scanFormat$9:	; £temporary1509 -> £temporary1510 = *£temporary1510
31:	

scanFormat$10:	; if £temporary1509 -> £temporary1510 == 0 goto 325
32:		cmp byte [a1031], 0
33:		je scanFormat$325
35:	

scanFormat$11:	; £temporary1514 = format + index
36:		mov a1032, [bp + 6]
37:		add a1032, [bp + 31]
39:	

scanFormat$12:	; £temporary1513 -> £temporary1514 = *£temporary1514
41:	

scanFormat$13:	; c = £temporary1513 -> £temporary1514
42:		mov t1033, [a1032]
43:		mov [bp + 10], t1033
45:	

scanFormat$14:	; £temporary1515 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov a1034, [bp + 10]
48:		and a1034, 255
50:		cmp a1034, 0
51:		jge scanFormat$15
52:		neg a1034
54:		neg a1034
56:	

scanFormat$15:	; d = £temporary1515 + 1
57:		add a1034, 1
58:		mov [bp + 55], a1034
60:	

scanFormat$16:	; if percent == 0 goto 317
61:		cmp word [bp + 13], 0
62:		je scanFormat$317
64:	

scanFormat$17:	; £temporary1517 = d - 1
65:		mov a1035, [bp + 55]
66:		sub a1035, 1
68:	

scanFormat$18:	; case £temporary1517 == 104 goto 36
69:		cmp a1035, 104
70:		je scanFormat$36
72:	

scanFormat$19:	; case £temporary1517 == 108 goto 38
73:		cmp a1035, 108
74:		je scanFormat$38
76:	

scanFormat$20:	; case £temporary1517 == 76 goto 40
77:		cmp a1035, 76
78:		je scanFormat$40
80:	

scanFormat$21:	; case £temporary1517 == 42 goto 42
81:		cmp a1035, 42
82:		je scanFormat$42
84:	

scanFormat$22:	; case £temporary1517 == 99 goto 44
85:		cmp a1035, 99
86:		je scanFormat$44
88:	

scanFormat$23:	; case £temporary1517 == 115 goto 62
89:		cmp a1035, 115
90:		je scanFormat$62
92:	

scanFormat$24:	; case £temporary1517 == 100 goto 81
93:		cmp a1035, 100
94:		je scanFormat$81
96:	

scanFormat$25:	; case £temporary1517 == 105 goto 81
97:		cmp a1035, 105
98:		je scanFormat$81
100:	

scanFormat$26:	; case £temporary1517 == 111 goto 116
101:		cmp a1035, 111
102:		je scanFormat$116
104:	

scanFormat$27:	; case £temporary1517 == 120 goto 152
105:		cmp a1035, 120
106:		je scanFormat$152
108:	

scanFormat$28:	; case £temporary1517 == 117 goto 188
109:		cmp a1035, 117
110:		je scanFormat$188
112:	

scanFormat$29:	; case £temporary1517 == 103 goto 224
113:		cmp a1035, 103
114:		je scanFormat$224
116:	

scanFormat$30:	; case £temporary1517 == 102 goto 224
117:		cmp a1035, 102
118:		je scanFormat$224
120:	

scanFormat$31:	; case £temporary1517 == 101 goto 224
121:		cmp a1035, 101
122:		je scanFormat$224
124:	

scanFormat$32:	; case £temporary1517 == 91 goto 260
125:		cmp a1035, 91
126:		je scanFormat$260
128:	

scanFormat$33:	; case £temporary1517 == 110 goto 301
129:		cmp a1035, 110
130:		je scanFormat$301
132:	

scanFormat$34:	; case end £temporary1517
134:	

scanFormat$35:	; goto 310
135:		jmp scanFormat$310
137:	

scanFormat$36:	; shortInt = 1
138:		mov word [bp + 15], 1
140:	

scanFormat$37:	; goto 323
141:		jmp scanFormat$323
143:	

scanFormat$38:	; longIntOrDouble = 1
144:		mov word [bp + 17], 1
146:	

scanFormat$39:	; goto 323
147:		jmp scanFormat$323
149:	

scanFormat$40:	; longDouble = 1
150:		mov word [bp + 19], 1
152:	

scanFormat$41:	; goto 323
153:		jmp scanFormat$323
155:	

scanFormat$42:	; star = 1
156:		mov word [bp + 21], 1
158:	

scanFormat$43:	; goto 323
159:		jmp scanFormat$323
161:	

scanFormat$44:	; call header integral zero 0 stack zero 0
163:	

scanFormat$45:	; call function noellipse-noellipse scanChar
164:		mov word [bp + 57], scanFormat$46
165:		mov [bp + 59], bp
166:		add bp, 57
167:		jmp scanChar
169:	

scanFormat$46:	; post call
171:	

scanFormat$47:	; £temporary1518 = return_value
176:	

scanFormat$48:	; charValue = £temporary1518
177:		mov [bp + 57], t1037
179:	

scanFormat$49:	; if star != 0 goto 57
180:		cmp word [bp + 21], 0
181:		jne scanFormat$57
183:	

scanFormat$50:	; arg_list = arg_list + 2
184:		add word [bp + 8], 2
186:	

scanFormat$51:	; £temporary1522 = arg_list - 2
187:		mov a1038, [bp + 8]
188:		sub a1038, 2
190:	

scanFormat$52:	; £temporary1523 = int_to_int £temporary1522 (Signed_Int -> Pointer)
193:	

scanFormat$53:	; £temporary1524 -> £temporary1523 = *£temporary1523
195:	

scanFormat$54:	; charPtr = £temporary1524 -> £temporary1523
196:		mov t1039, [a1038]
197:		mov [bp + 11], t1039
199:	

scanFormat$55:	; £temporary1525 -> charPtr = *charPtr
200:		mov a1040, [bp + 11]
202:	

scanFormat$56:	; £temporary1525 -> charPtr = charValue
203:		mov a1041, [bp + 57]
204:		mov [a1040], a1041
206:	

scanFormat$57:	; percent = 0
207:		mov word [bp + 13], 0
209:	

scanFormat$58:	; £temporary1526 = int_to_int charValue (Signed_Char -> Signed_Int)
210:		mov a1042, [bp + 57]
212:		and a1042, 255
214:		cmp a1042, 0
215:		jge scanFormat$59
216:		neg a1042
218:		neg a1042
220:	

scanFormat$59:	; if £temporary1526 == -1 goto 323
221:		cmp a1042, -1
222:		je scanFormat$323
224:	

scanFormat$60:	; ++g_inCount
225:		inc word [g_inCount]
227:	

scanFormat$61:	; goto 323
228:		jmp scanFormat$323
230:	

scanFormat$62:	; if star != 0 goto 74
231:		cmp word [bp + 21], 0
232:		jne scanFormat$74
234:	

scanFormat$63:	; arg_list = arg_list + 2
235:		add word [bp + 8], 2
237:	

scanFormat$64:	; £temporary1532 = arg_list - 2
238:		mov a1043, [bp + 8]
239:		sub a1043, 2
241:	

scanFormat$65:	; £temporary1533 = int_to_int £temporary1532 (Signed_Int -> Pointer)
244:	

scanFormat$66:	; £temporary1534 -> £temporary1533 = *£temporary1533
246:	

scanFormat$67:	; charPtr = £temporary1534 -> £temporary1533
247:		mov t1044, [a1043]
248:		mov [bp + 11], t1044
250:	

scanFormat$68:	; call header integral zero 0 stack zero 0
252:	

scanFormat$69:	; parameter charPtr, offset 6
253:		mov a1045, [bp + 11]
254:		mov [bp + 63], a1045
256:	

scanFormat$70:	; parameter 0, offset 8
257:		mov word [bp + 65], 0
259:	

scanFormat$71:	; call function noellipse-noellipse scanString
260:		mov word [bp + 57], scanFormat$72
261:		mov [bp + 59], bp
262:		add bp, 57
263:		jmp scanString
265:	

scanFormat$72:	; post call
267:	

scanFormat$73:	; goto 79
268:		jmp scanFormat$79
270:	

scanFormat$74:	; call header integral zero 0 stack zero 0
272:	

scanFormat$75:	; parameter 0, offset 6
273:		mov word [bp + 63], 0
275:	

scanFormat$76:	; parameter 0, offset 8
276:		mov word [bp + 65], 0
278:	

scanFormat$77:	; call function noellipse-noellipse scanString
279:		mov word [bp + 57], scanFormat$78
280:		mov [bp + 59], bp
281:		add bp, 57
282:		jmp scanString
284:	

scanFormat$78:	; post call
286:	

scanFormat$79:	; percent = 0
287:		mov word [bp + 13], 0
289:	

scanFormat$80:	; goto 323
290:		jmp scanFormat$323
292:	

scanFormat$81:	; call header integral zero 0 stack zero 0
294:	

scanFormat$82:	; call function noellipse-noellipse scanLongInt
295:		mov word [bp + 57], scanFormat$83
296:		mov [bp + 59], bp
297:		add bp, 57
298:		jmp scanLongInt
300:	

scanFormat$83:	; post call
302:	

scanFormat$84:	; £temporary1537 = return_value
307:	

scanFormat$85:	; longValue = £temporary1537
308:		mov [bp + 23], t1047
310:	

scanFormat$86:	; if star != 0 goto 114
311:		cmp word [bp + 21], 0
312:		jne scanFormat$114
314:	

scanFormat$87:	; if shortInt == 0 goto 97
315:		cmp word [bp + 15], 0
316:		je scanFormat$97
318:	

scanFormat$88:	; arg_list = arg_list + 2
319:		add word [bp + 8], 2
321:	

scanFormat$89:	; £temporary1541 = arg_list - 2
322:		mov a1048, [bp + 8]
323:		sub a1048, 2
325:	

scanFormat$90:	; £temporary1542 = int_to_int £temporary1541 (Signed_Int -> Pointer)
328:	

scanFormat$91:	; £temporary1543 -> £temporary1542 = *£temporary1542
330:	

scanFormat$92:	; shortPtr = £temporary1543 -> £temporary1542
331:		mov t1049, [a1048]
332:		mov [bp + 29], t1049
334:	

scanFormat$93:	; £temporary1544 -> shortPtr = *shortPtr
335:		mov a1050, [bp + 29]
337:	

scanFormat$94:	; £temporary1545 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
338:		mov a1051, [bp + 23]
341:		cmp a1051, 0
342:		jge scanFormat$95
343:		neg a1051
345:		neg a1051
347:	

scanFormat$95:	; £temporary1544 -> shortPtr = £temporary1545
348:		mov [a1050], a1051
350:	

scanFormat$96:	; goto 114
351:		jmp scanFormat$114
353:	

scanFormat$97:	; if longIntOrDouble != 0 goto 107
354:		cmp word [bp + 17], 0
355:		jne scanFormat$107
357:	

scanFormat$98:	; arg_list = arg_list + 2
358:		add word [bp + 8], 2
360:	

scanFormat$99:	; £temporary1549 = arg_list - 2
361:		mov a1052, [bp + 8]
362:		sub a1052, 2
364:	

scanFormat$100:	; £temporary1550 = int_to_int £temporary1549 (Signed_Int -> Pointer)
367:	

scanFormat$101:	; £temporary1551 -> £temporary1550 = *£temporary1550
369:	

scanFormat$102:	; intPtr = £temporary1551 -> £temporary1550
370:		mov t1053, [a1052]
371:		mov [bp + 33], t1053
373:	

scanFormat$103:	; £temporary1552 -> intPtr = *intPtr
374:		mov a1054, [bp + 33]
376:	

scanFormat$104:	; £temporary1553 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
377:		mov a1055, [bp + 23]
380:		cmp a1055, 0
381:		jge scanFormat$105
382:		neg a1055
384:		neg a1055
386:	

scanFormat$105:	; £temporary1552 -> intPtr = £temporary1553
387:		mov [a1054], a1055
389:	

scanFormat$106:	; goto 114
390:		jmp scanFormat$114
392:	

scanFormat$107:	; arg_list = arg_list + 2
393:		add word [bp + 8], 2
395:	

scanFormat$108:	; £temporary1555 = arg_list - 2
396:		mov a1056, [bp + 8]
397:		sub a1056, 2
399:	

scanFormat$109:	; £temporary1556 = int_to_int £temporary1555 (Signed_Int -> Pointer)
402:	

scanFormat$110:	; £temporary1557 -> £temporary1556 = *£temporary1556
404:	

scanFormat$111:	; longPtr = £temporary1557 -> £temporary1556
405:		mov t1057, [a1056]
406:		mov [bp + 27], t1057
408:	

scanFormat$112:	; £temporary1558 -> longPtr = *longPtr
409:		mov a1058, [bp + 27]
411:	

scanFormat$113:	; £temporary1558 -> longPtr = longValue
412:		mov a1059, [bp + 23]
413:		mov [a1058], a1059
415:	

scanFormat$114:	; percent = 0
416:		mov word [bp + 13], 0
418:	

scanFormat$115:	; goto 323
419:		jmp scanFormat$323
421:	

scanFormat$116:	; call header integral zero 0 stack zero 0
423:	

scanFormat$117:	; parameter 8, offset 6
424:		mov dword [bp + 63], 8
426:	

scanFormat$118:	; call function noellipse-noellipse scanUnsignedLongInt
427:		mov word [bp + 57], scanFormat$119
428:		mov [bp + 59], bp
429:		add bp, 57
430:		jmp scanUnsignedLongInt
432:	

scanFormat$119:	; post call
434:	

scanFormat$120:	; £temporary1560 = return_value
439:	

scanFormat$121:	; unsignedLongValue = £temporary1560
440:		mov [bp + 37], t1061
442:	

scanFormat$122:	; if star != 0 goto 150
443:		cmp word [bp + 21], 0
444:		jne scanFormat$150
446:	

scanFormat$123:	; if shortInt == 0 goto 133
447:		cmp word [bp + 15], 0
448:		je scanFormat$133
450:	

scanFormat$124:	; arg_list = arg_list + 2
451:		add word [bp + 8], 2
453:	

scanFormat$125:	; £temporary1564 = arg_list - 2
454:		mov a1062, [bp + 8]
455:		sub a1062, 2
457:	

scanFormat$126:	; £temporary1565 = int_to_int £temporary1564 (Signed_Int -> Pointer)
460:	

scanFormat$127:	; £temporary1566 -> £temporary1565 = *£temporary1565
462:	

scanFormat$128:	; unsignedShortPtr = £temporary1566 -> £temporary1565
463:		mov t1063, [a1062]
464:		mov [bp + 43], t1063
466:	

scanFormat$129:	; £temporary1567 -> unsignedShortPtr = *unsignedShortPtr
467:		mov a1064, [bp + 43]
469:	

scanFormat$130:	; £temporary1568 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
470:		mov a1065, [bp + 37]
473:	

scanFormat$131:	; £temporary1567 -> unsignedShortPtr = £temporary1568
474:		mov [a1064], a1065
476:	

scanFormat$132:	; goto 150
477:		jmp scanFormat$150
479:	

scanFormat$133:	; if longIntOrDouble != 0 goto 143
480:		cmp word [bp + 17], 0
481:		jne scanFormat$143
483:	

scanFormat$134:	; arg_list = arg_list + 2
484:		add word [bp + 8], 2
486:	

scanFormat$135:	; £temporary1572 = arg_list - 2
487:		mov a1066, [bp + 8]
488:		sub a1066, 2
490:	

scanFormat$136:	; £temporary1573 = int_to_int £temporary1572 (Signed_Int -> Pointer)
493:	

scanFormat$137:	; £temporary1574 -> £temporary1573 = *£temporary1573
495:	

scanFormat$138:	; unsignedIntPtr = £temporary1574 -> £temporary1573
496:		mov t1067, [a1066]
497:		mov [bp + 45], t1067
499:	

scanFormat$139:	; £temporary1575 -> unsignedIntPtr = *unsignedIntPtr
500:		mov a1068, [bp + 45]
502:	

scanFormat$140:	; £temporary1576 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
503:		mov a1069, [bp + 37]
506:	

scanFormat$141:	; £temporary1575 -> unsignedIntPtr = £temporary1576
507:		mov [a1068], a1069
509:	

scanFormat$142:	; goto 150
510:		jmp scanFormat$150
512:	

scanFormat$143:	; arg_list = arg_list + 2
513:		add word [bp + 8], 2
515:	

scanFormat$144:	; £temporary1578 = arg_list - 2
516:		mov a1070, [bp + 8]
517:		sub a1070, 2
519:	

scanFormat$145:	; £temporary1579 = int_to_int £temporary1578 (Signed_Int -> Pointer)
522:	

scanFormat$146:	; £temporary1580 -> £temporary1579 = *£temporary1579
524:	

scanFormat$147:	; unsignedLongPtr = £temporary1580 -> £temporary1579
525:		mov t1071, [a1070]
526:		mov [bp + 41], t1071
528:	

scanFormat$148:	; £temporary1581 -> unsignedLongPtr = *unsignedLongPtr
529:		mov a1072, [bp + 41]
531:	

scanFormat$149:	; £temporary1581 -> unsignedLongPtr = unsignedLongValue
532:		mov a1073, [bp + 37]
533:		mov [a1072], a1073
535:	

scanFormat$150:	; percent = 0
536:		mov word [bp + 13], 0
538:	

scanFormat$151:	; goto 323
539:		jmp scanFormat$323
541:	

scanFormat$152:	; call header integral zero 0 stack zero 0
543:	

scanFormat$153:	; parameter 16, offset 6
544:		mov dword [bp + 63], 16
546:	

scanFormat$154:	; call function noellipse-noellipse scanUnsignedLongInt
547:		mov word [bp + 57], scanFormat$155
548:		mov [bp + 59], bp
549:		add bp, 57
550:		jmp scanUnsignedLongInt
552:	

scanFormat$155:	; post call
554:	

scanFormat$156:	; £temporary1583 = return_value
559:	

scanFormat$157:	; unsignedLongValue = £temporary1583
560:		mov [bp + 37], t1075
562:	

scanFormat$158:	; if star != 0 goto 186
563:		cmp word [bp + 21], 0
564:		jne scanFormat$186
566:	

scanFormat$159:	; if shortInt == 0 goto 169
567:		cmp word [bp + 15], 0
568:		je scanFormat$169
570:	

scanFormat$160:	; arg_list = arg_list + 2
571:		add word [bp + 8], 2
573:	

scanFormat$161:	; £temporary1587 = arg_list - 2
574:		mov a1076, [bp + 8]
575:		sub a1076, 2
577:	

scanFormat$162:	; £temporary1588 = int_to_int £temporary1587 (Signed_Int -> Pointer)
580:	

scanFormat$163:	; £temporary1589 -> £temporary1588 = *£temporary1588
582:	

scanFormat$164:	; unsignedShortPtr = £temporary1589 -> £temporary1588
583:		mov t1077, [a1076]
584:		mov [bp + 43], t1077
586:	

scanFormat$165:	; £temporary1590 -> unsignedShortPtr = *unsignedShortPtr
587:		mov a1078, [bp + 43]
589:	

scanFormat$166:	; £temporary1591 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
590:		mov a1079, [bp + 37]
593:	

scanFormat$167:	; £temporary1590 -> unsignedShortPtr = £temporary1591
594:		mov [a1078], a1079
596:	

scanFormat$168:	; goto 186
597:		jmp scanFormat$186
599:	

scanFormat$169:	; if longIntOrDouble != 0 goto 179
600:		cmp word [bp + 17], 0
601:		jne scanFormat$179
603:	

scanFormat$170:	; arg_list = arg_list + 2
604:		add word [bp + 8], 2
606:	

scanFormat$171:	; £temporary1595 = arg_list - 2
607:		mov a1080, [bp + 8]
608:		sub a1080, 2
610:	

scanFormat$172:	; £temporary1596 = int_to_int £temporary1595 (Signed_Int -> Pointer)
613:	

scanFormat$173:	; £temporary1597 -> £temporary1596 = *£temporary1596
615:	

scanFormat$174:	; unsignedIntPtr = £temporary1597 -> £temporary1596
616:		mov t1081, [a1080]
617:		mov [bp + 45], t1081
619:	

scanFormat$175:	; £temporary1598 -> unsignedIntPtr = *unsignedIntPtr
620:		mov a1082, [bp + 45]
622:	

scanFormat$176:	; £temporary1599 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
623:		mov a1083, [bp + 37]
626:	

scanFormat$177:	; £temporary1598 -> unsignedIntPtr = £temporary1599
627:		mov [a1082], a1083
629:	

scanFormat$178:	; goto 186
630:		jmp scanFormat$186
632:	

scanFormat$179:	; arg_list = arg_list + 2
633:		add word [bp + 8], 2
635:	

scanFormat$180:	; £temporary1601 = arg_list - 2
636:		mov a1084, [bp + 8]
637:		sub a1084, 2
639:	

scanFormat$181:	; £temporary1602 = int_to_int £temporary1601 (Signed_Int -> Pointer)
642:	

scanFormat$182:	; £temporary1603 -> £temporary1602 = *£temporary1602
644:	

scanFormat$183:	; unsignedLongPtr = £temporary1603 -> £temporary1602
645:		mov t1085, [a1084]
646:		mov [bp + 41], t1085
648:	

scanFormat$184:	; £temporary1604 -> unsignedLongPtr = *unsignedLongPtr
649:		mov a1086, [bp + 41]
651:	

scanFormat$185:	; £temporary1604 -> unsignedLongPtr = unsignedLongValue
652:		mov a1087, [bp + 37]
653:		mov [a1086], a1087
655:	

scanFormat$186:	; percent = 0
656:		mov word [bp + 13], 0
658:	

scanFormat$187:	; goto 323
659:		jmp scanFormat$323
661:	

scanFormat$188:	; call header integral zero 0 stack zero 0
663:	

scanFormat$189:	; parameter 0, offset 6
664:		mov dword [bp + 63], 0
666:	

scanFormat$190:	; call function noellipse-noellipse scanUnsignedLongInt
667:		mov word [bp + 57], scanFormat$191
668:		mov [bp + 59], bp
669:		add bp, 57
670:		jmp scanUnsignedLongInt
672:	

scanFormat$191:	; post call
674:	

scanFormat$192:	; £temporary1606 = return_value
679:	

scanFormat$193:	; unsignedLongValue = £temporary1606
680:		mov [bp + 37], t1089
682:	

scanFormat$194:	; if star != 0 goto 222
683:		cmp word [bp + 21], 0
684:		jne scanFormat$222
686:	

scanFormat$195:	; if shortInt == 0 goto 205
687:		cmp word [bp + 15], 0
688:		je scanFormat$205
690:	

scanFormat$196:	; arg_list = arg_list + 2
691:		add word [bp + 8], 2
693:	

scanFormat$197:	; £temporary1610 = arg_list - 2
694:		mov a1090, [bp + 8]
695:		sub a1090, 2
697:	

scanFormat$198:	; £temporary1611 = int_to_int £temporary1610 (Signed_Int -> Pointer)
700:	

scanFormat$199:	; £temporary1612 -> £temporary1611 = *£temporary1611
702:	

scanFormat$200:	; unsignedShortPtr = £temporary1612 -> £temporary1611
703:		mov t1091, [a1090]
704:		mov [bp + 43], t1091
706:	

scanFormat$201:	; £temporary1613 -> unsignedShortPtr = *unsignedShortPtr
707:		mov a1092, [bp + 43]
709:	

scanFormat$202:	; £temporary1614 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
710:		mov a1093, [bp + 37]
713:	

scanFormat$203:	; £temporary1613 -> unsignedShortPtr = £temporary1614
714:		mov [a1092], a1093
716:	

scanFormat$204:	; goto 222
717:		jmp scanFormat$222
719:	

scanFormat$205:	; if longIntOrDouble != 0 goto 215
720:		cmp word [bp + 17], 0
721:		jne scanFormat$215
723:	

scanFormat$206:	; arg_list = arg_list + 2
724:		add word [bp + 8], 2
726:	

scanFormat$207:	; £temporary1618 = arg_list - 2
727:		mov a1094, [bp + 8]
728:		sub a1094, 2
730:	

scanFormat$208:	; £temporary1619 = int_to_int £temporary1618 (Signed_Int -> Pointer)
733:	

scanFormat$209:	; £temporary1620 -> £temporary1619 = *£temporary1619
735:	

scanFormat$210:	; unsignedIntPtr = £temporary1620 -> £temporary1619
736:		mov t1095, [a1094]
737:		mov [bp + 45], t1095
739:	

scanFormat$211:	; £temporary1621 -> unsignedIntPtr = *unsignedIntPtr
740:		mov a1096, [bp + 45]
742:	

scanFormat$212:	; £temporary1622 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
743:		mov a1097, [bp + 37]
746:	

scanFormat$213:	; £temporary1621 -> unsignedIntPtr = £temporary1622
747:		mov [a1096], a1097
749:	

scanFormat$214:	; goto 222
750:		jmp scanFormat$222
752:	

scanFormat$215:	; arg_list = arg_list + 2
753:		add word [bp + 8], 2
755:	

scanFormat$216:	; £temporary1624 = arg_list - 2
756:		mov a1098, [bp + 8]
757:		sub a1098, 2
759:	

scanFormat$217:	; £temporary1625 = int_to_int £temporary1624 (Signed_Int -> Pointer)
762:	

scanFormat$218:	; £temporary1626 -> £temporary1625 = *£temporary1625
764:	

scanFormat$219:	; unsignedLongPtr = £temporary1626 -> £temporary1625
765:		mov t1099, [a1098]
766:		mov [bp + 41], t1099
768:	

scanFormat$220:	; £temporary1627 -> unsignedLongPtr = *unsignedLongPtr
769:		mov a1100, [bp + 41]
771:	

scanFormat$221:	; £temporary1627 -> unsignedLongPtr = unsignedLongValue
772:		mov a1101, [bp + 37]
773:		mov [a1100], a1101
775:	

scanFormat$222:	; percent = 0
776:		mov word [bp + 13], 0
778:	

scanFormat$223:	; goto 323
779:		jmp scanFormat$323
781:	

scanFormat$224:	; call header integral zero 0 stack zero 0
783:	

scanFormat$225:	; call function noellipse-noellipse scanLongDouble
784:		mov word [bp + 57], scanFormat$226
785:		mov [bp + 59], bp
786:		add bp, 57
787:		jmp scanLongDouble
789:	

scanFormat$226:	; post call
791:	

scanFormat$227:	; £temporary1629 = return_value
793:	

scanFormat$228:	; pop float longDoubleValue
794:		fstp qword [bp + 47]
796:	

scanFormat$229:	; if star != 0 goto 258
797:		cmp word [bp + 21], 0
798:		jne scanFormat$258
800:	

scanFormat$230:	; if longIntOrDouble == 0 goto 240
801:		cmp word [bp + 17], 0
802:		je scanFormat$240
804:	

scanFormat$231:	; arg_list = arg_list + 2
805:		add word [bp + 8], 2
807:	

scanFormat$232:	; £temporary1633 = arg_list - 2
808:		mov a1102, [bp + 8]
809:		sub a1102, 2
811:	

scanFormat$233:	; £temporary1634 = int_to_int £temporary1633 (Signed_Int -> Pointer)
814:	

scanFormat$234:	; £temporary1635 -> £temporary1634 = *£temporary1634
816:	

scanFormat$235:	; doublePtr = £temporary1635 -> £temporary1634
817:		mov t1103, [a1102]
818:		mov [bp + 57], t1103
820:	

scanFormat$236:	; £temporary1636 -> doublePtr = *doublePtr
821:		mov a1104, [bp + 57]
823:	

scanFormat$237:	; push float longDoubleValue
824:		fld qword [bp + 47]
826:	

scanFormat$238:	; pop float £temporary1636 -> doublePtr
827:		fstp qword [a1104]
829:	

scanFormat$239:	; goto 258
830:		jmp scanFormat$258
832:	

scanFormat$240:	; if longDouble == 0 goto 250
833:		cmp word [bp + 19], 0
834:		je scanFormat$250
836:	

scanFormat$241:	; arg_list = arg_list + 2
837:		add word [bp + 8], 2
839:	

scanFormat$242:	; £temporary1639 = arg_list - 2
840:		mov a1105, [bp + 8]
841:		sub a1105, 2
843:	

scanFormat$243:	; £temporary1640 = int_to_int £temporary1639 (Signed_Int -> Pointer)
846:	

scanFormat$244:	; £temporary1641 -> £temporary1640 = *£temporary1640
848:	

scanFormat$245:	; longDoublePtr = £temporary1641 -> £temporary1640
849:		mov t1106, [a1105]
850:		mov [bp + 57], t1106
852:	

scanFormat$246:	; £temporary1642 -> longDoublePtr = *longDoublePtr
853:		mov a1107, [bp + 57]
855:	

scanFormat$247:	; push float longDoubleValue
856:		fld qword [bp + 47]
858:	

scanFormat$248:	; pop float £temporary1642 -> longDoublePtr
859:		fstp qword [a1107]
861:	

scanFormat$249:	; goto 258
862:		jmp scanFormat$258
864:	

scanFormat$250:	; arg_list = arg_list + 2
865:		add word [bp + 8], 2
867:	

scanFormat$251:	; £temporary1644 = arg_list - 2
868:		mov a1108, [bp + 8]
869:		sub a1108, 2
871:	

scanFormat$252:	; £temporary1645 = int_to_int £temporary1644 (Signed_Int -> Pointer)
874:	

scanFormat$253:	; £temporary1646 -> £temporary1645 = *£temporary1645
876:	

scanFormat$254:	; floatPtr = £temporary1646 -> £temporary1645
877:		mov t1109, [a1108]
878:		mov [bp + 57], t1109
880:	

scanFormat$255:	; £temporary1647 -> floatPtr = *floatPtr
881:		mov a1110, [bp + 57]
883:	

scanFormat$256:	; push float longDoubleValue
884:		fld qword [bp + 47]
886:	

scanFormat$257:	; pop float £temporary1647 -> floatPtr
887:		fstp dword [a1110]
889:	

scanFormat$258:	; percent = 0
890:		mov word [bp + 13], 0
892:	

scanFormat$259:	; goto 323
893:		jmp scanFormat$323
895:	

scanFormat$260:	; not = 0
896:		mov word [bp + 57], 0
898:	

scanFormat$261:	; ++index
899:		inc word [bp + 31]
901:	

scanFormat$262:	; £temporary1653 = format + index
902:		mov a1111, [bp + 6]
903:		add a1111, [bp + 31]
905:	

scanFormat$263:	; £temporary1652 -> £temporary1653 = *£temporary1653
907:	

scanFormat$264:	; if £temporary1652 -> £temporary1653 != 94 goto 267
908:		cmp byte [a1111], 94
909:		jne scanFormat$267
911:	

scanFormat$265:	; not = 1
912:		mov word [bp + 57], 1
914:	

scanFormat$266:	; startIndex = index + 1
915:		mov a1112, [bp + 31]
916:		add a1112, 1
917:		mov [bp + 59], a1112
919:	

scanFormat$267:	; £temporary1657 = format + index
920:		mov a1113, [bp + 6]
921:		add a1113, [bp + 31]
923:	

scanFormat$268:	; £temporary1656 -> £temporary1657 = *£temporary1657
925:	

scanFormat$269:	; if £temporary1656 -> £temporary1657 == 93 goto 272
926:		cmp byte [a1113], 93
927:		je scanFormat$272
929:	

scanFormat$270:	; ++index
930:		inc word [bp + 31]
932:	

scanFormat$271:	; goto 267
933:		jmp scanFormat$267
935:	

scanFormat$272:	; £temporary1661 = format + index
936:		mov a1114, [bp + 6]
937:		add a1114, [bp + 31]
939:	

scanFormat$273:	; £temporary1660 -> £temporary1661 = *£temporary1661
941:	

scanFormat$274:	; £temporary1660 -> £temporary1661 = 0
942:		mov byte [a1114], 0
944:	

scanFormat$275:	; if star != 0 goto 291
945:		cmp word [bp + 21], 0
946:		jne scanFormat$291
948:	

scanFormat$276:	; arg_list = arg_list + 2
949:		add word [bp + 8], 2
951:	

scanFormat$277:	; £temporary1665 = arg_list - 2
952:		mov a1115, [bp + 8]
953:		sub a1115, 2
955:	

scanFormat$278:	; £temporary1666 = int_to_int £temporary1665 (Signed_Int -> Pointer)
958:	

scanFormat$279:	; £temporary1667 -> £temporary1666 = *£temporary1666
960:	

scanFormat$280:	; string = £temporary1667 -> £temporary1666
961:		mov t1116, [a1115]
962:		mov [bp + 61], t1116
964:	

scanFormat$281:	; call header integral zero 0 stack zero 0
966:	

scanFormat$282:	; parameter string, offset 6
967:		mov a1117, [bp + 61]
968:		mov [bp + 69], a1117
970:	

scanFormat$283:	; £temporary1669 = format + startIndex
971:		mov a1118, [bp + 6]
972:		add a1118, [bp + 59]
974:	

scanFormat$284:	; £temporary1668 -> £temporary1669 = *£temporary1669
976:	

scanFormat$285:	; £temporary1670 = &£temporary1668 -> £temporary1669
978:	

scanFormat$286:	; parameter £temporary1670, offset 8
979:		mov [bp + 71], a1118
981:	

scanFormat$287:	; parameter not, offset 10
982:		mov a1119, [bp + 57]
983:		mov [bp + 73], a1119
985:	

scanFormat$288:	; call function noellipse-noellipse scanPattern
986:		mov word [bp + 63], scanFormat$289
987:		mov [bp + 65], bp
988:		add bp, 63
989:		jmp scanPattern
991:	

scanFormat$289:	; post call
993:	

scanFormat$290:	; goto 323
994:		jmp scanFormat$323
996:	

scanFormat$291:	; call header integral zero 0 stack zero 0
998:	

scanFormat$292:	; parameter 0, offset 6
999:		mov word [bp + 67], 0
1001:	

scanFormat$293:	; £temporary1673 = format + startIndex
1002:		mov a1120, [bp + 6]
1003:		add a1120, [bp + 59]
1005:	

scanFormat$294:	; £temporary1672 -> £temporary1673 = *£temporary1673
1007:	

scanFormat$295:	; £temporary1674 = &£temporary1672 -> £temporary1673
1009:	

scanFormat$296:	; parameter £temporary1674, offset 8
1010:		mov [bp + 69], a1120
1012:	

scanFormat$297:	; parameter not, offset 10
1013:		mov a1121, [bp + 57]
1014:		mov [bp + 71], a1121
1016:	

scanFormat$298:	; call function noellipse-noellipse scanPattern
1017:		mov word [bp + 61], scanFormat$299
1018:		mov [bp + 63], bp
1019:		add bp, 61
1020:		jmp scanPattern
1022:	

scanFormat$299:	; post call
1024:	

scanFormat$300:	; goto 323
1025:		jmp scanFormat$323
1027:	

scanFormat$301:	; arg_list = arg_list + 2
1028:		add word [bp + 8], 2
1030:	

scanFormat$302:	; £temporary1677 = arg_list - 2
1031:		mov a1122, [bp + 8]
1032:		sub a1122, 2
1034:	

scanFormat$303:	; £temporary1678 = int_to_int £temporary1677 (Signed_Int -> Pointer)
1037:	

scanFormat$304:	; £temporary1679 -> £temporary1678 = *£temporary1678
1039:	

scanFormat$305:	; charsPtr = £temporary1679 -> £temporary1678
1040:		mov t1123, [a1122]
1041:		mov [bp + 35], t1123
1043:	

scanFormat$306:	; £temporary1680 -> charsPtr = *charsPtr
1044:		mov a1124, [bp + 35]
1046:	

scanFormat$307:	; £temporary1680 -> charsPtr = g_inChars
1047:		mov a1125, [g_inChars]
1048:		mov [a1124], a1125
1050:	

scanFormat$308:	; percent = 0
1051:		mov word [bp + 13], 0
1053:	

scanFormat$309:	; goto 323
1054:		jmp scanFormat$323
1056:	

scanFormat$310:	; call header integral zero 0 stack zero 0
1058:	

scanFormat$311:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1059:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1061:	

scanFormat$312:	; £temporary1681 = int_to_int c (Signed_Char -> Signed_Int)
1062:		mov a1126, [bp + 10]
1064:		and a1126, 255
1066:		cmp a1126, 0
1067:		jge scanFormat$313
1068:		neg a1126
1070:		neg a1126
1072:	

scanFormat$313:	; parameter £temporary1681, offset 8
1073:		mov [bp + 65], a1126
1075:	

scanFormat$314:	; call function noellipse-ellipse printf, extra 0
1076:		mov word [bp + 57], scanFormat$315
1077:		mov [bp + 59], bp
1078:		add bp, 57
1079:		mov di, bp
1080:		add di, 2
1081:		jmp printf
1083:	

scanFormat$315:	; post call
1085:	

scanFormat$316:	; goto 323
1086:		jmp scanFormat$323
1088:	

scanFormat$317:	; if c != 37 goto 323
1089:		cmp byte [bp + 10], 37
1090:		jne scanFormat$323
1092:	

scanFormat$318:	; percent = 1
1093:		mov word [bp + 13], 1
1095:	

scanFormat$319:	; shortInt = 0
1096:		mov word [bp + 15], 0
1098:	

scanFormat$320:	; longIntOrDouble = 0
1099:		mov word [bp + 17], 0
1101:	

scanFormat$321:	; longDouble = 0
1102:		mov word [bp + 19], 0
1104:	

scanFormat$322:	; star = 0
1105:		mov word [bp + 21], 0
1107:	

scanFormat$323:	; ++index
1108:		inc word [bp + 31]
1110:	

scanFormat$324:	; goto 8
1111:		jmp scanFormat$8
1113:	

scanFormat$325:	; return_value = g_inCount
1114:		mov a1127, [g_inCount]
1116:	

scanFormat$326:	; return
1117:		mov t1128, [bp]
1118:		mov di, [bp + 4]
1119:		mov bp, [bp + 2]
1120:		jmp t1128
1122:	

scanFormat$327:	; function end scanFormat
1:	

scanf:	; £temporary1700 = &format
2:		mov t1129, bp
3:		add t1129, 6
5:	

scanf$1:	; £temporary1701 = int_to_int £temporary1700 (Pointer -> Pointer)
8:	

scanf$2:	; arg_list = £temporary1701 + 2
9:		add t1129, 2
10:		mov [di + 8], t1129
12:	

scanf$3:	; call header integral zero 0 stack zero 0
14:	

scanf$4:	; parameter format, offset 6
15:		mov a1130, [bp + 6]
16:		mov [di + 16], a1130
18:	

scanf$5:	; parameter arg_list, offset 8
19:		mov a1131, [di + 8]
20:		mov [di + 18], a1131
22:	

scanf$6:	; call function ellipse-noellipse vscanf
23:		mov word [di + 10], scanf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vscanf
30:	

scanf$7:	; post call
32:	

scanf$8:	; £temporary1703 = return_value
37:	

scanf$9:	; return_value = £temporary1703
39:	

scanf$10:	; return
40:		mov t1134, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t1134
45:	

scanf$11:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov a1135, [stdin]
5:		mov [bp + 16], a1135
7:	

vscanf$2:	; parameter format, offset 8
8:		mov a1136, [bp + 6]
9:		mov [bp + 18], a1136
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov a1137, [bp + 8]
13:		mov [bp + 20], a1137
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1707 = return_value
28:	

vscanf$7:	; return_value = £temporary1707
30:	

vscanf$8:	; return
31:		mov t1140, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp t1140
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1711 = &format
2:		mov t1141, bp
3:		add t1141, 8
5:	

fscanf$1:	; £temporary1712 = int_to_int £temporary1711 (Pointer -> Pointer)
8:	

fscanf$2:	; arg_list = £temporary1712 + 2
9:		add t1141, 2
10:		mov [di + 10], t1141
12:	

fscanf$3:	; call header integral zero 0 stack zero 0
14:	

fscanf$4:	; parameter inStream, offset 6
15:		mov a1142, [bp + 6]
16:		mov [di + 18], a1142
18:	

fscanf$5:	; parameter format, offset 8
19:		mov a1143, [bp + 8]
20:		mov [di + 20], a1143
22:	

fscanf$6:	; parameter arg_list, offset 10
23:		mov a1144, [di + 10]
24:		mov [di + 22], a1144
26:	

fscanf$7:	; call function ellipse-noellipse vfscanf
27:		mov word [di + 12], fscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfscanf
34:	

fscanf$8:	; post call
36:	

fscanf$9:	; £temporary1714 = return_value
41:	

fscanf$10:	; return_value = £temporary1714
43:	

fscanf$11:	; return
44:		mov t1147, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1147
49:	

fscanf$12:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1719 = int_to_int inStream (Pointer -> Pointer)
5:		mov a1148, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1719
9:		mov [g_inDevice], a1148
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov a1149, [bp + 8]
15:		mov [bp + 18], a1149
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov a1150, [bp + 10]
19:		mov [bp + 20], a1150
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1720 = return_value
34:	

vfscanf$9:	; return_value = £temporary1720
36:	

vfscanf$10:	; return
37:		mov t1153, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1153
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1723 = &format
2:		mov t1154, bp
3:		add t1154, 8
5:	

sscanf$1:	; £temporary1724 = int_to_int £temporary1723 (Pointer -> Pointer)
8:	

sscanf$2:	; arg_list = £temporary1724 + 2
9:		add t1154, 2
10:		mov [di + 10], t1154
12:	

sscanf$3:	; call header integral zero 0 stack zero 0
14:	

sscanf$4:	; parameter inString, offset 6
15:		mov a1155, [bp + 6]
16:		mov [di + 18], a1155
18:	

sscanf$5:	; parameter format, offset 8
19:		mov a1156, [bp + 8]
20:		mov [di + 20], a1156
22:	

sscanf$6:	; parameter arg_list, offset 10
23:		mov a1157, [di + 10]
24:		mov [di + 22], a1157
26:	

sscanf$7:	; call function ellipse-noellipse vsscanf
27:		mov word [di + 12], sscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsscanf
34:	

sscanf$8:	; post call
36:	

sscanf$9:	; £temporary1726 = return_value
41:	

sscanf$10:	; return_value = £temporary1726
43:	

sscanf$11:	; return
44:		mov t1160, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1160
49:	

sscanf$12:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1731 = int_to_int inString (Pointer -> Pointer)
5:		mov a1161, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1731
9:		mov [g_inDevice], a1161
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov a1162, [bp + 8]
15:		mov [bp + 18], a1162
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov a1163, [bp + 10]
19:		mov [bp + 20], a1163
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1732 = return_value
34:	

vsscanf$9:	; return_value = £temporary1732
36:	

vsscanf$10:	; return
37:		mov t1166, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1166
42:	

vsscanf$11:	; function end vsscanf
