1:	

filecreate:	; AssignRegister ah 60
2:		mov ah, 60
4:	

filecreate$1:	; AssignRegister cx 0
5:		mov cx, 0
7:	

filecreate$2:	; AssignRegister dx name
8:		mov dx, [bp + 6]
10:	

filecreate$3:	; Interrupt 33
11:		int 33
13:	

filecreate$4:	; InspectRegister £temporary673 ax
15:	

filecreate$5:	; Assign handle £temporary673
16:		mov [bp + 8], ax
18:	

filecreate$6:	; NotCarry 10
19:		jnc filecreate$10
21:	

filecreate$7:	; Assign errno 9
22:		mov word [errno], 9
24:	

filecreate$8:	; SetReturnValue -1
25:		mov bx, -1
27:	

filecreate$9:	; Return -1
28:		mov ax, [bp]
29:		mov di, [bp + 4]
30:		mov bp, [bp + 2]
31:		jmp ax
33:	

filecreate$10:	; SetReturnValue handle
34:		mov bx, [bp + 8]
36:	

filecreate$11:	; Return handle
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

filecreate$12:	; FunctionEnd filecreate
1:	

fileexistsX:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

fileexistsX$1:	; Parameter 8 name 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

fileexistsX$2:	; Parameter 8 string_r# 8
8:		mov word [bp + 16], @1651$string_r#
10:	

fileexistsX$3:	; Call 8 fopen 0
11:		mov word [bp + 8], fileexistsX$4
12:		mov [bp + 10], bp
13:		add bp, 8
14:		jmp fopen
16:	

fileexistsX$4:	; PostCall 8
18:	

fileexistsX$5:	; GetReturnValue £temporary675
23:	

fileexistsX$6:	; Assign filePtr £temporary675
24:		mov [bp + 8], bx
26:	

fileexistsX$7:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
28:	

fileexistsX$8:	; Parameter 10 string_0Afileexists2025s2025p0A# 6
29:		mov word [bp + 16], @1654$string_0Afileexists2025s2025p0A#
31:	

fileexistsX$9:	; Parameter 10 name 8
32:		mov ax, [bp + 6]
33:		mov [bp + 18], ax
35:	

fileexistsX$10:	; Parameter 10 filePtr 10
36:		mov ax, [bp + 8]
37:		mov [bp + 20], ax
39:	

fileexistsX$11:	; Call 10 printf 0
40:		mov word [bp + 10], fileexistsX$12
41:		mov [bp + 12], bp
42:		add bp, 10
43:		mov di, bp
44:		add di, 4
45:		jmp printf
47:	

fileexistsX$12:	; PostCall 10
49:	

fileexistsX$13:	; Equal 20 filePtr 0
50:		cmp word [bp + 8], 0
51:		je fileexistsX$20
53:	

fileexistsX$14:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
55:	

fileexistsX$15:	; Parameter 10 filePtr 6
56:		mov ax, [bp + 8]
57:		mov [bp + 16], ax
59:	

fileexistsX$16:	; Call 10 fclose 0
60:		mov word [bp + 10], fileexistsX$17
61:		mov [bp + 12], bp
62:		add bp, 10
63:		jmp fclose
65:	

fileexistsX$17:	; PostCall 10
67:	

fileexistsX$18:	; SetReturnValue 1
68:		mov bx, 1
70:	

fileexistsX$19:	; Return 1
71:		mov ax, [bp]
72:		mov di, [bp + 4]
73:		mov bp, [bp + 2]
74:		jmp ax
76:	

fileexistsX$20:	; SetReturnValue 0
77:		mov bx, 0
79:	

fileexistsX$21:	; Return 0
80:		mov ax, [bp]
81:		mov di, [bp + 4]
82:		mov bp, [bp + 2]
83:		jmp ax
85:	

fileexistsX$22:	; FunctionEnd fileexistsX
1:	

fileexists:	; AssignRegister ah 67
2:		mov ah, 67
4:	

fileexists$1:	; AssignRegister al 0
5:		mov al, 0
7:	

fileexists$2:	; AssignRegister dx name
8:		mov dx, [bp + 6]
10:	

fileexists$3:	; Interrupt 33
11:		int 33
13:	

fileexists$4:	; Carry 7
14:		jc fileexists$7
16:	

fileexists$5:	; Assign £temporary690 1
17:		mov bx, 1
19:	

fileexists$6:	; Goto 8
20:		jmp fileexists$8
22:	

fileexists$7:	; Assign £temporary690 0
23:		mov bx, 0
25:	

fileexists$8:	; SetReturnValue £temporary690
27:	

fileexists$9:	; Return £temporary690
28:		mov ax, [bp]
29:		mov di, [bp + 4]
30:		mov bp, [bp + 2]
31:		jmp ax
33:	

fileexists$10:	; FunctionEnd fileexists
1:	

@1685$fileopen:	; AssignRegister ah 61
2:		mov ah, 61
4:	

@1685$fileopen$1:	; AssignRegister al mode
5:		mov al, [bp + 8]
7:	

@1685$fileopen$2:	; AssignRegister dx name
8:		mov dx, [bp + 6]
10:	

@1685$fileopen$3:	; Interrupt 33
11:		int 33
13:	

@1685$fileopen$4:	; NotCarry 8
14:		jnc @1685$fileopen$8
16:	

@1685$fileopen$5:	; Assign errno 9
17:		mov word [errno], 9
19:	

@1685$fileopen$6:	; SetReturnValue -1
20:		mov bx, -1
22:	

@1685$fileopen$7:	; Return -1
23:		mov ax, [bp]
24:		mov di, [bp + 4]
25:		mov bp, [bp + 2]
26:		jmp ax
28:	

@1685$fileopen$8:	; InspectRegister £temporary695 ax
30:	

@1685$fileopen$9:	; SetReturnValue £temporary695
31:		mov bx, ax
33:	

@1685$fileopen$10:	; Return £temporary695
34:		mov ax, [bp]
35:		mov di, [bp + 4]
36:		mov bp, [bp + 2]
37:		jmp ax
39:	

@1685$fileopen$11:	; FunctionEnd fileopen
1:	

fopen:	; Assign index 0
2:		mov word [bp + 10], 0
4:	

fopen$1:	; SignedGreaterThanEqual 21 index 20
5:		cmp word [bp + 10], 20
6:		jge fopen$21
8:	

fopen$2:	; UnsignedMultiply £temporary699 index 29
9:		mov ax, [bp + 10]
11:		xor dx, dx
12:		mul word [@1707$int2$29#]
18:	

fopen$3:	; BinaryAdd £temporary700 g_fileArray £temporary699
19:		mov si, g_fileArray
20:		add si, ax
22:	

fopen$4:	; Deref £temporary698 -> £temporary700 £temporary700 0
24:	

fopen$5:	; NotEqual 19 £temporary698.open$0 -> £temporary700 0
25:		cmp word [si], 0
26:		jne fopen$19
28:	

fopen$6:	; CallHeader 12 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
30:	

fopen$7:	; Parameter 12 name 6
31:		mov ax, [bp + 6]
32:		mov [bp + 18], ax
34:	

fopen$8:	; Parameter 12 mode 8
35:		mov ax, [bp + 8]
36:		mov [bp + 20], ax
38:	

fopen$9:	; UnsignedMultiply £temporary704 index 29
39:		mov ax, [bp + 10]
41:		xor dx, dx
42:		mul word [@1715$int2$29#]
48:	

fopen$10:	; BinaryAdd £temporary705 g_fileArray £temporary704
49:		mov si, g_fileArray
50:		add si, ax
52:	

fopen$11:	; Deref £temporary703 -> £temporary705 £temporary705 0
54:	

fopen$12:	; address £temporary706 £temporary703 -> £temporary705
56:	

fopen$13:	; Parameter 12 £temporary706 10
57:		mov [bp + 22], si
59:	

fopen$14:	; Call 12 freopen 0
60:		mov word [bp + 12], fopen$15
61:		mov [bp + 14], bp
62:		add bp, 12
63:		jmp freopen
65:	

fopen$15:	; PostCall 12
67:	

fopen$16:	; GetReturnValue £temporary707
72:	

fopen$17:	; SetReturnValue £temporary707
74:	

fopen$18:	; Return £temporary707
75:		mov ax, [bp]
76:		mov di, [bp + 4]
77:		mov bp, [bp + 2]
78:		jmp ax
80:	

fopen$19:	; Increment index
81:		inc word [bp + 10]
83:	

fopen$20:	; Goto 1
84:		jmp fopen$1
86:	

fopen$21:	; SetReturnValue 0
87:		mov bx, 0
89:	

fopen$22:	; Return 0
90:		mov ax, [bp]
91:		mov di, [bp + 4]
92:		mov bp, [bp + 2]
93:		jmp ax
95:	

fopen$23:	; FunctionEnd fopen
1:	

freopen:	; Assign handle -1
2:		mov word [bp + 12], -1
4:	

freopen$1:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
6:	

freopen$2:	; Parameter 14 mode 6
7:		mov ax, [bp + 8]
8:		mov [bp + 20], ax
10:	

freopen$3:	; Parameter 14 string_r# 8
11:		mov word [bp + 22], @1730$string_r#
13:	

freopen$4:	; Call 14 strcmp 0
14:		mov word [bp + 14], freopen$5
15:		mov [bp + 16], bp
16:		add bp, 14
17:		jmp strcmp
19:	

freopen$5:	; PostCall 14
21:	

freopen$6:	; GetReturnValue £temporary711
26:	

freopen$7:	; NotEqual 16 £temporary711 0
27:		cmp bx, 0
28:		jne freopen$16
30:	

freopen$8:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
32:	

freopen$9:	; Parameter 14 name 6
33:		mov ax, [bp + 6]
34:		mov [bp + 20], ax
36:	

freopen$10:	; Parameter 14 64 8
37:		mov byte [bp + 22], 64
39:	

freopen$11:	; Call 14 fileopen 0
40:		mov word [bp + 14], freopen$12
41:		mov [bp + 16], bp
42:		add bp, 14
43:		jmp @1685$fileopen
45:	

freopen$12:	; PostCall 14
47:	

freopen$13:	; GetReturnValue £temporary713
52:	

freopen$14:	; Assign handle £temporary713
53:		mov [bp + 12], bx
55:	

freopen$15:	; Goto 130
56:		jmp freopen$130
58:	

freopen$16:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
60:	

freopen$17:	; Parameter 14 mode 6
61:		mov ax, [bp + 8]
62:		mov [bp + 20], ax
64:	

freopen$18:	; Parameter 14 string_w# 8
65:		mov word [bp + 22], @1738$string_w#
67:	

freopen$19:	; Call 14 strcmp 0
68:		mov word [bp + 14], freopen$20
69:		mov [bp + 16], bp
70:		add bp, 14
71:		jmp strcmp
73:	

freopen$20:	; PostCall 14
75:	

freopen$21:	; GetReturnValue £temporary714
80:	

freopen$22:	; NotEqual 30 £temporary714 0
81:		cmp bx, 0
82:		jne freopen$30
84:	

freopen$23:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
86:	

freopen$24:	; Parameter 14 name 6
87:		mov ax, [bp + 6]
88:		mov [bp + 20], ax
90:	

freopen$25:	; Call 14 filecreate 0
91:		mov word [bp + 14], freopen$26
92:		mov [bp + 16], bp
93:		add bp, 14
94:		jmp filecreate
96:	

freopen$26:	; PostCall 14
98:	

freopen$27:	; GetReturnValue £temporary716
103:	

freopen$28:	; Assign handle £temporary716
104:		mov [bp + 12], bx
106:	

freopen$29:	; Goto 130
107:		jmp freopen$130
109:	

freopen$30:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
111:	

freopen$31:	; Parameter 14 mode 6
112:		mov ax, [bp + 8]
113:		mov [bp + 20], ax
115:	

freopen$32:	; Parameter 14 string_a# 8
116:		mov word [bp + 22], @1744$string_a#
118:	

freopen$33:	; Call 14 strcmp 0
119:		mov word [bp + 14], freopen$34
120:		mov [bp + 16], bp
121:		add bp, 14
122:		jmp strcmp
124:	

freopen$34:	; PostCall 14
126:	

freopen$35:	; GetReturnValue £temporary717
131:	

freopen$36:	; NotEqual 59 £temporary717 0
132:		cmp bx, 0
133:		jne freopen$59
135:	

freopen$37:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
137:	

freopen$38:	; Parameter 14 name 6
138:		mov ax, [bp + 6]
139:		mov [bp + 20], ax
141:	

freopen$39:	; Parameter 14 65 8
142:		mov byte [bp + 22], 65
144:	

freopen$40:	; Call 14 fileopen 0
145:		mov word [bp + 14], freopen$41
146:		mov [bp + 16], bp
147:		add bp, 14
148:		jmp @1685$fileopen
150:	

freopen$41:	; PostCall 14
152:	

freopen$42:	; GetReturnValue £temporary719
157:	

freopen$43:	; Assign handle £temporary719
158:		mov [bp + 12], bx
160:	

freopen$44:	; Equal 52 handle -1
161:		cmp word [bp + 12], -1
162:		je freopen$52
164:	

freopen$45:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
166:	

freopen$46:	; Parameter 14 stream 6
167:		mov ax, [bp + 10]
168:		mov [bp + 20], ax
170:	

freopen$47:	; Parameter 14 0 8
171:		mov word [bp + 22], 0
173:	

freopen$48:	; Parameter 14 2 10
174:		mov word [bp + 24], 2
176:	

freopen$49:	; Call 14 fseek 0
177:		mov word [bp + 14], freopen$50
178:		mov [bp + 16], bp
179:		add bp, 14
180:		jmp fseek
182:	

freopen$50:	; PostCall 14
184:	

freopen$51:	; Goto 130
185:		jmp freopen$130
187:	

freopen$52:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
189:	

freopen$53:	; Parameter 14 name 6
190:		mov ax, [bp + 6]
191:		mov [bp + 20], ax
193:	

freopen$54:	; Call 14 filecreate 0
194:		mov word [bp + 14], freopen$55
195:		mov [bp + 16], bp
196:		add bp, 14
197:		jmp filecreate
199:	

freopen$55:	; PostCall 14
201:	

freopen$56:	; GetReturnValue £temporary722
206:	

freopen$57:	; Assign handle £temporary722
207:		mov [bp + 12], bx
209:	

freopen$58:	; Goto 130
210:		jmp freopen$130
212:	

freopen$59:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
214:	

freopen$60:	; Parameter 14 mode 6
215:		mov ax, [bp + 8]
216:		mov [bp + 20], ax
218:	

freopen$61:	; Parameter 14 string_r2B# 8
219:		mov word [bp + 22], @1761$string_r2B#
221:	

freopen$62:	; Call 14 strcmp 0
222:		mov word [bp + 14], freopen$63
223:		mov [bp + 16], bp
224:		add bp, 14
225:		jmp strcmp
227:	

freopen$63:	; PostCall 14
229:	

freopen$64:	; GetReturnValue £temporary723
234:	

freopen$65:	; NotEqual 74 £temporary723 0
235:		cmp bx, 0
236:		jne freopen$74
238:	

freopen$66:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
240:	

freopen$67:	; Parameter 14 name 6
241:		mov ax, [bp + 6]
242:		mov [bp + 20], ax
244:	

freopen$68:	; Parameter 14 66 8
245:		mov byte [bp + 22], 66
247:	

freopen$69:	; Call 14 fileopen 0
248:		mov word [bp + 14], freopen$70
249:		mov [bp + 16], bp
250:		add bp, 14
251:		jmp @1685$fileopen
253:	

freopen$70:	; PostCall 14
255:	

freopen$71:	; GetReturnValue £temporary725
260:	

freopen$72:	; Assign handle £temporary725
261:		mov [bp + 12], bx
263:	

freopen$73:	; Goto 130
264:		jmp freopen$130
266:	

freopen$74:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
268:	

freopen$75:	; Parameter 14 mode 6
269:		mov ax, [bp + 8]
270:		mov [bp + 20], ax
272:	

freopen$76:	; Parameter 14 string_w2B# 8
273:		mov word [bp + 22], @1769$string_w2B#
275:	

freopen$77:	; Call 14 strcmp 0
276:		mov word [bp + 14], freopen$78
277:		mov [bp + 16], bp
278:		add bp, 14
279:		jmp strcmp
281:	

freopen$78:	; PostCall 14
283:	

freopen$79:	; GetReturnValue £temporary726
288:	

freopen$80:	; NotEqual 102 £temporary726 0
289:		cmp bx, 0
290:		jne freopen$102
292:	

freopen$81:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
294:	

freopen$82:	; Parameter 14 name 6
295:		mov ax, [bp + 6]
296:		mov [bp + 20], ax
298:	

freopen$83:	; Call 14 fileexists 0
299:		mov word [bp + 14], freopen$84
300:		mov [bp + 16], bp
301:		add bp, 14
302:		jmp fileexists
304:	

freopen$84:	; PostCall 14
306:	

freopen$85:	; GetReturnValue £temporary728
311:	

freopen$86:	; Equal 95 £temporary728 0
312:		cmp bx, 0
313:		je freopen$95
315:	

freopen$87:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
317:	

freopen$88:	; Parameter 14 name 6
318:		mov ax, [bp + 6]
319:		mov [bp + 20], ax
321:	

freopen$89:	; Parameter 14 66 8
322:		mov byte [bp + 22], 66
324:	

freopen$90:	; Call 14 fileopen 0
325:		mov word [bp + 14], freopen$91
326:		mov [bp + 16], bp
327:		add bp, 14
328:		jmp @1685$fileopen
330:	

freopen$91:	; PostCall 14
332:	

freopen$92:	; GetReturnValue £temporary729
337:	

freopen$93:	; Assign handle £temporary729
338:		mov [bp + 12], bx
340:	

freopen$94:	; Goto 130
341:		jmp freopen$130
343:	

freopen$95:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
345:	

freopen$96:	; Parameter 14 name 6
346:		mov ax, [bp + 6]
347:		mov [bp + 20], ax
349:	

freopen$97:	; Call 14 filecreate 0
350:		mov word [bp + 14], freopen$98
351:		mov [bp + 16], bp
352:		add bp, 14
353:		jmp filecreate
355:	

freopen$98:	; PostCall 14
357:	

freopen$99:	; GetReturnValue £temporary730
362:	

freopen$100:	; Assign handle £temporary730
363:		mov [bp + 12], bx
365:	

freopen$101:	; Goto 130
366:		jmp freopen$130
368:	

freopen$102:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
370:	

freopen$103:	; Parameter 14 mode 6
371:		mov ax, [bp + 8]
372:		mov [bp + 20], ax
374:	

freopen$104:	; Parameter 14 string_a2B# 8
375:		mov word [bp + 22], @1781$string_a2B#
377:	

freopen$105:	; Call 14 strcmp 0
378:		mov word [bp + 14], freopen$106
379:		mov [bp + 16], bp
380:		add bp, 14
381:		jmp strcmp
383:	

freopen$106:	; PostCall 14
385:	

freopen$107:	; GetReturnValue £temporary732
390:	

freopen$108:	; NotEqual 130 £temporary732 0
391:		cmp bx, 0
392:		jne freopen$130
394:	

freopen$109:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
396:	

freopen$110:	; Parameter 14 name 6
397:		mov ax, [bp + 6]
398:		mov [bp + 20], ax
400:	

freopen$111:	; Parameter 14 66 8
401:		mov byte [bp + 22], 66
403:	

freopen$112:	; Call 14 fileopen 0
404:		mov word [bp + 14], freopen$113
405:		mov [bp + 16], bp
406:		add bp, 14
407:		jmp @1685$fileopen
409:	

freopen$113:	; PostCall 14
411:	

freopen$114:	; GetReturnValue £temporary734
416:	

freopen$115:	; Assign handle £temporary734
417:		mov [bp + 12], bx
419:	

freopen$116:	; Equal 124 handle -1
420:		cmp word [bp + 12], -1
421:		je freopen$124
423:	

freopen$117:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
425:	

freopen$118:	; Parameter 14 stream 6
426:		mov ax, [bp + 10]
427:		mov [bp + 20], ax
429:	

freopen$119:	; Parameter 14 0 8
430:		mov word [bp + 22], 0
432:	

freopen$120:	; Parameter 14 2 10
433:		mov word [bp + 24], 2
435:	

freopen$121:	; Call 14 fseek 0
436:		mov word [bp + 14], freopen$122
437:		mov [bp + 16], bp
438:		add bp, 14
439:		jmp fseek
441:	

freopen$122:	; PostCall 14
443:	

freopen$123:	; Goto 130
444:		jmp freopen$130
446:	

freopen$124:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
448:	

freopen$125:	; Parameter 14 name 6
449:		mov ax, [bp + 6]
450:		mov [bp + 20], ax
452:	

freopen$126:	; Call 14 filecreate 0
453:		mov word [bp + 14], freopen$127
454:		mov [bp + 16], bp
455:		add bp, 14
456:		jmp filecreate
458:	

freopen$127:	; PostCall 14
460:	

freopen$128:	; GetReturnValue £temporary737
465:	

freopen$129:	; Assign handle £temporary737
466:		mov [bp + 12], bx
468:	

freopen$130:	; Equal 147 handle -1
469:		cmp word [bp + 12], -1
470:		je freopen$147
472:	

freopen$131:	; Deref £temporary739 -> stream stream 0
473:		mov si, [bp + 10]
475:	

freopen$132:	; Assign £temporary739 -> stream 1
476:		mov word [si], 1
478:	

freopen$133:	; Deref £temporary740 -> stream stream 2
479:		mov si, [bp + 10]
481:	

freopen$134:	; Assign £temporary740 -> stream handle
482:		mov ax, [bp + 12]
483:		mov [si + 2], ax
485:	

freopen$135:	; Deref £temporary741 -> stream stream 25
486:		mov si, [bp + 10]
488:	

freopen$136:	; Assign £temporary741 -> stream 0
489:		mov word [si + 25], 0
491:	

freopen$137:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
493:	

freopen$138:	; Deref £temporary742 -> stream stream 4
494:		mov si, [bp + 10]
496:	

freopen$139:	; Parameter 14 £temporary742 -> stream 6
497:		mov [bp + 20], si
498:		add word [bp + 20], 4
500:	

freopen$140:	; Parameter 14 name 8
501:		mov ax, [bp + 6]
502:		mov [bp + 22], ax
504:	

freopen$141:	; Call 14 strcpy 0
505:		mov word [bp + 14], freopen$142
506:		mov [bp + 16], bp
507:		add bp, 14
508:		jmp strcpy
510:	

freopen$142:	; PostCall 14
512:	

freopen$143:	; Deref £temporary744 -> stream stream 27
513:		mov si, [bp + 10]
515:	

freopen$144:	; Assign £temporary744 -> stream 0
516:		mov word [si + 27], 0
518:	

freopen$145:	; SetReturnValue stream
519:		mov bx, [bp + 10]
521:	

freopen$146:	; Return stream
522:		mov ax, [bp]
523:		mov di, [bp + 4]
524:		mov bp, [bp + 2]
525:		jmp ax
527:	

freopen$147:	; Deref £temporary745 -> stream stream 0
528:		mov si, [bp + 10]
530:	

freopen$148:	; Assign £temporary745 -> stream 0
531:		mov word [si], 0
533:	

freopen$149:	; SetReturnValue 0
534:		mov bx, 0
536:	

freopen$150:	; Return 0
537:		mov ax, [bp]
538:		mov di, [bp + 4]
539:		mov bp, [bp + 2]
540:		jmp ax
542:	

freopen$151:	; FunctionEnd freopen
1:	

fflush:	; NotEqual 21 stream 0
2:		cmp word [bp + 6], 0
3:		jne fflush$21
5:	

fflush$1:	; Assign index 0
6:		mov word [bp + 8], 0
8:	

fflush$2:	; SignedGreaterThanEqual 21 index 20
9:		cmp word [bp + 8], 20
10:		jge fflush$21
12:	

fflush$3:	; UnsignedMultiply £temporary785 index 29
13:		mov ax, [bp + 8]
15:		xor dx, dx
16:		mul word [@1868$int2$29#]
22:	

fflush$4:	; BinaryAdd £temporary786 g_fileArray £temporary785
23:		mov si, g_fileArray
24:		add si, ax
26:	

fflush$5:	; Deref £temporary784 -> £temporary786 £temporary786 0
28:	

fflush$6:	; Equal 19 £temporary784.open$0 -> £temporary786 0
29:		cmp word [si], 0
30:		je fflush$19
32:	

fflush$7:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
34:	

fflush$8:	; UnsignedMultiply £temporary788 index 29
35:		mov ax, [bp + 8]
37:		xor dx, dx
38:		mul word [@1873$int2$29#]
44:	

fflush$9:	; BinaryAdd £temporary789 g_fileArray £temporary788
45:		mov si, g_fileArray
46:		add si, ax
48:	

fflush$10:	; Deref £temporary787 -> £temporary789 £temporary789 0
50:	

fflush$11:	; address £temporary790 £temporary787 -> £temporary789
52:	

fflush$12:	; Parameter 10 £temporary790 6
53:		mov [bp + 16], si
55:	

fflush$13:	; Call 10 fflush 0
56:		mov word [bp + 10], fflush$14
57:		mov [bp + 12], bp
58:		add bp, 10
59:		jmp fflush
61:	

fflush$14:	; PostCall 10
63:	

fflush$15:	; GetReturnValue £temporary791
68:	

fflush$16:	; NotEqual 19 £temporary791 -1
69:		cmp bx, -1
70:		jne fflush$19
72:	

fflush$17:	; SetReturnValue -1
73:		mov bx, -1
75:	

fflush$18:	; Return -1
76:		mov ax, [bp]
77:		mov di, [bp + 4]
78:		mov bp, [bp + 2]
79:		jmp ax
81:	

fflush$19:	; Increment index
82:		inc word [bp + 8]
84:	

fflush$20:	; Goto 2
85:		jmp fflush$2
87:	

fflush$21:	; SetReturnValue 0
88:		mov bx, 0
90:	

fflush$22:	; Return 0
91:		mov ax, [bp]
92:		mov di, [bp + 4]
93:		mov bp, [bp + 2]
94:		jmp ax
96:	

fflush$23:	; FunctionEnd fflush
1:	

fclose:	; Equal 20 stream 0
2:		cmp word [bp + 6], 0
3:		je fclose$20
5:	

fclose$1:	; AssignRegister ah 62
6:		mov ah, 62
8:	

fclose$2:	; Deref £temporary798 -> stream stream 2
9:		mov si, [bp + 6]
11:	

fclose$3:	; AssignRegister bx £temporary798 -> stream
12:		mov bx, [si + 2]
14:	

fclose$4:	; Interrupt 33
15:		int 33
17:	

fclose$5:	; NotCarry 9
18:		jnc fclose$9
20:	

fclose$6:	; Assign errno 11
21:		mov word [errno], 11
23:	

fclose$7:	; SetReturnValue -1
24:		mov bx, -1
26:	

fclose$8:	; Return -1
27:		mov ax, [bp]
28:		mov di, [bp + 4]
29:		mov bp, [bp + 2]
30:		jmp ax
32:	

fclose$9:	; Deref £temporary800 -> stream stream 27
33:		mov si, [bp + 6]
35:	

fclose$10:	; Equal 16 £temporary800 -> stream 0
36:		cmp word [si + 27], 0
37:		je fclose$16
39:	

fclose$11:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
41:	

fclose$12:	; Deref £temporary801 -> stream stream 4
42:		mov si, [bp + 6]
44:	

fclose$13:	; Parameter 8 £temporary801 -> stream 6
45:		mov [bp + 14], si
46:		add word [bp + 14], 4
48:	

fclose$14:	; Call 8 remove 0
49:		mov word [bp + 8], fclose$15
50:		mov [bp + 10], bp
51:		add bp, 8
52:		jmp remove
54:	

fclose$15:	; PostCall 8
56:	

fclose$16:	; Deref £temporary804 -> stream stream 0
57:		mov si, [bp + 6]
59:	

fclose$17:	; Assign £temporary804 -> stream 0
60:		mov word [si], 0
62:	

fclose$18:	; SetReturnValue 0
63:		mov bx, 0
65:	

fclose$19:	; Return 0
66:		mov ax, [bp]
67:		mov di, [bp + 4]
68:		mov bp, [bp + 2]
69:		jmp ax
71:	

fclose$20:	; Assign index 0
72:		mov word [bp + 8], 0
74:	

fclose$21:	; SignedGreaterThanEqual 40 index 20
75:		cmp word [bp + 8], 20
76:		jge fclose$40
78:	

fclose$22:	; UnsignedMultiply £temporary808 index 29
79:		mov ax, [bp + 8]
81:		xor dx, dx
82:		mul word [@1922$int2$29#]
88:	

fclose$23:	; BinaryAdd £temporary809 g_fileArray £temporary808
89:		mov si, g_fileArray
90:		add si, ax
92:	

fclose$24:	; Deref £temporary807 -> £temporary809 £temporary809 0
94:	

fclose$25:	; Equal 38 £temporary807.open$0 -> £temporary809 0
95:		cmp word [si], 0
96:		je fclose$38
98:	

fclose$26:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
100:	

fclose$27:	; UnsignedMultiply £temporary811 index 29
101:		mov ax, [bp + 8]
103:		xor dx, dx
104:		mul word [@1927$int2$29#]
110:	

fclose$28:	; BinaryAdd £temporary812 g_fileArray £temporary811
111:		mov si, g_fileArray
112:		add si, ax
114:	

fclose$29:	; Deref £temporary810 -> £temporary812 £temporary812 0
116:	

fclose$30:	; address £temporary813 £temporary810 -> £temporary812
118:	

fclose$31:	; Parameter 10 £temporary813 6
119:		mov [bp + 16], si
121:	

fclose$32:	; Call 10 fclose 0
122:		mov word [bp + 10], fclose$33
123:		mov [bp + 12], bp
124:		add bp, 10
125:		jmp fclose
127:	

fclose$33:	; PostCall 10
129:	

fclose$34:	; GetReturnValue £temporary814
134:	

fclose$35:	; NotEqual 38 £temporary814 -1
135:		cmp bx, -1
136:		jne fclose$38
138:	

fclose$36:	; SetReturnValue -1
139:		mov bx, -1
141:	

fclose$37:	; Return -1
142:		mov ax, [bp]
143:		mov di, [bp + 4]
144:		mov bp, [bp + 2]
145:		jmp ax
147:	

fclose$38:	; Increment index
148:		inc word [bp + 8]
150:	

fclose$39:	; Goto 21
151:		jmp fclose$21
153:	

fclose$40:	; SetReturnValue 0
154:		mov bx, 0
156:	

fclose$41:	; Return 0
157:		mov ax, [bp]
158:		mov di, [bp + 4]
159:		mov bp, [bp + 2]
160:		jmp ax
162:	

fclose$42:	; FunctionEnd fclose
1:	

remove:	; AssignRegister ah 65
2:		mov ah, 65
4:	

remove$1:	; AssignRegister cl 0
5:		mov cl, 0
7:	

remove$2:	; AssignRegister dx name
8:		mov dx, [bp + 6]
10:	

remove$3:	; Interrupt 33
11:		int 33
13:	

remove$4:	; Carry 7
14:		jc remove$7
16:	

remove$5:	; SetReturnValue 0
17:		mov bx, 0
19:	

remove$6:	; Return 0
20:		mov ax, [bp]
21:		mov di, [bp + 4]
22:		mov bp, [bp + 2]
23:		jmp ax
25:	

remove$7:	; Assign errno 18
26:		mov word [errno], 18
28:	

remove$8:	; SetReturnValue -1
29:		mov bx, -1
31:	

remove$9:	; Return -1
32:		mov ax, [bp]
33:		mov di, [bp + 4]
34:		mov bp, [bp + 2]
35:		jmp ax
37:	

remove$10:	; FunctionEnd remove
1:	

rename:	; AssignRegister ah 86
2:		mov ah, 86
4:	

rename$1:	; AssignRegister cl 0
5:		mov cl, 0
7:	

rename$2:	; AssignRegister dx oldName
8:		mov dx, [bp + 6]
10:	

rename$3:	; AssignRegister di newName
11:		mov di, [bp + 8]
13:	

rename$4:	; Interrupt 33
14:		int 33
16:	

rename$5:	; Carry 8
17:		jc rename$8
19:	

rename$6:	; SetReturnValue 0
20:		mov bx, 0
22:	

rename$7:	; Return 0
23:		mov ax, [bp]
24:		mov di, [bp + 4]
25:		mov bp, [bp + 2]
26:		jmp ax
28:	

rename$8:	; Assign errno 19
29:		mov word [errno], 19
31:	

rename$9:	; SetReturnValue -1
32:		mov bx, -1
34:	

rename$10:	; Return -1
35:		mov ax, [bp]
36:		mov di, [bp + 4]
37:		mov bp, [bp + 2]
38:		jmp ax
40:	

rename$11:	; FunctionEnd rename
1:	

setvbuf:	; SetReturnValue 0
2:		mov bx, 0
4:	

setvbuf$1:	; Return 0
5:		mov ax, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp ax
10:	

setvbuf$2:	; FunctionEnd setvbuf
1:	

setbuf:	; Empty
3:	

setbuf$1:	; Return 0
4:		mov ax, [bp]
5:		mov di, [bp + 4]
6:		mov bp, [bp + 2]
7:		jmp ax
9:	

setbuf$2:	; FunctionEnd setbuf
1:	

fgetc:	; Assign c 0
2:		mov byte [bp + 8], 0
4:	

fgetc$1:	; CallHeader 9 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
6:	

fgetc$2:	; address £temporary830 c
7:		mov si, bp
8:		add si, 8
10:	

fgetc$3:	; Parameter 9 £temporary830 6
11:		mov [bp + 15], si
13:	

fgetc$4:	; Parameter 9 1 8
14:		mov word [bp + 17], 1
16:	

fgetc$5:	; Parameter 9 1 10
17:		mov word [bp + 19], 1
19:	

fgetc$6:	; Parameter 9 stream 12
20:		mov ax, [bp + 6]
21:		mov [bp + 21], ax
23:	

fgetc$7:	; Call 9 fread 0
24:		mov word [bp + 9], fgetc$8
25:		mov [bp + 11], bp
26:		add bp, 9
27:		jmp fread
29:	

fgetc$8:	; PostCall 9
31:	

fgetc$9:	; GetReturnValue £temporary831
36:	

fgetc$10:	; SignedLessThanEqual 14 £temporary831 0
37:		cmp bx, 0
38:		jle fgetc$14
40:	

fgetc$11:	; IntegralToIntegral £temporary833 c
41:		mov bl, [bp + 8]
43:		and bx, 255
45:		cmp bl, 0
46:		jge fgetc$12
47:		neg bl
49:		neg bx
51:	

fgetc$12:	; SetReturnValue £temporary833
53:	

fgetc$13:	; Return £temporary833
54:		mov ax, [bp]
55:		mov di, [bp + 4]
56:		mov bp, [bp + 2]
57:		jmp ax
59:	

fgetc$14:	; SetReturnValue -1
60:		mov bx, -1
62:	

fgetc$15:	; Return -1
63:		mov ax, [bp]
64:		mov di, [bp + 4]
65:		mov bp, [bp + 2]
66:		jmp ax
68:	

fgetc$16:	; FunctionEnd fgetc
1:	

fgets:	; Assign count 0
2:		mov word [bp + 12], 0
4:	

fgets$1:	; Assign prevChar 0
5:		mov byte [bp + 14], 0
7:	

fgets$2:	; BinarySubtract £temporary839 size 1
8:		mov ax, [bp + 8]
9:		sub ax, 1
11:	

fgets$3:	; SignedGreaterThanEqual 33 count £temporary839
12:		cmp [bp + 12], ax
13:		jge fgets$33
15:	

fgets$4:	; Assign currChar 0
16:		mov byte [bp + 15], 0
18:	

fgets$5:	; CallHeader 16 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
20:	

fgets$6:	; Parameter 16 stream 6
21:		mov ax, [bp + 10]
22:		mov [bp + 22], ax
24:	

fgets$7:	; Parameter 16 string_25c# 8
25:		mov word [bp + 24], @2013$string_25c#
27:	

fgets$8:	; address £temporary841 currChar
28:		mov si, bp
29:		add si, 15
31:	

fgets$9:	; Parameter 16 £temporary841 10
32:		mov [bp + 26], si
34:	

fgets$10:	; Call 16 fscanf 0
35:		mov word [bp + 16], fgets$11
36:		mov [bp + 18], bp
37:		add bp, 16
38:		mov di, bp
39:		add di, 2
40:		jmp fscanf
42:	

fgets$11:	; PostCall 16
44:	

fgets$12:	; NotEqual 18 prevChar 13
45:		cmp byte [bp + 14], 13
46:		jne fgets$18
48:	

fgets$13:	; NotEqual 18 currChar 10
49:		cmp byte [bp + 15], 10
50:		jne fgets$18
52:	

fgets$14:	; BinaryAdd £temporary847 text count
53:		mov si, [bp + 6]
54:		add si, [bp + 12]
56:	

fgets$15:	; Deref £temporary846 -> £temporary847 £temporary847 0
58:	

fgets$16:	; Assign £temporary846 -> £temporary847 0
59:		mov byte [si], 0
61:	

fgets$17:	; Goto 33
62:		jmp fgets$33
64:	

fgets$18:	; IntegralToIntegral £temporary848 currChar
65:		mov al, [bp + 15]
67:		and ax, 255
69:		cmp al, 0
70:		jge fgets$19
71:		neg al
73:		neg ax
75:	

fgets$19:	; NotEqual 24 £temporary848 -1
76:		cmp ax, -1
77:		jne fgets$24
79:	

fgets$20:	; BinaryAdd £temporary851 text count
80:		mov si, [bp + 6]
81:		add si, [bp + 12]
83:	

fgets$21:	; Deref £temporary850 -> £temporary851 £temporary851 0
85:	

fgets$22:	; Assign £temporary850 -> £temporary851 0
86:		mov byte [si], 0
88:	

fgets$23:	; Goto 33
89:		jmp fgets$33
91:	

fgets$24:	; Equal 31 currChar 13
92:		cmp byte [bp + 15], 13
93:		je fgets$31
95:	

fgets$25:	; Equal 31 currChar 10
96:		cmp byte [bp + 15], 10
97:		je fgets$31
99:	

fgets$26:	; Assign £temporary855 count
100:		mov ax, [bp + 12]
102:	

fgets$27:	; Increment count
103:		inc word [bp + 12]
105:	

fgets$28:	; BinaryAdd £temporary857 text £temporary855
106:		mov si, [bp + 6]
107:		add si, ax
109:	

fgets$29:	; Deref £temporary856 -> £temporary857 £temporary857 0
111:	

fgets$30:	; Assign £temporary856 -> £temporary857 currChar
112:		mov al, [bp + 15]
113:		mov [si], al
115:	

fgets$31:	; Assign prevChar currChar
116:		mov al, [bp + 15]
117:		mov [bp + 14], al
119:	

fgets$32:	; Goto 2
120:		jmp fgets$2
122:	

fgets$33:	; SetReturnValue text
123:		mov bx, [bp + 6]
125:	

fgets$34:	; Return text
126:		mov ax, [bp]
127:		mov di, [bp + 4]
128:		mov bp, [bp + 2]
129:		jmp ax
131:	

fgets$35:	; FunctionEnd fgets
1:	

fputs:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

fputs$1:	; Parameter 10 s 6
4:		mov ax, [bp + 6]
5:		mov [bp + 16], ax
7:	

fputs$2:	; Call 10 strlen 0
8:		mov word [bp + 10], fputs$3
9:		mov [bp + 12], bp
10:		add bp, 10
11:		jmp strlen
13:	

fputs$3:	; PostCall 10
15:	

fputs$4:	; GetReturnValue £temporary862
20:	

fputs$5:	; BinaryAdd £temporary863 £temporary862 1
21:		add bx, 1
23:	

fputs$6:	; SignedMultiply size £temporary863 1
24:		mov ax, bx
26:		xor dx, dx
27:		imul word [@2056$int2$1#]
28:		mov [bp + 10], ax
30:	

fputs$7:	; CallHeader 12 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
32:	

fputs$8:	; Parameter 12 s 6
33:		mov ax, [bp + 6]
34:		mov [bp + 18], ax
36:	

fputs$9:	; Parameter 12 size 8
37:		mov ax, [bp + 10]
38:		mov [bp + 20], ax
40:	

fputs$10:	; Parameter 12 1 10
41:		mov word [bp + 22], 1
43:	

fputs$11:	; Parameter 12 stream 12
44:		mov ax, [bp + 8]
45:		mov [bp + 24], ax
47:	

fputs$12:	; Call 12 fwrite 0
48:		mov word [bp + 12], fputs$13
49:		mov [bp + 14], bp
50:		add bp, 12
51:		jmp fwrite
53:	

fputs$13:	; PostCall 12
55:	

fputs$14:	; GetReturnValue £temporary865
60:	

fputs$15:	; NotEqual 18 £temporary865 size
61:		cmp bx, [bp + 10]
62:		jne fputs$18
64:	

fputs$16:	; Assign £temporary870 0
65:		mov bx, 0
67:	

fputs$17:	; Goto 19
68:		jmp fputs$19
70:	

fputs$18:	; Assign £temporary870 -1
71:		mov bx, -1
73:	

fputs$19:	; SetReturnValue £temporary870
75:	

fputs$20:	; Return £temporary870
76:		mov ax, [bp]
77:		mov di, [bp + 4]
78:		mov bp, [bp + 2]
79:		jmp ax
81:	

fputs$21:	; FunctionEnd fputs
1:	

getchar:	; CallHeader 6 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

getchar$1:	; Parameter 6 stdin 6
4:		mov ax, [stdin]
5:		mov [bp + 12], ax
7:	

getchar$2:	; Call 6 fgetc 0
8:		mov word [bp + 6], getchar$3
9:		mov [bp + 8], bp
10:		add bp, 6
11:		jmp fgetc
13:	

getchar$3:	; PostCall 6
15:	

getchar$4:	; GetReturnValue £temporary876
20:	

getchar$5:	; SetReturnValue £temporary876
22:	

getchar$6:	; Return £temporary876
23:		mov ax, [bp]
24:		mov di, [bp + 4]
25:		mov bp, [bp + 2]
26:		jmp ax
28:	

getchar$7:	; FunctionEnd getchar
1:	

gets:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

gets$1:	; Parameter 8 s 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

gets$2:	; Parameter 8 -1 8
8:		mov word [bp + 16], -1
10:	

gets$3:	; Parameter 8 stdin 10
11:		mov ax, [stdin]
12:		mov [bp + 18], ax
14:	

gets$4:	; Call 8 fgets 0
15:		mov word [bp + 8], gets$5
16:		mov [bp + 10], bp
17:		add bp, 8
18:		jmp fgets
20:	

gets$5:	; PostCall 8
22:	

gets$6:	; GetReturnValue £temporary878
27:	

gets$7:	; Equal 21 £temporary878 0
28:		cmp bx, 0
29:		je gets$21
31:	

gets$8:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
33:	

gets$9:	; Parameter 8 s 6
34:		mov ax, [bp + 6]
35:		mov [bp + 14], ax
37:	

gets$10:	; Call 8 strlen 0
38:		mov word [bp + 8], gets$11
39:		mov [bp + 10], bp
40:		add bp, 8
41:		jmp strlen
43:	

gets$11:	; PostCall 8
45:	

gets$12:	; GetReturnValue £temporary880
50:	

gets$13:	; Assign size £temporary880
51:		mov [bp + 8], bx
53:	

gets$14:	; SignedLessThanEqual 19 size 0
54:		cmp word [bp + 8], 0
55:		jle gets$19
57:	

gets$15:	; BinarySubtract £temporary882 size 1
58:		mov ax, [bp + 8]
59:		sub ax, 1
61:	

gets$16:	; BinaryAdd £temporary884 s £temporary882
62:		mov si, [bp + 6]
63:		add si, ax
65:	

gets$17:	; Deref £temporary883 -> £temporary884 £temporary884 0
67:	

gets$18:	; Assign £temporary883 -> £temporary884 0
68:		mov byte [si], 0
70:	

gets$19:	; SetReturnValue s
71:		mov bx, [bp + 6]
73:	

gets$20:	; Return s
74:		mov ax, [bp]
75:		mov di, [bp + 4]
76:		mov bp, [bp + 2]
77:		jmp ax
79:	

gets$21:	; SetReturnValue 0
80:		mov bx, 0
82:	

gets$22:	; Return 0
83:		mov ax, [bp]
84:		mov di, [bp + 4]
85:		mov bp, [bp + 2]
86:		jmp ax
88:	

gets$23:	; FunctionEnd gets
1:	

puts:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

puts$1:	; Parameter 8 s 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

puts$2:	; Parameter 8 stdout 8
8:		mov ax, [stdout]
9:		mov [bp + 16], ax
11:	

puts$3:	; Call 8 fputs 0
12:		mov word [bp + 8], puts$4
13:		mov [bp + 10], bp
14:		add bp, 8
15:		jmp fputs
17:	

puts$4:	; PostCall 8
19:	

puts$5:	; GetReturnValue £temporary889
24:	

puts$6:	; Equal 15 £temporary889 0
25:		cmp bx, 0
26:		je puts$15
28:	

puts$7:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
30:	

puts$8:	; Parameter 8 10 6
31:		mov word [bp + 14], 10
33:	

puts$9:	; Parameter 8 stdout 8
34:		mov ax, [stdout]
35:		mov [bp + 16], ax
37:	

puts$10:	; Call 8 fputc 0
38:		mov word [bp + 8], puts$11
39:		mov [bp + 10], bp
40:		add bp, 8
41:		jmp fputc
43:	

puts$11:	; PostCall 8
45:	

puts$12:	; GetReturnValue £temporary891
50:	

puts$13:	; SetReturnValue £temporary891
52:	

puts$14:	; Return £temporary891
53:		mov ax, [bp]
54:		mov di, [bp + 4]
55:		mov bp, [bp + 2]
56:		jmp ax
58:	

puts$15:	; SetReturnValue -1
59:		mov bx, -1
61:	

puts$16:	; Return -1
62:		mov ax, [bp]
63:		mov di, [bp + 4]
64:		mov bp, [bp + 2]
65:		jmp ax
67:	

puts$17:	; FunctionEnd puts
1:	

ungetc:	; Deref £temporary896 -> stream stream 20
2:		mov si, [bp + 8]
4:	

ungetc$1:	; IntegralToIntegral £temporary897 £temporary896 -> stream
5:		mov al, [si + 20]
7:		and ax, 255
9:		cmp al, 0
10:		jge ungetc$2
11:		neg al
13:		neg ax
15:	

ungetc$2:	; Equal 6 £temporary897 -1
16:		cmp ax, -1
17:		je ungetc$6
19:	

ungetc$3:	; Deref £temporary899 -> stream stream 20
20:		mov si, [bp + 8]
22:	

ungetc$4:	; IntegralToIntegral £temporary900 c
23:		mov ax, [bp + 6]
26:		cmp ax, 0
27:		jge ungetc$5
28:		neg ax
30:		neg al
32:	

ungetc$5:	; Assign £temporary899 -> stream £temporary900
33:		mov [si + 20], al
35:	

ungetc$6:	; SetReturnValue c
36:		mov bx, [bp + 6]
38:	

ungetc$7:	; Return c
39:		mov ax, [bp]
40:		mov di, [bp + 4]
41:		mov bp, [bp + 2]
42:		jmp ax
44:	

ungetc$8:	; FunctionEnd ungetc
1:	

fread:	; Deref £temporary902 -> stream stream 2
2:		mov si, [bp + 12]
4:	

fread$1:	; AssignRegister bx £temporary902 -> stream
5:		mov bx, [si + 2]
7:	

fread$2:	; SignedMultiply £temporary904 size nobj
8:		mov ax, [bp + 8]
10:		xor dx, dx
11:		imul word [bp + 10]
17:	

fread$3:	; AssignRegister cx £temporary904
18:		mov cx, ax
20:	

fread$4:	; AssignRegister ah 63
21:		mov ah, 63
23:	

fread$5:	; AssignRegister dx ptr
24:		mov dx, [bp + 6]
26:	

fread$6:	; Interrupt 33
27:		int 33
29:	

fread$7:	; NotCarry 13
30:		jnc fread$13
32:	

fread$8:	; Deref £temporary908 -> stream stream 21
33:		mov si, [bp + 12]
35:	

fread$9:	; Assign errno 14
36:		mov word [errno], 14
38:	

fread$10:	; Assign £temporary908 -> stream errno
39:		mov ax, [errno]
40:		mov [si + 21], ax
42:	

fread$11:	; SetReturnValue 0
43:		mov bx, 0
45:	

fread$12:	; Return 0
46:		mov ax, [bp]
47:		mov di, [bp + 4]
48:		mov bp, [bp + 2]
49:		jmp ax
51:	

fread$13:	; InspectRegister £temporary909 ax
53:	

fread$14:	; SetReturnValue £temporary909
54:		mov bx, ax
56:	

fread$15:	; Return £temporary909
57:		mov ax, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp ax
62:	

fread$16:	; FunctionEnd fread
1:	

fwrite:	; Deref £temporary911 -> stream stream 2
2:		mov si, [bp + 12]
4:	

fwrite$1:	; AssignRegister bx £temporary911 -> stream
5:		mov bx, [si + 2]
7:	

fwrite$2:	; SignedMultiply £temporary913 size nobj
8:		mov ax, [bp + 8]
10:		xor dx, dx
11:		imul word [bp + 10]
17:	

fwrite$3:	; AssignRegister cx £temporary913
18:		mov cx, ax
20:	

fwrite$4:	; AssignRegister ah 64
21:		mov ah, 64
23:	

fwrite$5:	; AssignRegister dx ptr
24:		mov dx, [bp + 6]
26:	

fwrite$6:	; Interrupt 33
27:		int 33
29:	

fwrite$7:	; NotCarry 13
30:		jnc fwrite$13
32:	

fwrite$8:	; Deref £temporary917 -> stream stream 21
33:		mov si, [bp + 12]
35:	

fwrite$9:	; Assign errno 13
36:		mov word [errno], 13
38:	

fwrite$10:	; Assign £temporary917 -> stream errno
39:		mov ax, [errno]
40:		mov [si + 21], ax
42:	

fwrite$11:	; SetReturnValue 0
43:		mov bx, 0
45:	

fwrite$12:	; Return 0
46:		mov ax, [bp]
47:		mov di, [bp + 4]
48:		mov bp, [bp + 2]
49:		jmp ax
51:	

fwrite$13:	; InspectRegister £temporary918 ax
53:	

fwrite$14:	; SetReturnValue £temporary918
54:		mov bx, ax
56:	

fwrite$15:	; Return £temporary918
57:		mov ax, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp ax
62:	

fwrite$16:	; FunctionEnd fwrite
1:	

fseek:	; IntegralToIntegral £temporary920 origin
2:		mov ax, [bp + 10]
5:		cmp ax, 0
6:		jge fseek$1
7:		neg ax
9:		neg al
11:	

fseek$1:	; AssignRegister al £temporary920
13:	

fseek$2:	; AssignRegister ah 66
14:		mov ah, 66
16:	

fseek$3:	; Deref £temporary923 -> stream stream 2
17:		mov si, [bp + 6]
19:	

fseek$4:	; AssignRegister bx £temporary923 -> stream
20:		mov bx, [si + 2]
22:	

fseek$5:	; AssignRegister cx 0
23:		mov cx, 0
25:	

fseek$6:	; IntegralToIntegral £temporary926 offset
26:		mov dx, [bp + 8]
29:	

fseek$7:	; AssignRegister dx £temporary926
31:	

fseek$8:	; Interrupt 33
32:		int 33
34:	

fseek$9:	; Carry 16
35:		jc fseek$16
37:	

fseek$10:	; Deref £temporary929 -> stream stream 23
38:		mov si, [bp + 6]
40:	

fseek$11:	; InspectRegister £temporary930 ax
42:	

fseek$12:	; Assign £temporary929 -> stream £temporary930
43:		mov [si + 23], ax
45:	

fseek$13:	; Deref £temporary931 -> stream stream 23
46:		mov si, [bp + 6]
48:	

fseek$14:	; SetReturnValue £temporary931 -> stream
49:		mov bx, [si + 23]
51:	

fseek$15:	; Return £temporary931 -> stream
52:		mov ax, [bp]
53:		mov di, [bp + 4]
54:		mov bp, [bp + 2]
55:		jmp ax
57:	

fseek$16:	; Deref £temporary932 -> stream stream 21
58:		mov si, [bp + 6]
60:	

fseek$17:	; Assign £temporary932 -> stream 15
61:		mov word [si + 21], 15
63:	

fseek$18:	; SetReturnValue -1
64:		mov bx, -1
66:	

fseek$19:	; Return -1
67:		mov ax, [bp]
68:		mov di, [bp + 4]
69:		mov bp, [bp + 2]
70:		jmp ax
72:	

fseek$20:	; FunctionEnd fseek
1:	

ftell:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

ftell$1:	; Parameter 8 stream 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

ftell$2:	; Parameter 8 0 8
8:		mov word [bp + 16], 0
10:	

ftell$3:	; Parameter 8 1 10
11:		mov word [bp + 18], 1
13:	

ftell$4:	; Call 8 fseek 0
14:		mov word [bp + 8], ftell$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp fseek
19:	

ftell$5:	; PostCall 8
21:	

ftell$6:	; GetReturnValue £temporary933
26:	

ftell$7:	; SetReturnValue £temporary933
28:	

ftell$8:	; Return £temporary933
29:		mov ax, [bp]
30:		mov di, [bp + 4]
31:		mov bp, [bp + 2]
32:		jmp ax
34:	

ftell$9:	; FunctionEnd ftell
1:	

rewind:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

rewind$1:	; Parameter 8 stream 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

rewind$2:	; Parameter 8 0 8
8:		mov word [bp + 16], 0
10:	

rewind$3:	; Parameter 8 0 10
11:		mov word [bp + 18], 0
13:	

rewind$4:	; Call 8 fseek 0
14:		mov word [bp + 8], rewind$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp fseek
19:	

rewind$5:	; PostCall 8
21:	

rewind$6:	; Return 0
22:		mov ax, [bp]
23:		mov di, [bp + 4]
24:		mov bp, [bp + 2]
25:		jmp ax
27:	

rewind$7:	; FunctionEnd rewind
1:	

fgetpos:	; Deref £temporary942 -> ptr ptr 0
2:		mov si, [bp + 8]
4:	

fgetpos$1:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
5:		mov [bp + 10], si
7:	

fgetpos$2:	; Parameter 10 stream 6
8:		mov ax, [bp + 6]
9:		mov [bp + 18], ax
11:	

fgetpos$3:	; Call 10 ftell 0
12:		mov word [bp + 12], fgetpos$4
13:		mov [bp + 14], bp
14:		add bp, 12
15:		jmp ftell
17:	

fgetpos$4:	; PostCall 10
18:		mov si, [bp + 10]
20:	

fgetpos$5:	; GetReturnValue £temporary943
25:	

fgetpos$6:	; IntegralToIntegral £temporary944 £temporary943
28:	

fgetpos$7:	; Assign £temporary942 -> ptr £temporary944
29:		mov [si], bx
31:	

fgetpos$8:	; SetReturnValue 0
32:		mov bx, 0
34:	

fgetpos$9:	; Return 0
35:		mov ax, [bp]
36:		mov di, [bp + 4]
37:		mov bp, [bp + 2]
38:		jmp ax
40:	

fgetpos$10:	; FunctionEnd fgetpos
1:	

fsetpos:	; CallHeader 10 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

fsetpos$1:	; Parameter 10 stream 6
4:		mov ax, [bp + 6]
5:		mov [bp + 16], ax
7:	

fsetpos$2:	; Deref £temporary946 -> ptr ptr 0
8:		mov si, [bp + 8]
10:	

fsetpos$3:	; Parameter 10 £temporary946 -> ptr 8
11:		mov ax, [si]
12:		mov [bp + 18], ax
14:	

fsetpos$4:	; Parameter 10 0 10
15:		mov word [bp + 20], 0
17:	

fsetpos$5:	; Call 10 fseek 0
18:		mov word [bp + 10], fsetpos$6
19:		mov [bp + 12], bp
20:		add bp, 10
21:		jmp fseek
23:	

fsetpos$6:	; PostCall 10
25:	

fsetpos$7:	; GetReturnValue £temporary947
30:	

fsetpos$8:	; IntegralToIntegral £temporary948 £temporary947
33:	

fsetpos$9:	; SetReturnValue £temporary948
35:	

fsetpos$10:	; Return £temporary948
36:		mov ax, [bp]
37:		mov di, [bp + 4]
38:		mov bp, [bp + 2]
39:		jmp ax
41:	

fsetpos$11:	; FunctionEnd fsetpos
1:	

clearerr:	; Deref £temporary952 -> stream stream 21
2:		mov si, [bp + 6]
4:	

clearerr$1:	; Assign errno 0
5:		mov word [errno], 0
7:	

clearerr$2:	; Assign £temporary952 -> stream errno
8:		mov ax, [errno]
9:		mov [si + 21], ax
11:	

clearerr$3:	; Return 0
12:		mov ax, [bp]
13:		mov di, [bp + 4]
14:		mov bp, [bp + 2]
15:		jmp ax
17:	

clearerr$4:	; FunctionEnd clearerr
1:	

feof:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

feof$1:	; Parameter 8 stream 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

feof$2:	; Parameter 8 0 8
8:		mov word [bp + 16], 0
10:	

feof$3:	; Parameter 8 1 10
11:		mov word [bp + 18], 1
13:	

feof$4:	; Call 8 fseek 0
14:		mov word [bp + 8], feof$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		jmp fseek
19:	

feof$5:	; PostCall 8
21:	

feof$6:	; GetReturnValue £temporary953
26:	

feof$7:	; IntegralToIntegral £temporary954 £temporary953
28:		and ebx, 65535
30:	

feof$8:	; Assign currPosition £temporary954
31:		mov [bp + 8], ebx
33:	

feof$9:	; CallHeader 12 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
35:	

feof$10:	; Parameter 12 stream 6
36:		mov ax, [bp + 6]
37:		mov [bp + 18], ax
39:	

feof$11:	; Parameter 12 0 8
40:		mov word [bp + 20], 0
42:	

feof$12:	; Parameter 12 2 10
43:		mov word [bp + 22], 2
45:	

feof$13:	; Call 12 fseek 0
46:		mov word [bp + 12], feof$14
47:		mov [bp + 14], bp
48:		add bp, 12
49:		jmp fseek
51:	

feof$14:	; PostCall 12
53:	

feof$15:	; GetReturnValue £temporary955
58:	

feof$16:	; IntegralToIntegral £temporary956 £temporary955
60:		and ebx, 65535
62:	

feof$17:	; Assign lastPosition £temporary956
63:		mov [bp + 12], ebx
65:	

feof$18:	; CallHeader 16 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
67:	

feof$19:	; Parameter 16 stream 6
68:		mov ax, [bp + 6]
69:		mov [bp + 22], ax
71:	

feof$20:	; IntegralToIntegral £temporary957 currPosition
72:		mov eax, [bp + 8]
75:	

feof$21:	; Parameter 16 £temporary957 8
76:		mov [bp + 24], ax
78:	

feof$22:	; Parameter 16 0 10
79:		mov word [bp + 26], 0
81:	

feof$23:	; Call 16 fseek 0
82:		mov word [bp + 16], feof$24
83:		mov [bp + 18], bp
84:		add bp, 16
85:		jmp fseek
87:	

feof$24:	; PostCall 16
89:	

feof$25:	; NotEqual 28 currPosition lastPosition
90:		mov eax, [bp + 12]
91:		cmp [bp + 8], eax
92:		jne feof$28
94:	

feof$26:	; Assign £temporary960 1
95:		mov ax, 1
97:	

feof$27:	; Goto 29
98:		jmp feof$29
100:	

feof$28:	; Assign £temporary960 0
101:		mov ax, 0
103:	

feof$29:	; Assign endOfFile £temporary960
104:		mov [bp + 16], ax
106:	

feof$30:	; SetReturnValue endOfFile
107:		mov bx, [bp + 16]
109:	

feof$31:	; Return endOfFile
110:		mov ax, [bp]
111:		mov di, [bp + 4]
112:		mov bp, [bp + 2]
113:		jmp ax
115:	

feof$32:	; FunctionEnd feof
1:	

ferror:	; Deref £temporary970 -> stream stream 21
2:		mov si, [bp + 6]
4:	

ferror$1:	; SetReturnValue £temporary970 -> stream
5:		mov bx, [si + 21]
7:	

ferror$2:	; Return £temporary970 -> stream
8:		mov ax, [bp]
9:		mov di, [bp + 4]
10:		mov bp, [bp + 2]
11:		jmp ax
13:	

ferror$3:	; FunctionEnd ferror
1:	

perror:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

perror$1:	; Parameter 8 string_25s3A2025s2E0A# 6
4:		mov word [bp + 14], @2257$string_25s3A2025s2E0A#
6:	

perror$2:	; Parameter 8 s 8
7:		mov ax, [bp + 6]
8:		mov [bp + 16], ax
10:	

perror$3:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
12:	

perror$4:	; Parameter 8 errno 16
13:		mov ax, [errno]
14:		mov [bp + 24], ax
16:	

perror$5:	; Call 8 strerror 10
17:		mov word [bp + 18], perror$6
18:		mov [bp + 20], bp
19:		add bp, 18
20:		jmp strerror
22:	

perror$6:	; PostCall 8
24:	

perror$7:	; GetReturnValue £temporary971
29:	

perror$8:	; Parameter 8 £temporary971 10
30:		mov [bp + 18], bx
32:	

perror$9:	; Call 8 printf 0
33:		mov word [bp + 8], perror$10
34:		mov [bp + 10], bp
35:		add bp, 8
36:		mov di, bp
37:		add di, 4
38:		jmp printf
40:	

perror$10:	; PostCall 8
42:	

perror$11:	; Return 0
43:		mov ax, [bp]
44:		mov di, [bp + 4]
45:		mov bp, [bp + 2]
46:		jmp ax
48:	

perror$12:	; FunctionEnd perror
