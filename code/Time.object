1:	

clock:	; SetReturnValue -1
2:		mov ebx, -1
4:	

clock$1:	; Return -1
5:		mov ax, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp ax
10:	

clock$2:	; FunctionEnd clock
1:	

@7420$isLeapYear:	; SignedModulo £temporary3231 year 4
2:		mov ax, [bp + 6]
4:		xor dx, dx
5:		idiv word [@7422$int2$4#]
11:	

@7420$isLeapYear$1:	; NotEqual 4 £temporary3231 0
12:		cmp dx, 0
13:		jne @7420$isLeapYear$4
15:	

@7420$isLeapYear$2:	; SignedModulo £temporary3233 year 100
16:		mov ax, [bp + 6]
18:		xor dx, dx
19:		idiv word [@7428$int2$100#]
25:	

@7420$isLeapYear$3:	; NotEqual 6 £temporary3233 0
26:		cmp dx, 0
27:		jne @7420$isLeapYear$6
29:	

@7420$isLeapYear$4:	; SignedModulo £temporary3236 year 400
30:		mov ax, [bp + 6]
32:		xor dx, dx
33:		idiv word [@7435$int2$400#]
39:	

@7420$isLeapYear$5:	; NotEqual 8 £temporary3236 0
40:		cmp dx, 0
41:		jne @7420$isLeapYear$8
43:	

@7420$isLeapYear$6:	; Assign £temporary3239 1
44:		mov bx, 1
46:	

@7420$isLeapYear$7:	; Goto 9
47:		jmp @7420$isLeapYear$9
49:	

@7420$isLeapYear$8:	; Assign £temporary3239 0
50:		mov bx, 0
52:	

@7420$isLeapYear$9:	; SetReturnValue £temporary3239
54:	

@7420$isLeapYear$10:	; Return £temporary3239
55:		mov ax, [bp]
56:		mov di, [bp + 4]
57:		mov bp, [bp + 2]
58:		jmp ax
60:	

@7420$isLeapYear$11:	; FunctionEnd isLeapYear
1:	

time:	; AssignRegister ah 42
2:		mov ah, 42
4:	

time$1:	; Interrupt 33
5:		int 33
7:	

time$2:	; InspectRegister £temporary3241 cx
9:	

time$3:	; BinarySubtract year £temporary3241 1900
10:		sub cx, 1900
11:		mov [bp + 12], cx
13:	

time$4:	; InspectRegister £temporary3243 dh
15:	

time$5:	; BinarySubtract month £temporary3243 1
16:		sub dh, 1
17:		mov [bp + 14], dh
19:	

time$6:	; InspectRegister £temporary3245 dl
21:	

time$7:	; Assign monthDay £temporary3245
22:		mov [bp + 15], dl
24:	

time$8:	; AssignRegister ah 44
25:		mov ah, 44
27:	

time$9:	; Interrupt 33
28:		int 33
30:	

time$10:	; InspectRegister £temporary3247 ch
32:	

time$11:	; Assign hour £temporary3247
33:		mov [bp + 16], ch
35:	

time$12:	; InspectRegister £temporary3248 cl
37:	

time$13:	; Assign min £temporary3248
38:		mov [bp + 17], cl
40:	

time$14:	; InspectRegister £temporary3249 dh
42:	

time$15:	; Assign sec £temporary3249
43:		mov [bp + 18], dh
45:	

time$16:	; CallHeader 19 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
47:	

time$17:	; Call 19 localeconv 0
48:		mov word [bp + 19], time$18
49:		mov [bp + 21], bp
50:		add bp, 19
51:		jmp localeconv
53:	

time$18:	; PostCall 19
55:	

time$19:	; GetReturnValue £temporary3250
57:	

time$20:	; Assign localeConvPtr £temporary3250
58:		mov [bp + 19], bx
60:	

time$21:	; Equal 27 localeConvPtr 0
61:		cmp word [bp + 19], 0
62:		je time$27
64:	

time$22:	; IntegralToIntegral £temporary3253 hour
65:		mov al, [bp + 16]
67:		and ax, 255
69:		cmp al, 0
70:		jge time$23
71:		neg al
73:		neg ax
75:	

time$23:	; Deref £temporary3252 -> localeConvPtr localeConvPtr 2
76:		mov si, [bp + 19]
78:	

time$24:	; BinarySubtract £temporary3254 £temporary3253 £temporary3252 -> localeConvPtr
79:		sub ax, [si + 2]
81:	

time$25:	; IntegralToIntegral £temporary3255 £temporary3254
84:		cmp ax, 0
85:		jge time$26
86:		neg ax
88:		neg al
90:	

time$26:	; Assign hour £temporary3255
91:		mov [bp + 16], al
93:	

time$27:	; Assign daysOfMonths[0] 31
94:		mov word [bp + 19], 31
96:	

time$28:	; CallHeader 21 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
98:	

time$29:	; Parameter 21 year 6
99:		mov ax, [bp + 12]
100:		mov [bp + 27], ax
102:	

time$30:	; Call 21 isLeapYear 0
103:		mov word [bp + 21], time$31
104:		mov [bp + 23], bp
105:		add bp, 21
106:		jmp @7420$isLeapYear
108:	

time$31:	; PostCall 21
110:	

time$32:	; GetReturnValue £temporary3256
112:	

time$33:	; Equal 36 £temporary3256 0
113:		cmp bx, 0
114:		je time$36
116:	

time$34:	; Assign £temporary3261 29
117:		mov ax, 29
119:	

time$35:	; Goto 37
120:		jmp time$37
122:	

time$36:	; Assign £temporary3261 28
123:		mov ax, 28
125:	

time$37:	; Assign daysOfMonths[1] £temporary3261
126:		mov [bp + 21], ax
128:	

time$38:	; Assign daysOfMonths[2] 31
129:		mov word [bp + 23], 31
131:	

time$39:	; Assign daysOfMonths[3] 30
132:		mov word [bp + 25], 30
134:	

time$40:	; Assign daysOfMonths[4] 31
135:		mov word [bp + 27], 31
137:	

time$41:	; Assign daysOfMonths[5] 30
138:		mov word [bp + 29], 30
140:	

time$42:	; Assign daysOfMonths[6] 31
141:		mov word [bp + 31], 31
143:	

time$43:	; Assign daysOfMonths[7] 31
144:		mov word [bp + 33], 31
146:	

time$44:	; Assign daysOfMonths[8] 30
147:		mov word [bp + 35], 30
149:	

time$45:	; Assign daysOfMonths[9] 31
150:		mov word [bp + 37], 31
152:	

time$46:	; Assign daysOfMonths[10] 30
153:		mov word [bp + 39], 30
155:	

time$47:	; Assign daysOfMonths[11] 31
156:		mov word [bp + 41], 31
158:	

time$48:	; IntegralToIntegral £temporary3274 monthDay
159:		mov al, [bp + 15]
161:		and ax, 255
163:		cmp al, 0
164:		jge time$49
165:		neg al
167:		neg ax
169:	

time$49:	; BinarySubtract yearDay £temporary3274 1
170:		sub ax, 1
171:		mov [bp + 43], ax
173:	

time$50:	; Assign monthIndex 0
174:		mov word [bp + 45], 0
176:	

time$51:	; IntegralToIntegral £temporary3276 month
177:		mov al, [bp + 14]
179:		and ax, 255
181:		cmp al, 0
182:		jge time$52
183:		neg al
185:		neg ax
187:	

time$52:	; SignedGreaterThanEqual 59 monthIndex £temporary3276
188:		cmp [bp + 45], ax
189:		jge time$59
191:	

time$53:	; SignedMultiply £temporary3280 monthIndex 2
192:		mov ax, [bp + 45]
194:		xor dx, dx
195:		imul word [@7543$int2$2#]
201:	

time$54:	; BinaryAdd £temporary3281 daysOfMonths £temporary3280
202:		mov si, bp
203:		add si, 19
204:		add si, ax
206:	

time$55:	; Deref £temporary3279 -> £temporary3281 £temporary3281 0
208:	

time$56:	; BinaryAdd yearDay yearDay £temporary3279 -> £temporary3281
209:		mov ax, [si]
210:		add [bp + 43], ax
212:	

time$57:	; Increment monthIndex
213:		inc word [bp + 45]
215:	

time$58:	; Goto 51
216:		jmp time$51
218:	

time$59:	; IntegralToIntegral £temporary3284 sec
219:		mov al, [bp + 18]
221:		and ax, 255
223:		cmp al, 0
224:		jge time$60
225:		neg al
227:		neg ax
229:	

time$60:	; Assign s$tm_sec £temporary3284
230:		mov [bp + 47], ax
232:	

time$61:	; IntegralToIntegral £temporary3286 min
233:		mov al, [bp + 17]
235:		and ax, 255
237:		cmp al, 0
238:		jge time$62
239:		neg al
241:		neg ax
243:	

time$62:	; Assign s$tm_min £temporary3286
244:		mov [bp + 49], ax
246:	

time$63:	; IntegralToIntegral £temporary3288 hour
247:		mov al, [bp + 16]
249:		and ax, 255
251:		cmp al, 0
252:		jge time$64
253:		neg al
255:		neg ax
257:	

time$64:	; Assign s$tm_hour £temporary3288
258:		mov [bp + 51], ax
260:	

time$65:	; IntegralToIntegral £temporary3290 monthDay
261:		mov al, [bp + 15]
263:		and ax, 255
265:		cmp al, 0
266:		jge time$66
267:		neg al
269:		neg ax
271:	

time$66:	; Assign s$tm_mday £temporary3290
272:		mov [bp + 53], ax
274:	

time$67:	; IntegralToIntegral £temporary3292 month
275:		mov al, [bp + 14]
277:		and ax, 255
279:		cmp al, 0
280:		jge time$68
281:		neg al
283:		neg ax
285:	

time$68:	; Assign s$tm_mon £temporary3292
286:		mov [bp + 55], ax
288:	

time$69:	; Assign s$tm_year year
289:		mov ax, [bp + 12]
290:		mov [bp + 57], ax
292:	

time$70:	; Assign s$tm_wday 0
293:		mov word [bp + 59], 0
295:	

time$71:	; Assign s$tm_yday yearDay
296:		mov ax, [bp + 43]
297:		mov [bp + 61], ax
299:	

time$72:	; Assign s$tm_isdst 0
300:		mov word [bp + 63], 0
302:	

time$73:	; CallHeader 65 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
304:	

time$74:	; address £temporary3297 s
305:		mov si, bp
306:		add si, 47
308:	

time$75:	; Parameter 65 £temporary3297 6
309:		mov [bp + 71], si
311:	

time$76:	; Call 65 mktime 0
312:		mov word [bp + 65], time$77
313:		mov [bp + 67], bp
314:		add bp, 65
315:		jmp mktime
317:	

time$77:	; PostCall 65
319:	

time$78:	; GetReturnValue £temporary3298
321:	

time$79:	; Assign time £temporary3298
322:		mov [bp + 8], ebx
324:	

time$80:	; Equal 83 timePtr 0
325:		cmp word [bp + 6], 0
326:		je time$83
328:	

time$81:	; Deref £temporary3300 -> timePtr timePtr 0
329:		mov si, [bp + 6]
331:	

time$82:	; Assign £temporary3300 -> timePtr time
332:		mov eax, [bp + 8]
333:		mov [si], eax
335:	

time$83:	; SetReturnValue time
336:		mov ebx, [bp + 8]
338:	

time$84:	; Return time
339:		mov ax, [bp]
340:		mov di, [bp + 4]
341:		mov bp, [bp + 2]
342:		jmp ax
344:	

time$85:	; FunctionEnd time
1:	

mktime:	; Equal 28 tp 0
2:		cmp word [bp + 6], 0
3:		je mktime$28
5:	

mktime$1:	; Deref £temporary3305 -> tp tp 10
6:		mov si, [bp + 6]
8:	

mktime$2:	; BinarySubtract £temporary3306 £temporary3305 -> tp 69
9:		mov ax, [si + 10]
10:		sub ax, 69
12:	

mktime$3:	; SignedDivide £temporary3307 £temporary3306 4
14:		xor dx, dx
15:		idiv word [@7586$int2$4#]
21:	

mktime$4:	; IntegralToIntegral £temporary3308 £temporary3307
23:		and eax, 65535
25:		cmp ax, 0
26:		jge mktime$5
27:		neg ax
29:		neg eax
31:	

mktime$5:	; Assign leapDays £temporary3308
32:		mov [bp + 8], eax
34:	

mktime$6:	; Deref £temporary3309 -> tp tp 10
35:		mov si, [bp + 6]
37:	

mktime$7:	; BinarySubtract £temporary3310 £temporary3309 -> tp 70
38:		mov ax, [si + 10]
39:		sub ax, 70
41:	

mktime$8:	; SignedMultiply £temporary3311 £temporary3310 365
43:		xor dx, dx
44:		imul word [@7595$int2$365#]
50:	

mktime$9:	; IntegralToIntegral £temporary3312 £temporary3311
52:		and eax, 65535
54:		cmp ax, 0
55:		jge mktime$10
56:		neg ax
58:		neg eax
60:	

mktime$10:	; BinaryAdd £temporary3313 £temporary3312 leapDays
61:		add eax, [bp + 8]
63:	

mktime$11:	; Deref £temporary3314 -> tp tp 14
64:		mov si, [bp + 6]
66:	

mktime$12:	; IntegralToIntegral £temporary3315 £temporary3314 -> tp
67:		mov bx, [si + 14]
69:		and ebx, 65535
71:		cmp bx, 0
72:		jge mktime$13
73:		neg bx
75:		neg ebx
77:	

mktime$13:	; BinaryAdd totalDays £temporary3313 £temporary3315
78:		add eax, ebx
79:		mov [bp + 12], eax
81:	

mktime$14:	; SignedMultiply £temporary3317 totalDays 86400
82:		mov eax, [bp + 12]
84:		xor edx, edx
85:		imul dword [@7604$int4$86400#]
91:		mov ebx, eax
93:	

mktime$15:	; Deref £temporary3318 -> tp tp 4
94:		mov si, [bp + 6]
96:	

mktime$16:	; IntegralToIntegral £temporary3319 £temporary3318 -> tp
97:		mov ax, [si + 4]
99:		and eax, 65535
101:		cmp ax, 0
102:		jge mktime$17
103:		neg ax
105:		neg eax
107:	

mktime$17:	; SignedMultiply £temporary3320 £temporary3319 3600
109:		xor edx, edx
110:		imul dword [@7608$int4$3600#]
116:	

mktime$18:	; BinaryAdd £temporary3321 £temporary3317 £temporary3320
117:		add ebx, eax
119:	

mktime$19:	; Deref £temporary3322 -> tp tp 2
120:		mov si, [bp + 6]
122:	

mktime$20:	; IntegralToIntegral £temporary3323 £temporary3322 -> tp
123:		mov ax, [si + 2]
125:		and eax, 65535
127:		cmp ax, 0
128:		jge mktime$21
129:		neg ax
131:		neg eax
133:	

mktime$21:	; SignedMultiply £temporary3324 £temporary3323 60
135:		xor edx, edx
136:		imul dword [@7614$int4$60#]
142:	

mktime$22:	; BinaryAdd £temporary3325 £temporary3321 £temporary3324
143:		add ebx, eax
145:	

mktime$23:	; Deref £temporary3326 -> tp tp 0
146:		mov si, [bp + 6]
148:	

mktime$24:	; IntegralToIntegral £temporary3327 £temporary3326 -> tp
149:		mov ax, [si]
151:		and eax, 65535
153:		cmp ax, 0
154:		jge mktime$25
155:		neg ax
157:		neg eax
159:	

mktime$25:	; BinaryAdd £temporary3328 £temporary3325 £temporary3327
160:		add ebx, eax
162:	

mktime$26:	; SetReturnValue £temporary3328
164:	

mktime$27:	; Return £temporary3328
165:		mov ax, [bp]
166:		mov di, [bp + 4]
167:		mov bp, [bp + 2]
168:		jmp ax
170:	

mktime$28:	; SetReturnValue 0
171:		mov ebx, 0
173:	

mktime$29:	; Return 0
174:		mov ax, [bp]
175:		mov di, [bp + 4]
176:		mov bp, [bp + 2]
177:		jmp ax
179:	

mktime$30:	; FunctionEnd mktime
1:	

gmtime:	; Equal 89 timePtr 0
2:		cmp word [bp + 6], 0
3:		je gmtime$89
5:	

gmtime$1:	; Deref £temporary3330 -> timePtr timePtr 0
6:		mov si, [bp + 6]
8:	

gmtime$2:	; Assign time £temporary3330 -> timePtr
9:		mov eax, [si]
10:		mov [bp + 8], eax
12:	

gmtime$3:	; SignedModulo secondsOfDay time 86400
13:		mov eax, [bp + 8]
15:		xor edx, edx
16:		idiv dword [@7632$int4$86400#]
17:		mov [bp + 12], edx
19:	

gmtime$4:	; SignedModulo secondsOfHour secondsOfDay 3600
20:		mov eax, [bp + 12]
22:		xor edx, edx
23:		idiv dword [@7636$int4$3600#]
24:		mov [bp + 16], edx
26:	

gmtime$5:	; SignedDivide £temporary3334 secondsOfDay 3600
27:		mov eax, [bp + 12]
29:		xor edx, edx
30:		idiv dword [@7641$int4$3600#]
36:	

gmtime$6:	; IntegralToIntegral £temporary3335 £temporary3334
39:		cmp eax, 0
40:		jge gmtime$7
41:		neg eax
43:		neg ax
45:	

gmtime$7:	; Assign g_timeStruct$tm_hour £temporary3335
46:		mov [@7624$g_timeStruct + 4], ax
48:	

gmtime$8:	; SignedDivide £temporary3337 secondsOfHour 60
49:		mov eax, [bp + 16]
51:		xor edx, edx
52:		idiv dword [@7646$int4$60#]
58:	

gmtime$9:	; IntegralToIntegral £temporary3338 £temporary3337
61:		cmp eax, 0
62:		jge gmtime$10
63:		neg eax
65:		neg ax
67:	

gmtime$10:	; Assign g_timeStruct$tm_min £temporary3338
68:		mov [@7624$g_timeStruct + 2], ax
70:	

gmtime$11:	; SignedModulo £temporary3340 secondsOfHour 60
71:		mov eax, [bp + 16]
73:		xor edx, edx
74:		idiv dword [@7651$int4$60#]
80:	

gmtime$12:	; IntegralToIntegral £temporary3341 £temporary3340
83:		cmp edx, 0
84:		jge gmtime$13
85:		neg edx
87:		neg dx
89:	

gmtime$13:	; Assign g_timeStruct$tm_sec £temporary3341
90:		mov [@7624$g_timeStruct], dx
92:	

gmtime$14:	; SignedDivide totalDays time 86400
93:		mov eax, [bp + 8]
95:		xor edx, edx
96:		idiv dword [@7655$int4$86400#]
97:		mov [bp + 20], eax
99:	

gmtime$15:	; SignedGreaterThanEqual 20 totalDays 3
100:		cmp dword [bp + 20], 3
101:		jge gmtime$20
103:	

gmtime$16:	; BinaryAdd £temporary3345 totalDays 4
104:		mov eax, [bp + 20]
105:		add eax, 4
107:	

gmtime$17:	; IntegralToIntegral £temporary3346 £temporary3345
110:		cmp eax, 0
111:		jge gmtime$18
112:		neg eax
114:		neg ax
116:	

gmtime$18:	; Assign g_timeStruct$tm_wday £temporary3346
117:		mov [@7624$g_timeStruct + 12], ax
119:	

gmtime$19:	; Goto 24
120:		jmp gmtime$24
122:	

gmtime$20:	; BinarySubtract £temporary3348 totalDays 3
123:		mov eax, [bp + 20]
124:		sub eax, 3
126:	

gmtime$21:	; SignedModulo £temporary3349 £temporary3348 7
128:		xor edx, edx
129:		idiv dword [@7671$int4$7#]
135:	

gmtime$22:	; IntegralToIntegral £temporary3350 £temporary3349
138:		cmp edx, 0
139:		jge gmtime$23
140:		neg edx
142:		neg dx
144:	

gmtime$23:	; Assign g_timeStruct$tm_wday £temporary3350
145:		mov [@7624$g_timeStruct + 12], dx
147:	

gmtime$24:	; SignedDivide £temporary3351 totalDays 365
148:		mov eax, [bp + 20]
150:		xor edx, edx
151:		idiv dword [@7676$int4$365#]
157:	

gmtime$25:	; BinaryAdd £temporary3352 £temporary3351 1970
158:		add eax, 1970
160:	

gmtime$26:	; IntegralToIntegral £temporary3353 £temporary3352
163:		cmp eax, 0
164:		jge gmtime$27
165:		neg eax
167:		neg ax
169:	

gmtime$27:	; Assign year £temporary3353
170:		mov [bp + 24], ax
172:	

gmtime$28:	; BinarySubtract £temporary3354 year 1969
173:		mov ax, [bp + 24]
174:		sub ax, 1969
176:	

gmtime$29:	; SignedDivide leapDays £temporary3354 4
178:		xor dx, dx
179:		idiv word [@7686$int2$4#]
180:		mov [bp + 26], ax
182:	

gmtime$30:	; SignedModulo totalDays totalDays 365
183:		mov eax, [bp + 20]
185:		xor edx, edx
186:		idiv dword [@7690$int4$365#]
187:		mov [bp + 20], edx
189:	

gmtime$31:	; IntegralToIntegral £temporary3357 leapDays
190:		mov ax, [bp + 26]
192:		and eax, 65535
194:		cmp ax, 0
195:		jge gmtime$32
196:		neg ax
198:		neg eax
200:	

gmtime$32:	; BinarySubtract totalDays totalDays £temporary3357
201:		sub [bp + 20], eax
203:	

gmtime$33:	; SignedGreaterThanEqual 44 totalDays 0
204:		cmp dword [bp + 20], 0
205:		jge gmtime$44
207:	

gmtime$34:	; Decrement year
208:		dec word [bp + 24]
210:	

gmtime$35:	; CallHeader 28 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
212:	

gmtime$36:	; Parameter 28 year 6
213:		mov ax, [bp + 24]
214:		mov [bp + 34], ax
216:	

gmtime$37:	; Call 28 isLeapYear 0
217:		mov word [bp + 28], gmtime$38
218:		mov [bp + 30], bp
219:		add bp, 28
220:		jmp @7420$isLeapYear
222:	

gmtime$38:	; PostCall 28
224:	

gmtime$39:	; GetReturnValue £temporary3361
226:	

gmtime$40:	; Equal 43 £temporary3361 0
227:		cmp bx, 0
228:		je gmtime$43
230:	

gmtime$41:	; BinaryAdd totalDays totalDays 366
231:		add dword [bp + 20], 366
233:	

gmtime$42:	; Goto 44
234:		jmp gmtime$44
236:	

gmtime$43:	; BinaryAdd totalDays totalDays 365
237:		add dword [bp + 20], 365
239:	

gmtime$44:	; BinarySubtract g_timeStruct$tm_year year 1900
240:		mov ax, [bp + 24]
241:		sub ax, 1900
242:		mov [@7624$g_timeStruct + 10], ax
244:	

gmtime$45:	; IntegralToIntegral £temporary3368 totalDays
245:		mov eax, [bp + 20]
248:		cmp eax, 0
249:		jge gmtime$46
250:		neg eax
252:		neg ax
254:	

gmtime$46:	; Assign g_timeStruct$tm_yday £temporary3368
255:		mov [@7624$g_timeStruct + 14], ax
257:	

gmtime$47:	; Assign daysOfMonths[0] 31
258:		mov word [bp + 28], 31
260:	

gmtime$48:	; CallHeader 30 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
262:	

gmtime$49:	; Parameter 30 year 6
263:		mov ax, [bp + 24]
264:		mov [bp + 36], ax
266:	

gmtime$50:	; Call 30 isLeapYear 0
267:		mov word [bp + 30], gmtime$51
268:		mov [bp + 32], bp
269:		add bp, 30
270:		jmp @7420$isLeapYear
272:	

gmtime$51:	; PostCall 30
274:	

gmtime$52:	; GetReturnValue £temporary3369
276:	

gmtime$53:	; Equal 56 £temporary3369 0
277:		cmp bx, 0
278:		je gmtime$56
280:	

gmtime$54:	; Assign £temporary3374 29
281:		mov ax, 29
283:	

gmtime$55:	; Goto 57
284:		jmp gmtime$57
286:	

gmtime$56:	; Assign £temporary3374 28
287:		mov ax, 28
289:	

gmtime$57:	; Assign daysOfMonths[1] £temporary3374
290:		mov [bp + 30], ax
292:	

gmtime$58:	; Assign daysOfMonths[2] 31
293:		mov word [bp + 32], 31
295:	

gmtime$59:	; Assign daysOfMonths[3] 30
296:		mov word [bp + 34], 30
298:	

gmtime$60:	; Assign daysOfMonths[4] 31
299:		mov word [bp + 36], 31
301:	

gmtime$61:	; Assign daysOfMonths[5] 30
302:		mov word [bp + 38], 30
304:	

gmtime$62:	; Assign daysOfMonths[6] 31
305:		mov word [bp + 40], 31
307:	

gmtime$63:	; Assign daysOfMonths[7] 31
308:		mov word [bp + 42], 31
310:	

gmtime$64:	; Assign daysOfMonths[8] 30
311:		mov word [bp + 44], 30
313:	

gmtime$65:	; Assign daysOfMonths[9] 31
314:		mov word [bp + 46], 31
316:	

gmtime$66:	; Assign daysOfMonths[10] 30
317:		mov word [bp + 48], 30
319:	

gmtime$67:	; Assign daysOfMonths[11] 31
320:		mov word [bp + 50], 31
322:	

gmtime$68:	; Assign month 0
323:		mov word [bp + 52], 0
325:	

gmtime$69:	; SignedMultiply £temporary3388 month 2
326:		mov ax, [bp + 52]
328:		xor dx, dx
329:		imul word [@7766$int2$2#]
335:	

gmtime$70:	; BinaryAdd £temporary3389 daysOfMonths £temporary3388
336:		mov si, bp
337:		add si, 28
338:		add si, ax
340:	

gmtime$71:	; Deref £temporary3387 -> £temporary3389 £temporary3389 0
342:	

gmtime$72:	; IntegralToIntegral £temporary3390 £temporary3387 -> £temporary3389
343:		mov ax, [si]
345:		and eax, 65535
347:		cmp ax, 0
348:		jge gmtime$73
349:		neg ax
351:		neg eax
353:	

gmtime$73:	; SignedLessThan 82 totalDays £temporary3390
354:		cmp [bp + 20], eax
355:		jl gmtime$82
357:	

gmtime$74:	; Assign £temporary3392 month
358:		mov ax, [bp + 52]
360:	

gmtime$75:	; Increment month
361:		inc word [bp + 52]
363:	

gmtime$76:	; SignedMultiply £temporary3394 £temporary3392 2
365:		xor dx, dx
366:		imul word [@7774$int2$2#]
372:	

gmtime$77:	; BinaryAdd £temporary3395 daysOfMonths £temporary3394
373:		mov si, bp
374:		add si, 28
375:		add si, ax
377:	

gmtime$78:	; Deref £temporary3393 -> £temporary3395 £temporary3395 0
379:	

gmtime$79:	; IntegralToIntegral £temporary3396 £temporary3393 -> £temporary3395
380:		mov ax, [si]
382:		and eax, 65535
384:		cmp ax, 0
385:		jge gmtime$80
386:		neg ax
388:		neg eax
390:	

gmtime$80:	; BinarySubtract totalDays totalDays £temporary3396
391:		sub [bp + 20], eax
393:	

gmtime$81:	; Goto 69
394:		jmp gmtime$69
396:	

gmtime$82:	; Assign g_timeStruct$tm_mon month
397:		mov ax, [bp + 52]
398:		mov [@7624$g_timeStruct + 8], ax
400:	

gmtime$83:	; BinaryAdd £temporary3400 totalDays 1
401:		mov eax, [bp + 20]
402:		add eax, 1
404:	

gmtime$84:	; IntegralToIntegral £temporary3401 £temporary3400
407:		cmp eax, 0
408:		jge gmtime$85
409:		neg eax
411:		neg ax
413:	

gmtime$85:	; Assign g_timeStruct$tm_mday £temporary3401
414:		mov [@7624$g_timeStruct + 6], ax
416:	

gmtime$86:	; Assign g_timeStruct$tm_isdst -1
417:		mov word [@7624$g_timeStruct + 16], -1
419:	

gmtime$87:	; SetReturnValue (@7624$g_timeStruct,0)
420:		mov bx, @7624$g_timeStruct
422:	

gmtime$88:	; Return (@7624$g_timeStruct,0)
423:		mov ax, [bp]
424:		mov di, [bp + 4]
425:		mov bp, [bp + 2]
426:		jmp ax
428:	

gmtime$89:	; SetReturnValue 0
429:		mov bx, 0
431:	

gmtime$90:	; Return 0
432:		mov ax, [bp]
433:		mov di, [bp + 4]
434:		mov bp, [bp + 2]
435:		jmp ax
437:	

gmtime$91:	; FunctionEnd gmtime
1:	

localtime:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

localtime$1:	; Parameter 8 timePtr 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

localtime$2:	; Call 8 gmtime 0
8:		mov word [bp + 8], localtime$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp gmtime
13:	

localtime$3:	; PostCall 8
15:	

localtime$4:	; GetReturnValue £temporary3405
17:	

localtime$5:	; Assign tmPtr £temporary3405
18:		mov [bp + 8], bx
20:	

localtime$6:	; Deref £temporary3406 -> timePtr timePtr 0
21:		mov si, [bp + 6]
23:	

localtime$7:	; Assign t £temporary3406 -> timePtr
24:		mov eax, [si]
25:		mov [bp + 10], eax
27:	

localtime$8:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
29:	

localtime$9:	; Call 14 localeconv 0
30:		mov word [bp + 14], localtime$10
31:		mov [bp + 16], bp
32:		add bp, 14
33:		jmp localeconv
35:	

localtime$10:	; PostCall 14
37:	

localtime$11:	; GetReturnValue £temporary3407
39:	

localtime$12:	; Assign localeConvPtr £temporary3407
40:		mov [bp + 14], bx
42:	

localtime$13:	; Equal 25 localeConvPtr 0
43:		cmp word [bp + 14], 0
44:		je localtime$25
46:	

localtime$14:	; Deref £temporary3409 -> tmPtr tmPtr 16
47:		mov si, [bp + 8]
49:	

localtime$15:	; NotEqual 19 £temporary3409 -> tmPtr 1
50:		cmp word [si + 16], 1
51:		jne localtime$19
53:	

localtime$16:	; Deref £temporary3411 -> localeConvPtr localeConvPtr 0
54:		mov si, [bp + 14]
56:	

localtime$17:	; Assign £temporary3416 £temporary3411 -> localeConvPtr
57:		mov ax, [si]
59:	

localtime$18:	; Goto 21
60:		jmp localtime$21
62:	

localtime$19:	; Deref £temporary3412 -> localeConvPtr localeConvPtr 2
63:		mov si, [bp + 14]
65:	

localtime$20:	; Assign £temporary3416 £temporary3412 -> localeConvPtr
66:		mov ax, [si + 2]
68:	

localtime$21:	; Assign timeZone £temporary3416
69:		mov [bp + 16], ax
71:	

localtime$22:	; IntegralToIntegral £temporary3417 timeZone
72:		mov ax, [bp + 16]
74:		and eax, 65535
76:		cmp ax, 0
77:		jge localtime$23
78:		neg ax
80:		neg eax
82:	

localtime$23:	; SignedMultiply £temporary3418 £temporary3417 3600
84:		xor edx, edx
85:		imul dword [@7819$int4$3600#]
91:	

localtime$24:	; BinaryAdd t t £temporary3418
92:		add [bp + 10], eax
94:	

localtime$25:	; CallHeader 16 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
96:	

localtime$26:	; address £temporary3420 t
97:		mov si, bp
98:		add si, 10
100:	

localtime$27:	; Parameter 16 £temporary3420 6
101:		mov [bp + 22], si
103:	

localtime$28:	; Call 16 gmtime 0
104:		mov word [bp + 16], localtime$29
105:		mov [bp + 18], bp
106:		add bp, 16
107:		jmp gmtime
109:	

localtime$29:	; PostCall 16
111:	

localtime$30:	; GetReturnValue £temporary3421
113:	

localtime$31:	; SetReturnValue £temporary3421
115:	

localtime$32:	; Return £temporary3421
116:		mov ax, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp ax
121:	

localtime$33:	; FunctionEnd localtime
1:	

difftime:	; BinarySubtract £temporary3425 time2 time1
2:		mov eax, [bp + 10]
3:		sub eax, [bp + 6]
5:	

difftime$1:	; IntegralToFloating £temporary3426 £temporary3425
6:		mov [container4bytes#], eax
7:		fild dword [container4bytes#]
9:	

difftime$2:	; SetReturnValue £temporary3426
11:	

difftime$3:	; Return £temporary3426
12:		mov ax, [bp]
13:		mov di, [bp + 4]
14:		mov bp, [bp + 2]
15:		jmp ax
17:	

difftime$4:	; FunctionEnd difftime
1:	

asctime:	; Assign localeConvPtr 0
2:		mov word [bp + 8], 0
4:	

asctime$1:	; Equal 7 localeConvPtr 0
5:		cmp word [bp + 8], 0
6:		je asctime$7
8:	

asctime$2:	; Deref £temporary3428 -> localeConvPtr localeConvPtr 4
9:		mov si, [bp + 8]
11:	

asctime$3:	; Equal 7 £temporary3428 -> localeConvPtr 0
12:		cmp word [si + 4], 0
13:		je asctime$7
15:	

asctime$4:	; Deref £temporary3431 -> localeConvPtr localeConvPtr 4
16:		mov si, [bp + 8]
18:	

asctime$5:	; Assign shortDayList £temporary3431 -> localeConvPtr
19:		mov ax, [si + 4]
20:		mov [bp + 10], ax
22:	

asctime$6:	; Goto 8
23:		jmp asctime$8
25:	

asctime$7:	; Assign shortDayList g_shortDayList
26:		mov word [bp + 10], @7842$g_shortDayList
28:	

asctime$8:	; Equal 14 localeConvPtr 0
29:		cmp word [bp + 8], 0
30:		je asctime$14
32:	

asctime$9:	; Deref £temporary3433 -> localeConvPtr localeConvPtr 8
33:		mov si, [bp + 8]
35:	

asctime$10:	; Equal 14 £temporary3433 -> localeConvPtr 0
36:		cmp word [si + 8], 0
37:		je asctime$14
39:	

asctime$11:	; Deref £temporary3436 -> localeConvPtr localeConvPtr 8
40:		mov si, [bp + 8]
42:	

asctime$12:	; Assign shortMonthList £temporary3436 -> localeConvPtr
43:		mov ax, [si + 8]
44:		mov [bp + 12], ax
46:	

asctime$13:	; Goto 15
47:		jmp asctime$15
49:	

asctime$14:	; Assign shortMonthList g_shortMonthList
50:		mov word [bp + 12], @7863$g_shortMonthList
52:	

asctime$15:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
54:	

asctime$16:	; Parameter 14 g_timeString 6
55:		mov word [bp + 20], @7834$g_timeString
57:	

asctime$17:	; Parameter 14 string_25s2025s2025i202502i3A2502i3A2502i2025i# 8
58:		mov word [bp + 22], @7905$string_25s2025s2025i202502i3A2502i3A2502i2025i#
60:	

asctime$18:	; Deref £temporary3437 -> tp tp 12
61:		mov si, [bp + 6]
63:	

asctime$19:	; SignedMultiply £temporary3439 £temporary3437 -> tp 2
64:		mov ax, [si + 12]
66:		xor dx, dx
67:		imul word [@7908$int2$2#]
73:	

asctime$20:	; BinaryAdd £temporary3440 shortDayList £temporary3439
74:		mov si, [bp + 10]
75:		add si, ax
77:	

asctime$21:	; Deref £temporary3438 -> £temporary3440 £temporary3440 0
79:	

asctime$22:	; Parameter 14 £temporary3438 -> £temporary3440 10
80:		mov ax, [si]
81:		mov [bp + 24], ax
83:	

asctime$23:	; Deref £temporary3441 -> tp tp 8
84:		mov si, [bp + 6]
86:	

asctime$24:	; SignedMultiply £temporary3443 £temporary3441 -> tp 2
87:		mov ax, [si + 8]
89:		xor dx, dx
90:		imul word [@7913$int2$2#]
96:	

asctime$25:	; BinaryAdd £temporary3444 shortMonthList £temporary3443
97:		mov si, [bp + 12]
98:		add si, ax
100:	

asctime$26:	; Deref £temporary3442 -> £temporary3444 £temporary3444 0
102:	

asctime$27:	; Parameter 14 £temporary3442 -> £temporary3444 12
103:		mov ax, [si]
104:		mov [bp + 26], ax
106:	

asctime$28:	; Deref £temporary3445 -> tp tp 6
107:		mov si, [bp + 6]
109:	

asctime$29:	; Parameter 14 £temporary3445 -> tp 14
110:		mov ax, [si + 6]
111:		mov [bp + 28], ax
113:	

asctime$30:	; Deref £temporary3446 -> tp tp 4
114:		mov si, [bp + 6]
116:	

asctime$31:	; Parameter 14 £temporary3446 -> tp 16
117:		mov ax, [si + 4]
118:		mov [bp + 30], ax
120:	

asctime$32:	; Deref £temporary3447 -> tp tp 2
121:		mov si, [bp + 6]
123:	

asctime$33:	; Parameter 14 £temporary3447 -> tp 18
124:		mov ax, [si + 2]
125:		mov [bp + 32], ax
127:	

asctime$34:	; Deref £temporary3448 -> tp tp 0
128:		mov si, [bp + 6]
130:	

asctime$35:	; Parameter 14 £temporary3448 -> tp 20
131:		mov ax, [si]
132:		mov [bp + 34], ax
134:	

asctime$36:	; Deref £temporary3449 -> tp tp 10
135:		mov si, [bp + 6]
137:	

asctime$37:	; BinaryAdd £temporary3450 £temporary3449 -> tp 1900
138:		mov ax, [si + 10]
139:		add ax, 1900
141:	

asctime$38:	; Parameter 14 £temporary3450 22
142:		mov [bp + 36], ax
144:	

asctime$39:	; Call 14 sprintf 0
145:		mov word [bp + 14], asctime$40
146:		mov [bp + 16], bp
147:		add bp, 14
148:		mov di, bp
149:		add di, 14
150:		jmp sprintf
152:	

asctime$40:	; PostCall 14
154:	

asctime$41:	; SetReturnValue g_timeString
155:		mov bx, @7834$g_timeString
157:	

asctime$42:	; Return g_timeString
158:		mov ax, [bp]
159:		mov di, [bp + 4]
160:		mov bp, [bp + 2]
161:		jmp ax
163:	

asctime$43:	; FunctionEnd asctime
1:	

ctime:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

ctime$1:	; CallHeader 8 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
5:	

ctime$2:	; Parameter 8 time 6
6:		mov ax, [bp + 6]
7:		mov [bp + 14], ax
9:	

ctime$3:	; Call 8 localtime 0
10:		mov word [bp + 8], ctime$4
11:		mov [bp + 10], bp
12:		add bp, 8
13:		jmp localtime
15:	

ctime$4:	; PostCall 8
17:	

ctime$5:	; GetReturnValue £temporary3461
19:	

ctime$6:	; Parameter 8 £temporary3461 6
20:		mov [bp + 14], bx
22:	

ctime$7:	; Call 8 asctime 0
23:		mov word [bp + 8], ctime$8
24:		mov [bp + 10], bp
25:		add bp, 8
26:		jmp asctime
28:	

ctime$8:	; PostCall 8
30:	

ctime$9:	; GetReturnValue £temporary3462
32:	

ctime$10:	; SetReturnValue £temporary3462
34:	

ctime$11:	; Return £temporary3462
35:		mov ax, [bp]
36:		mov di, [bp + 4]
37:		mov bp, [bp + 2]
38:		jmp ax
40:	

ctime$12:	; FunctionEnd ctime
1:	

strftime:	; CallHeader 14 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
3:	

strftime$1:	; Call 14 localeconv 0
4:		mov word [bp + 14], strftime$2
5:		mov [bp + 16], bp
6:		add bp, 14
7:		jmp localeconv
9:	

strftime$2:	; PostCall 14
11:	

strftime$3:	; GetReturnValue £temporary3465
13:	

strftime$4:	; Assign localeConvPtr £temporary3465
14:		mov [bp + 14], bx
16:	

strftime$5:	; Equal 11 localeConvPtr 0
17:		cmp word [bp + 14], 0
18:		je strftime$11
20:	

strftime$6:	; Deref £temporary3467 -> localeConvPtr localeConvPtr 4
21:		mov si, [bp + 14]
23:	

strftime$7:	; Equal 11 £temporary3467 -> localeConvPtr 0
24:		cmp word [si + 4], 0
25:		je strftime$11
27:	

strftime$8:	; Deref £temporary3470 -> localeConvPtr localeConvPtr 4
28:		mov si, [bp + 14]
30:	

strftime$9:	; Assign shortDayList £temporary3470 -> localeConvPtr
31:		mov ax, [si + 4]
32:		mov [bp + 16], ax
34:	

strftime$10:	; Goto 12
35:		jmp strftime$12
37:	

strftime$11:	; Assign shortDayList g_shortDayList
38:		mov word [bp + 16], @7842$g_shortDayList
40:	

strftime$12:	; Equal 18 localeConvPtr 0
41:		cmp word [bp + 14], 0
42:		je strftime$18
44:	

strftime$13:	; Deref £temporary3472 -> localeConvPtr localeConvPtr 6
45:		mov si, [bp + 14]
47:	

strftime$14:	; Equal 18 £temporary3472 -> localeConvPtr 0
48:		cmp word [si + 6], 0
49:		je strftime$18
51:	

strftime$15:	; Deref £temporary3475 -> localeConvPtr localeConvPtr 6
52:		mov si, [bp + 14]
54:	

strftime$16:	; Assign longDayList £temporary3475 -> localeConvPtr
55:		mov ax, [si + 6]
56:		mov [bp + 20], ax
58:	

strftime$17:	; Goto 19
59:		jmp strftime$19
61:	

strftime$18:	; Assign longDayList g_longDayList
62:		mov word [bp + 20], @7850$g_longDayList
64:	

strftime$19:	; Equal 25 localeConvPtr 0
65:		cmp word [bp + 14], 0
66:		je strftime$25
68:	

strftime$20:	; Deref £temporary3477 -> localeConvPtr localeConvPtr 8
69:		mov si, [bp + 14]
71:	

strftime$21:	; Equal 25 £temporary3477 -> localeConvPtr 0
72:		cmp word [si + 8], 0
73:		je strftime$25
75:	

strftime$22:	; Deref £temporary3480 -> localeConvPtr localeConvPtr 8
76:		mov si, [bp + 14]
78:	

strftime$23:	; Assign shortMonthList £temporary3480 -> localeConvPtr
79:		mov ax, [si + 8]
80:		mov [bp + 18], ax
82:	

strftime$24:	; Goto 26
83:		jmp strftime$26
85:	

strftime$25:	; Assign shortMonthList g_shortMonthList
86:		mov word [bp + 18], @7863$g_shortMonthList
88:	

strftime$26:	; Equal 32 localeConvPtr 0
89:		cmp word [bp + 14], 0
90:		je strftime$32
92:	

strftime$27:	; Deref £temporary3482 -> localeConvPtr localeConvPtr 10
93:		mov si, [bp + 14]
95:	

strftime$28:	; Equal 32 £temporary3482 -> localeConvPtr 0
96:		cmp word [si + 10], 0
97:		je strftime$32
99:	

strftime$29:	; Deref £temporary3485 -> localeConvPtr localeConvPtr 10
100:		mov si, [bp + 14]
102:	

strftime$30:	; Assign longMonthList £temporary3485 -> localeConvPtr
103:		mov ax, [si + 10]
104:		mov [bp + 22], ax
106:	

strftime$31:	; Goto 33
107:		jmp strftime$33
109:	

strftime$32:	; Assign longMonthList g_longMonthList
110:		mov word [bp + 22], @7876$g_longMonthList
112:	

strftime$33:	; CallHeader 24 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
114:	

strftime$34:	; Parameter 24 result 6
115:		mov ax, [bp + 6]
116:		mov [bp + 30], ax
118:	

strftime$35:	; Parameter 24 string_# 8
119:		mov word [bp + 32], @7990$string_#
121:	

strftime$36:	; Call 24 strcpy 0
122:		mov word [bp + 24], strftime$37
123:		mov [bp + 26], bp
124:		add bp, 24
125:		jmp strcpy
127:	

strftime$37:	; PostCall 24
129:	

strftime$38:	; CallHeader 26 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
131:	

strftime$39:	; Parameter 26 tp 6
132:		mov ax, [bp + 12]
133:		mov [bp + 32], ax
135:	

strftime$40:	; Call 26 getWeekNumber 0
136:		mov word [bp + 26], strftime$41
137:		mov [bp + 28], bp
138:		add bp, 26
139:		jmp getWeekNumber
141:	

strftime$41:	; PostCall 26
143:	

strftime$42:	; GetReturnValue £temporary3487
145:	

strftime$43:	; Assign weekNumberStartSunday £temporary3487
146:		mov [bp + 26], bx
148:	

strftime$44:	; Assign weekNumberStartMonday weekNumberStartSunday
149:		mov ax, [bp + 26]
150:		mov [bp + 28], ax
152:	

strftime$45:	; Deref £temporary3488 -> tp tp 6
153:		mov si, [bp + 12]
155:	

strftime$46:	; NotEqual 48 £temporary3488 -> tp 0
156:		cmp word [si + 6], 0
157:		jne strftime$48
159:	

strftime$47:	; Decrement weekNumberStartMonday
160:		dec word [bp + 28]
162:	

strftime$48:	; Assign index 0
163:		mov word [bp + 24], 0
165:	

strftime$49:	; BinaryAdd £temporary3492 format index
166:		mov si, [bp + 10]
167:		add si, [bp + 24]
169:	

strftime$50:	; Deref £temporary3491 -> £temporary3492 £temporary3492 0
171:	

strftime$51:	; Equal 99 £temporary3491 -> £temporary3492 0
172:		cmp byte [si], 0
173:		je strftime$99
175:	

strftime$52:	; BinaryAdd £temporary3496 format index
176:		mov si, [bp + 10]
177:		add si, [bp + 24]
179:	

strftime$53:	; Deref £temporary3495 -> £temporary3496 £temporary3496 0
181:	

strftime$54:	; NotEqual 74 £temporary3495 -> £temporary3496 37
182:		cmp byte [si], 37
183:		jne strftime$74
185:	

strftime$55:	; Increment index
186:		inc word [bp + 24]
188:	

strftime$56:	; Assign £temporary3498 index
189:		mov ax, [bp + 24]
191:	

strftime$57:	; BinaryAdd £temporary3500 format £temporary3498
192:		mov si, [bp + 10]
193:		add si, ax
195:	

strftime$58:	; Deref £temporary3499 -> £temporary3500 £temporary3500 0
197:	

strftime$59:	; Case 62 £temporary3499 -> £temporary3500 112
198:		mov al, [si]
199:		cmp al, 112
200:		je strftime$62
202:	

strftime$60:	; CaseEnd £temporary3499 -> £temporary3500
204:	

strftime$61:	; Goto 80
205:		jmp strftime$80
207:	

strftime$62:	; CallHeader 50 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
209:	

strftime$63:	; Parameter 50 add 6
210:		mov [bp + 56], bp
211:		add word [bp + 56], 30
213:	

strftime$64:	; Parameter 50 string_25s# 8
214:		mov word [bp + 58], @8025$string_25s#
216:	

strftime$65:	; Deref £temporary3501 -> tp tp 4
217:		mov si, [bp + 12]
219:	

strftime$66:	; SignedGreaterThanEqual 69 £temporary3501 -> tp 12
220:		cmp word [si + 4], 12
221:		jge strftime$69
223:	

strftime$67:	; Assign £temporary3506 string_AM#
224:		mov ax, @8030$string_AM#
226:	

strftime$68:	; Goto 70
227:		jmp strftime$70
229:	

strftime$69:	; Assign £temporary3506 string_PM#
230:		mov ax, @8031$string_PM#
232:	

strftime$70:	; Parameter 50 £temporary3506 10
233:		mov [bp + 60], ax
235:	

strftime$71:	; Call 50 sprintf 0
236:		mov word [bp + 50], strftime$72
237:		mov [bp + 52], bp
238:		add bp, 50
239:		mov di, bp
240:		add di, 2
241:		jmp sprintf
243:	

strftime$72:	; PostCall 50
245:	

strftime$73:	; Goto 80
246:		jmp strftime$80
248:	

strftime$74:	; Deref £temporary3508 -> add add 0
249:		mov si, bp
250:		add si, 30
252:	

strftime$75:	; BinaryAdd £temporary3510 format index
253:		mov di, [bp + 10]
254:		add di, [bp + 24]
256:	

strftime$76:	; Deref £temporary3509 -> £temporary3510 £temporary3510 0
258:	

strftime$77:	; Assign £temporary3508 -> add £temporary3509 -> £temporary3510
259:		mov al, [di]
260:		mov [si], al
262:	

strftime$78:	; Deref £temporary3511 -> add add 1
263:		mov si, bp
264:		add si, 30
266:	

strftime$79:	; Assign £temporary3511 -> add 0
267:		mov byte [si + 1], 0
269:	

strftime$80:	; CallHeader 58 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
271:	

strftime$81:	; Parameter 58 result 6
272:		mov ax, [bp + 6]
273:		mov [bp + 64], ax
275:	

strftime$82:	; Call 58 strlen 0
276:		mov word [bp + 58], strftime$83
277:		mov [bp + 60], bp
278:		add bp, 58
279:		jmp strlen
281:	

strftime$83:	; PostCall 58
283:	

strftime$84:	; GetReturnValue £temporary3512
285:	

strftime$85:	; CallHeader 58 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
286:		mov [bp + 58], bx
288:	

strftime$86:	; Parameter 58 add 6
289:		mov [bp + 66], bp
290:		add word [bp + 66], 30
292:	

strftime$87:	; Call 58 strlen 0
293:		mov word [bp + 60], strftime$88
294:		mov [bp + 62], bp
295:		add bp, 60
296:		jmp strlen
298:	

strftime$88:	; PostCall 58
299:		mov ax, bx
300:		mov bx, [bp + 58]
302:	

strftime$89:	; GetReturnValue £temporary3513
304:	

strftime$90:	; BinaryAdd £temporary3514 £temporary3512 £temporary3513
305:		add bx, ax
307:	

strftime$91:	; SignedGreaterThanEqual 99 £temporary3514 maxSize
308:		cmp bx, [bp + 8]
309:		jge strftime$99
311:	

strftime$92:	; CallHeader 58 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
313:	

strftime$93:	; Parameter 58 result 6
314:		mov ax, [bp + 6]
315:		mov [bp + 64], ax
317:	

strftime$94:	; Parameter 58 add 8
318:		mov [bp + 66], bp
319:		add word [bp + 66], 30
321:	

strftime$95:	; Call 58 strcat 0
322:		mov word [bp + 58], strftime$96
323:		mov [bp + 60], bp
324:		add bp, 58
325:		jmp strcat
327:	

strftime$96:	; PostCall 58
329:	

strftime$97:	; Increment index
330:		inc word [bp + 24]
332:	

strftime$98:	; Goto 49
333:		jmp strftime$49
335:	

strftime$99:	; CallHeader 24 System.Collections.Generic.HashSet`1[CCompiler.Symbol] 0
337:	

strftime$100:	; Parameter 24 result 6
338:		mov ax, [bp + 6]
339:		mov [bp + 30], ax
341:	

strftime$101:	; Call 24 strlen 0
342:		mov word [bp + 24], strftime$102
343:		mov [bp + 26], bp
344:		add bp, 24
345:		jmp strlen
347:	

strftime$102:	; PostCall 24
349:	

strftime$103:	; GetReturnValue £temporary3517
351:	

strftime$104:	; SetReturnValue £temporary3517
353:	

strftime$105:	; Return £temporary3517
354:		mov ax, [bp]
355:		mov di, [bp + 4]
356:		mov bp, [bp + 2]
357:		jmp ax
359:	

strftime$106:	; FunctionEnd strftime
1:	

getWeekNumber:	; Deref £temporary3529 -> tp tp 10
2:		mov si, [bp + 6]
4:	

getWeekNumber$1:	; BinarySubtract £temporary3530 £temporary3529 -> tp 69
5:		mov ax, [si + 10]
6:		sub ax, 69
8:	

getWeekNumber$2:	; SignedDivide £temporary3531 £temporary3530 4
10:		xor dx, dx
11:		idiv word [@8072$int2$4#]
17:	

getWeekNumber$3:	; IntegralToIntegral £temporary3532 £temporary3531
19:		and eax, 65535
21:		cmp ax, 0
22:		jge getWeekNumber$4
23:		neg ax
25:		neg eax
27:	

getWeekNumber$4:	; Assign leapDays £temporary3532
28:		mov [bp + 8], eax
30:	

getWeekNumber$5:	; Deref £temporary3533 -> tp tp 10
31:		mov si, [bp + 6]
33:	

getWeekNumber$6:	; BinarySubtract £temporary3534 £temporary3533 -> tp 70
34:		mov ax, [si + 10]
35:		sub ax, 70
37:	

getWeekNumber$7:	; SignedMultiply £temporary3535 £temporary3534 365
39:		xor dx, dx
40:		imul word [@8081$int2$365#]
46:	

getWeekNumber$8:	; IntegralToIntegral £temporary3536 £temporary3535
48:		and eax, 65535
50:		cmp ax, 0
51:		jge getWeekNumber$9
52:		neg ax
54:		neg eax
56:	

getWeekNumber$9:	; BinaryAdd £temporary3537 £temporary3536 leapDays
57:		add eax, [bp + 8]
59:	

getWeekNumber$10:	; IntegralToIntegral £temporary3538 £temporary3537
62:		cmp eax, 0
63:		jge getWeekNumber$11
64:		neg eax
66:		neg ax
68:	

getWeekNumber$11:	; Assign totalDays £temporary3538
69:		mov [bp + 12], ax
71:	

getWeekNumber$12:	; SignedGreaterThanEqual 15 totalDays 3
72:		cmp word [bp + 12], 3
73:		jge getWeekNumber$15
75:	

getWeekNumber$13:	; BinaryAdd weekDayJanuaryFirst totalDays 4
76:		mov ax, [bp + 12]
77:		add ax, 4
78:		mov [bp + 14], ax
80:	

getWeekNumber$14:	; Goto 17
81:		jmp getWeekNumber$17
83:	

getWeekNumber$15:	; BinarySubtract £temporary3541 totalDays 3
84:		mov ax, [bp + 12]
85:		sub ax, 3
87:	

getWeekNumber$16:	; SignedModulo weekDayJanuaryFirst £temporary3541 7
89:		xor dx, dx
90:		idiv word [@8098$int2$7#]
91:		mov [bp + 14], dx
93:	

getWeekNumber$17:	; BinarySubtract firstWeekSize 7 weekDayJanuaryFirst
94:		mov ax, 7
95:		sub ax, [bp + 14]
96:		mov [bp + 16], ax
98:	

getWeekNumber$18:	; Deref £temporary3544 -> tp tp 14
99:		mov si, [bp + 6]
101:	

getWeekNumber$19:	; SignedGreaterThanEqual 22 £temporary3544 -> tp firstWeekSize
102:		mov ax, [bp + 16]
103:		cmp [si + 14], ax
104:		jge getWeekNumber$22
106:	

getWeekNumber$20:	; SetReturnValue 0
107:		mov bx, 0
109:	

getWeekNumber$21:	; Return 0
110:		mov ax, [bp]
111:		mov di, [bp + 4]
112:		mov bp, [bp + 2]
113:		jmp ax
115:	

getWeekNumber$22:	; Deref £temporary3546 -> tp tp 14
116:		mov si, [bp + 6]
118:	

getWeekNumber$23:	; BinarySubtract £temporary3547 £temporary3546 -> tp firstWeekSize
119:		mov ax, [si + 14]
120:		sub ax, [bp + 16]
122:	

getWeekNumber$24:	; SignedDivide £temporary3548 £temporary3547 7
124:		xor dx, dx
125:		idiv word [@8111$int2$7#]
131:	

getWeekNumber$25:	; BinaryAdd £temporary3549 £temporary3548 1
132:		add ax, 1
134:	

getWeekNumber$26:	; SetReturnValue £temporary3549
135:		mov bx, ax
137:	

getWeekNumber$27:	; Return £temporary3549
138:		mov ax, [bp]
139:		mov di, [bp + 4]
140:		mov bp, [bp + 2]
141:		jmp ax
143:	

getWeekNumber$28:	; FunctionEnd getWeekNumber
