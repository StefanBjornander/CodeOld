1:	

clock:	; return_value = -1
2:		mov ebx, -1
4:	

clock$1:	; return
5:		mov ax, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp ax
10:	

clock$2:	; function end clock
1:	

time:	; ah = 42
2:		mov ah, 42
4:	

time$1:	; interrupt 33
5:		int 33
7:	

time$2:	; £temporary3418 = cx
9:	

time$3:	; year = £temporary3418 - 1900
10:		sub cx, 1900
11:		mov [bp + 12], cx
13:	

time$4:	; £temporary3420 = dh
15:	

time$5:	; month = £temporary3420 - 1
16:		sub dh, 1
17:		mov [bp + 14], dh
19:	

time$6:	; £temporary3422 = dl
21:	

time$7:	; monthDay = £temporary3422
22:		mov [bp + 15], dl
24:	

time$8:	; ah = 44
25:		mov ah, 44
27:	

time$9:	; interrupt 33
28:		int 33
30:	

time$10:	; £temporary3424 = ch
32:	

time$11:	; hour = £temporary3424
33:		mov [bp + 16], ch
35:	

time$12:	; £temporary3425 = cl
37:	

time$13:	; min = £temporary3425
38:		mov [bp + 17], cl
40:	

time$14:	; £temporary3426 = dh
42:	

time$15:	; sec = £temporary3426
43:		mov [bp + 18], dh
45:	

time$16:	; £temporary3427 = year % 4
46:		mov ax, [bp + 12]
48:		xor dx, dx
49:		idiv word [int2$4#]
55:	

time$17:	; if £temporary3427 != 0 goto 20
56:		cmp dx, 0
57:		jne time$20
59:	

time$18:	; £temporary3429 = 1
60:		mov ax, 1
62:	

time$19:	; goto 21
63:		jmp time$21
65:	

time$20:	; £temporary3429 = 0
66:		mov ax, 0
68:	

time$21:	; leapYear = £temporary3429
69:		mov [bp + 19], ax
71:	

time$22:	; daysOfMonths[0] = 31
72:		mov word [bp + 21], 31
74:	

time$23:	; if leapYear == 0 goto 26
75:		cmp word [bp + 19], 0
76:		je time$26
78:	

time$24:	; £temporary3434 = 29
79:		mov ax, 29
81:	

time$25:	; goto 27
82:		jmp time$27
84:	

time$26:	; £temporary3434 = 28
85:		mov ax, 28
87:	

time$27:	; daysOfMonths[1] = £temporary3434
88:		mov [bp + 23], ax
90:	

time$28:	; daysOfMonths[2] = 31
91:		mov word [bp + 25], 31
93:	

time$29:	; daysOfMonths[3] = 30
94:		mov word [bp + 27], 30
96:	

time$30:	; daysOfMonths[4] = 31
97:		mov word [bp + 29], 31
99:	

time$31:	; daysOfMonths[5] = 30
100:		mov word [bp + 31], 30
102:	

time$32:	; daysOfMonths[6] = 30
103:		mov word [bp + 33], 30
105:	

time$33:	; daysOfMonths[7] = 31
106:		mov word [bp + 35], 31
108:	

time$34:	; daysOfMonths[8] = 30
109:		mov word [bp + 37], 30
111:	

time$35:	; daysOfMonths[9] = 31
112:		mov word [bp + 39], 31
114:	

time$36:	; daysOfMonths[10] = 30
115:		mov word [bp + 41], 30
117:	

time$37:	; daysOfMonths[11] = 31
118:		mov word [bp + 43], 31
120:	

time$38:	; £temporary3447 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
121:		mov al, [bp + 15]
123:		and ax, 255
125:		cmp al, 0
126:		jge time$39
127:		neg al
129:		neg ax
131:	

time$39:	; yearDay = £temporary3447 - 1
132:		sub ax, 1
133:		mov [bp + 45], ax
135:	

time$40:	; mon = 0
136:		mov word [bp + 47], 0
138:	

time$41:	; £temporary3449 = int_to_int month (Signed_Short_Int -> Signed_Int)
139:		mov al, [bp + 14]
141:		and ax, 255
143:		cmp al, 0
144:		jge time$42
145:		neg al
147:		neg ax
149:	

time$42:	; if mon >= £temporary3449 goto 49
150:		cmp [bp + 47], ax
151:		jge time$49
153:	

time$43:	; £temporary3453 = mon * 2
154:		mov ax, [bp + 47]
156:		xor dx, dx
157:		mul word [int2$2#]
163:	

time$44:	; £temporary3454 = daysOfMonths + £temporary3453
164:		mov si, bp
165:		add si, 21
166:		add si, ax
168:	

time$45:	; £temporary3452 -> £temporary3454 = *£temporary3454
170:	

time$46:	; yearDay = yearDay + £temporary3452 -> £temporary3454
171:		mov ax, [si]
172:		add [bp + 45], ax
174:	

time$47:	; ++mon
175:		inc word [bp + 47]
177:	

time$48:	; goto 41
178:		jmp time$41
180:	

time$49:	; £temporary3457 = int_to_int sec (Signed_Short_Int -> Signed_Int)
181:		mov al, [bp + 18]
183:		and ax, 255
185:		cmp al, 0
186:		jge time$50
187:		neg al
189:		neg ax
191:	

time$50:	; s$tm_sec = £temporary3457
192:		mov [bp + 49], ax
194:	

time$51:	; £temporary3459 = int_to_int min (Signed_Short_Int -> Signed_Int)
195:		mov al, [bp + 17]
197:		and ax, 255
199:		cmp al, 0
200:		jge time$52
201:		neg al
203:		neg ax
205:	

time$52:	; s$tm_min = £temporary3459
206:		mov [bp + 51], ax
208:	

time$53:	; £temporary3461 = int_to_int hour (Signed_Short_Int -> Signed_Int)
209:		mov al, [bp + 16]
211:		and ax, 255
213:		cmp al, 0
214:		jge time$54
215:		neg al
217:		neg ax
219:	

time$54:	; s$tm_hour = £temporary3461
220:		mov [bp + 53], ax
222:	

time$55:	; £temporary3463 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
223:		mov al, [bp + 15]
225:		and ax, 255
227:		cmp al, 0
228:		jge time$56
229:		neg al
231:		neg ax
233:	

time$56:	; s$tm_mday = £temporary3463
234:		mov [bp + 55], ax
236:	

time$57:	; £temporary3465 = int_to_int month (Signed_Short_Int -> Signed_Int)
237:		mov al, [bp + 14]
239:		and ax, 255
241:		cmp al, 0
242:		jge time$58
243:		neg al
245:		neg ax
247:	

time$58:	; s$tm_mon = £temporary3465
248:		mov [bp + 57], ax
250:	

time$59:	; s$tm_year = year
251:		mov ax, [bp + 12]
252:		mov [bp + 59], ax
254:	

time$60:	; s$tm_wday = 0
255:		mov word [bp + 61], 0
257:	

time$61:	; s$tm_yday = yearDay
258:		mov ax, [bp + 45]
259:		mov [bp + 63], ax
261:	

time$62:	; s$tm_isdst = 0
262:		mov word [bp + 65], 0
264:	

time$63:	; call header integral zero 0 stack zero 0
266:	

time$64:	; £temporary3470 = &s
267:		mov si, bp
268:		add si, 49
270:	

time$65:	; parameter £temporary3470, offset 6
271:		mov [bp + 73], si
273:	

time$66:	; call function noellipse-noellipse mktime
274:		mov word [bp + 67], time$67
275:		mov [bp + 69], bp
276:		add bp, 67
277:		jmp mktime
279:	

time$67:	; post call
281:	

time$68:	; £temporary3471 = return_value
286:	

time$69:	; time = £temporary3471
287:		mov [bp + 8], ebx
289:	

time$70:	; if timePtr == 0 goto 73
290:		cmp word [bp + 6], 0
291:		je time$73
293:	

time$71:	; £temporary3473 -> timePtr = *timePtr
294:		mov si, [bp + 6]
296:	

time$72:	; £temporary3473 -> timePtr = time
297:		mov eax, [bp + 8]
298:		mov [si], eax
300:	

time$73:	; return_value = time
301:		mov ebx, [bp + 8]
303:	

time$74:	; return
304:		mov ax, [bp]
305:		mov di, [bp + 4]
306:		mov bp, [bp + 2]
307:		jmp ax
309:	

time$75:	; function end time
1:	

mktime:	; if tp == 0 goto 28
2:		cmp word [bp + 6], 0
3:		je mktime$28
5:	

mktime$1:	; £temporary3477 -> tp = *tp, offset 10
6:		mov si, [bp + 6]
8:	

mktime$2:	; £temporary3478 = £temporary3477 -> tp - 69
9:		mov ax, [si + 10]
10:		sub ax, 69
12:	

mktime$3:	; £temporary3479 = £temporary3478 / 4
14:		xor dx, dx
15:		idiv word [int2$4#]
21:	

mktime$4:	; £temporary3480 = int_to_int £temporary3479 (Signed_Int -> Signed_Long_Int)
23:		and eax, 65535
25:		cmp ax, 0
26:		jge mktime$5
27:		neg ax
29:		neg eax
31:	

mktime$5:	; leapDays = £temporary3480
32:		mov [bp + 8], eax
34:	

mktime$6:	; £temporary3481 -> tp = *tp, offset 10
35:		mov si, [bp + 6]
37:	

mktime$7:	; £temporary3482 = £temporary3481 -> tp - 70
38:		mov ax, [si + 10]
39:		sub ax, 70
41:	

mktime$8:	; £temporary3483 = £temporary3482 * 365
43:		xor dx, dx
44:		imul word [int2$365#]
50:	

mktime$9:	; £temporary3484 = int_to_int £temporary3483 (Signed_Int -> Signed_Long_Int)
52:		and eax, 65535
54:		cmp ax, 0
55:		jge mktime$10
56:		neg ax
58:		neg eax
60:	

mktime$10:	; £temporary3485 = £temporary3484 + leapDays
61:		add eax, [bp + 8]
63:	

mktime$11:	; £temporary3486 -> tp = *tp, offset 14
64:		mov si, [bp + 6]
66:	

mktime$12:	; £temporary3487 = int_to_int £temporary3486 -> tp (Signed_Int -> Signed_Long_Int)
67:		mov bx, [si + 14]
69:		and ebx, 65535
71:		cmp bx, 0
72:		jge mktime$13
73:		neg bx
75:		neg ebx
77:	

mktime$13:	; totalDays = £temporary3485 + £temporary3487
78:		add eax, ebx
79:		mov [bp + 12], eax
81:	

mktime$14:	; £temporary3489 = totalDays * 86400
82:		mov eax, [bp + 12]
84:		xor edx, edx
85:		imul dword [int4$86400#]
91:		mov ebx, eax
93:	

mktime$15:	; £temporary3490 -> tp = *tp, offset 4
94:		mov si, [bp + 6]
96:	

mktime$16:	; £temporary3491 = int_to_int £temporary3490 -> tp (Signed_Int -> Signed_Long_Int)
97:		mov ax, [si + 4]
99:		and eax, 65535
101:		cmp ax, 0
102:		jge mktime$17
103:		neg ax
105:		neg eax
107:	

mktime$17:	; £temporary3492 = £temporary3491 * 3600
109:		xor edx, edx
110:		imul dword [int4$3600#]
116:	

mktime$18:	; £temporary3493 = £temporary3489 + £temporary3492
117:		add ebx, eax
119:	

mktime$19:	; £temporary3494 -> tp = *tp, offset 2
120:		mov si, [bp + 6]
122:	

mktime$20:	; £temporary3495 = int_to_int £temporary3494 -> tp (Signed_Int -> Signed_Long_Int)
123:		mov ax, [si + 2]
125:		and eax, 65535
127:		cmp ax, 0
128:		jge mktime$21
129:		neg ax
131:		neg eax
133:	

mktime$21:	; £temporary3496 = £temporary3495 * 60
135:		xor edx, edx
136:		imul dword [int4$60#]
142:	

mktime$22:	; £temporary3497 = £temporary3493 + £temporary3496
143:		add ebx, eax
145:	

mktime$23:	; £temporary3498 -> tp = *tp
146:		mov si, [bp + 6]
148:	

mktime$24:	; £temporary3499 = int_to_int £temporary3498 -> tp (Signed_Int -> Signed_Long_Int)
149:		mov ax, [si]
151:		and eax, 65535
153:		cmp ax, 0
154:		jge mktime$25
155:		neg ax
157:		neg eax
159:	

mktime$25:	; £temporary3500 = £temporary3497 + £temporary3499
160:		add ebx, eax
162:	

mktime$26:	; return_value = £temporary3500
164:	

mktime$27:	; return
165:		mov ax, [bp]
166:		mov di, [bp + 4]
167:		mov bp, [bp + 2]
168:		jmp ax
170:	

mktime$28:	; return_value = 0
171:		mov ebx, 0
173:	

mktime$29:	; return
174:		mov ax, [bp]
175:		mov di, [bp + 4]
176:		mov bp, [bp + 2]
177:		jmp ax
179:	

mktime$30:	; function end mktime
1:	

@30$leapSeconds:	; seconds = 0
2:		mov word [bp + 10], 0
4:	

@30$leapSeconds$1:	; index = 0
5:		mov word [bp + 12], 0
7:	

@30$leapSeconds$2:	; if index >= leapSize goto 23
8:		mov ax, [@29$leapSize]
9:		cmp [bp + 12], ax
10:		jge @30$leapSeconds$23
12:	

@30$leapSeconds$3:	; call header integral zero 0 stack zero 0
14:	

@30$leapSeconds$4:	; parameter t, offset 6
15:		mov eax, [bp + 6]
16:		mov [bp + 20], eax
18:	

@30$leapSeconds$5:	; call header integral zero 0 stack zero 0
20:	

@30$leapSeconds$6:	; £temporary3505 = index * 18
21:		mov ax, [bp + 12]
23:		xor dx, dx
24:		mul word [int2$18#]
30:	

@30$leapSeconds$7:	; £temporary3506 = leapList + £temporary3505
31:		mov si, @28$leapList
32:		add si, ax
34:	

@30$leapSeconds$8:	; £temporary3504 -> £temporary3506 = *£temporary3506
36:	

@30$leapSeconds$9:	; £temporary3507 = &£temporary3504 -> £temporary3506
38:	

@30$leapSeconds$10:	; parameter £temporary3507, offset 16
39:		mov [bp + 30], si
41:	

@30$leapSeconds$11:	; call function noellipse-noellipse mktime
42:		mov word [bp + 24], @30$leapSeconds$12
43:		mov [bp + 26], bp
44:		add bp, 24
45:		jmp mktime
47:	

@30$leapSeconds$12:	; post call
49:	

@30$leapSeconds$13:	; £temporary3508 = return_value
54:	

@30$leapSeconds$14:	; parameter £temporary3508, offset 10
55:		mov [bp + 24], ebx
57:	

@30$leapSeconds$15:	; call function noellipse-noellipse difftime
58:		mov word [bp + 14], @30$leapSeconds$16
59:		mov [bp + 16], bp
60:		add bp, 14
61:		jmp difftime
63:	

@30$leapSeconds$16:	; post call
65:	

@30$leapSeconds$17:	; £temporary3509 = return_value
67:	

@30$leapSeconds$18:	; push 0
68:		fldz
70:	

@30$leapSeconds$19:	; if £temporary3509 < 0 goto 21
71:		fcompp
72:		fstsw ax
73:		sahf
74:		ja @30$leapSeconds$21
76:	

@30$leapSeconds$20:	; ++seconds
77:		inc word [bp + 10]
79:	

@30$leapSeconds$21:	; ++index
80:		inc word [bp + 12]
82:	

@30$leapSeconds$22:	; goto 2
83:		jmp @30$leapSeconds$2
85:	

@30$leapSeconds$23:	; return_value = seconds
86:		mov bx, [bp + 10]
88:	

@30$leapSeconds$24:	; return
89:		mov ax, [bp]
90:		mov di, [bp + 4]
91:		mov bp, [bp + 2]
92:		jmp ax
94:	

@30$leapSeconds$25:	; function end leapSeconds
1:	

gmtime:	; year = 1970
2:		mov word [bp + 8], 1970
4:	

gmtime$1:	; if timePtr == 0 goto 85
5:		cmp word [bp + 6], 0
6:		je gmtime$85
8:	

gmtime$2:	; £temporary3516 -> timePtr = *timePtr
9:		mov si, [bp + 6]
11:	

gmtime$3:	; time = £temporary3516 -> timePtr
12:		mov eax, [si]
13:		mov [bp + 10], eax
15:	

gmtime$4:	; totalDays = time / 86400
16:		mov eax, [bp + 10]
18:		xor edx, edx
19:		idiv dword [int4$86400#]
20:		mov [bp + 14], eax
22:	

gmtime$5:	; secondsOfDay = time % 86400
23:		mov eax, [bp + 10]
25:		xor edx, edx
26:		idiv dword [int4$86400#]
27:		mov [bp + 18], edx
29:	

gmtime$6:	; secondsOfHour = secondsOfDay % 3600
30:		mov eax, [bp + 18]
32:		xor edx, edx
33:		idiv dword [int4$3600#]
34:		mov [bp + 22], edx
36:	

gmtime$7:	; £temporary3521 = secondsOfDay / 3600
37:		mov eax, [bp + 18]
39:		xor edx, edx
40:		idiv dword [int4$3600#]
46:	

gmtime$8:	; £temporary3522 = int_to_int £temporary3521 (Signed_Long_Int -> Signed_Int)
49:		cmp eax, 0
50:		jge gmtime$9
51:		neg eax
53:		neg ax
55:	

gmtime$9:	; g_timeStruct$tm_hour = £temporary3522
56:		mov [@27$g_timeStruct + 4], ax
58:	

gmtime$10:	; £temporary3524 = secondsOfHour / 60
59:		mov eax, [bp + 22]
61:		xor edx, edx
62:		idiv dword [int4$60#]
68:	

gmtime$11:	; £temporary3525 = int_to_int £temporary3524 (Signed_Long_Int -> Signed_Int)
71:		cmp eax, 0
72:		jge gmtime$12
73:		neg eax
75:		neg ax
77:	

gmtime$12:	; g_timeStruct$tm_min = £temporary3525
78:		mov [@27$g_timeStruct + 2], ax
80:	

gmtime$13:	; £temporary3527 = secondsOfHour % 60
81:		mov eax, [bp + 22]
83:		xor edx, edx
84:		idiv dword [int4$60#]
90:	

gmtime$14:	; £temporary3528 = int_to_int £temporary3527 (Signed_Long_Int -> Signed_Int)
93:		cmp edx, 0
94:		jge gmtime$15
95:		neg edx
97:		neg dx
99:	

gmtime$15:	; g_timeStruct$tm_sec = £temporary3528
100:		mov [@27$g_timeStruct], dx
102:	

gmtime$16:	; if totalDays >= 3 goto 21
103:		cmp dword [bp + 14], 3
104:		jge gmtime$21
106:	

gmtime$17:	; £temporary3531 = totalDays + 4
107:		mov eax, [bp + 14]
108:		add eax, 4
110:	

gmtime$18:	; £temporary3532 = int_to_int £temporary3531 (Signed_Long_Int -> Signed_Int)
113:		cmp eax, 0
114:		jge gmtime$19
115:		neg eax
117:		neg ax
119:	

gmtime$19:	; g_timeStruct$tm_wday = £temporary3532
120:		mov [@27$g_timeStruct + 12], ax
122:	

gmtime$20:	; goto 25
123:		jmp gmtime$25
125:	

gmtime$21:	; £temporary3534 = totalDays - 3
126:		mov eax, [bp + 14]
127:		sub eax, 3
129:	

gmtime$22:	; £temporary3535 = £temporary3534 % 7
131:		xor edx, edx
132:		idiv dword [int4$7#]
138:	

gmtime$23:	; £temporary3536 = int_to_int £temporary3535 (Signed_Long_Int -> Signed_Int)
141:		cmp edx, 0
142:		jge gmtime$24
143:		neg edx
145:		neg dx
147:	

gmtime$24:	; g_timeStruct$tm_wday = £temporary3536
148:		mov [@27$g_timeStruct + 12], dx
150:	

gmtime$25:	; £temporary3537 = year % 4
151:		mov ax, [bp + 8]
153:		xor dx, dx
154:		idiv word [int2$4#]
160:	

gmtime$26:	; if £temporary3537 != 0 goto 29
161:		cmp dx, 0
162:		jne gmtime$29
164:	

gmtime$27:	; £temporary3539 = year % 100
165:		mov ax, [bp + 8]
167:		xor dx, dx
168:		idiv word [int2$100#]
174:	

gmtime$28:	; if £temporary3539 != 0 goto 31
175:		cmp dx, 0
176:		jne gmtime$31
178:	

gmtime$29:	; £temporary3542 = year % 400
179:		mov ax, [bp + 8]
181:		xor dx, dx
182:		idiv word [int2$400#]
188:	

gmtime$30:	; if £temporary3542 != 0 goto 33
189:		cmp dx, 0
190:		jne gmtime$33
192:	

gmtime$31:	; £temporary3545 = 1
193:		mov ax, 1
195:	

gmtime$32:	; goto 34
196:		jmp gmtime$34
198:	

gmtime$33:	; £temporary3545 = 0
199:		mov ax, 0
201:	

gmtime$34:	; leapYear = £temporary3545
202:		mov [bp + 26], ax
204:	

gmtime$35:	; if leapYear == 0 goto 38
205:		cmp word [bp + 26], 0
206:		je gmtime$38
208:	

gmtime$36:	; £temporary3550 = 366
209:		mov ax, 366
211:	

gmtime$37:	; goto 39
212:		jmp gmtime$39
214:	

gmtime$38:	; £temporary3550 = 365
215:		mov ax, 365
217:	

gmtime$39:	; daysOfYear = £temporary3550
218:		mov [bp + 28], ax
220:	

gmtime$40:	; £temporary3551 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
221:		mov ax, [bp + 28]
223:		and eax, 65535
225:		cmp ax, 0
226:		jge gmtime$41
227:		neg ax
229:		neg eax
231:	

gmtime$41:	; if totalDays >= £temporary3551 goto 81
232:		cmp [bp + 14], eax
233:		jge gmtime$81
235:	

gmtime$42:	; daysOfMonths[0] = 31
236:		mov word [bp + 30], 31
238:	

gmtime$43:	; if leapYear == 0 goto 46
239:		cmp word [bp + 26], 0
240:		je gmtime$46
242:	

gmtime$44:	; £temporary3557 = 29
243:		mov ax, 29
245:	

gmtime$45:	; goto 47
246:		jmp gmtime$47
248:	

gmtime$46:	; £temporary3557 = 28
249:		mov ax, 28
251:	

gmtime$47:	; daysOfMonths[1] = £temporary3557
252:		mov [bp + 32], ax
254:	

gmtime$48:	; daysOfMonths[2] = 31
255:		mov word [bp + 34], 31
257:	

gmtime$49:	; daysOfMonths[3] = 30
258:		mov word [bp + 36], 30
260:	

gmtime$50:	; daysOfMonths[4] = 31
261:		mov word [bp + 38], 31
263:	

gmtime$51:	; daysOfMonths[5] = 30
264:		mov word [bp + 40], 30
266:	

gmtime$52:	; daysOfMonths[6] = 30
267:		mov word [bp + 42], 30
269:	

gmtime$53:	; daysOfMonths[7] = 31
270:		mov word [bp + 44], 31
272:	

gmtime$54:	; daysOfMonths[8] = 30
273:		mov word [bp + 46], 30
275:	

gmtime$55:	; daysOfMonths[9] = 31
276:		mov word [bp + 48], 31
278:	

gmtime$56:	; daysOfMonths[10] = 30
279:		mov word [bp + 50], 30
281:	

gmtime$57:	; daysOfMonths[11] = 31
282:		mov word [bp + 52], 31
284:	

gmtime$58:	; month = 0
285:		mov word [bp + 54], 0
287:	

gmtime$59:	; g_timeStruct$tm_year = year - 1900
288:		mov ax, [bp + 8]
289:		sub ax, 1900
290:		mov [@27$g_timeStruct], ax
292:	

gmtime$60:	; £temporary3573 = int_to_int totalDays (Signed_Long_Int -> Signed_Int)
293:		mov eax, [bp + 14]
296:		cmp eax, 0
297:		jge gmtime$61
298:		neg eax
300:		neg ax
302:	

gmtime$61:	; g_timeStruct$tm_yday = £temporary3573
303:		mov [@27$g_timeStruct + 14], ax
305:	

gmtime$62:	; £temporary3575 = month * 2
306:		mov ax, [bp + 54]
308:		xor dx, dx
309:		mul word [int2$2#]
315:	

gmtime$63:	; £temporary3576 = daysOfMonths + £temporary3575
316:		mov si, bp
317:		add si, 30
318:		add si, ax
320:	

gmtime$64:	; £temporary3574 -> £temporary3576 = *£temporary3576
322:	

gmtime$65:	; £temporary3577 = int_to_int £temporary3574 -> £temporary3576 (Signed_Int -> Signed_Long_Int)
323:		mov ax, [si]
325:		and eax, 65535
327:		cmp ax, 0
328:		jge gmtime$66
329:		neg ax
331:		neg eax
333:	

gmtime$66:	; if totalDays < £temporary3577 goto 74
334:		cmp [bp + 14], eax
335:		jl gmtime$74
337:	

gmtime$67:	; £temporary3580 = month * 2
338:		mov ax, [bp + 54]
340:		xor dx, dx
341:		mul word [int2$2#]
347:	

gmtime$68:	; £temporary3581 = daysOfMonths + £temporary3580
348:		mov si, bp
349:		add si, 30
350:		add si, ax
352:	

gmtime$69:	; £temporary3579 -> £temporary3581 = *£temporary3581
354:	

gmtime$70:	; £temporary3582 = int_to_int £temporary3579 -> £temporary3581 (Signed_Int -> Signed_Long_Int)
355:		mov ax, [si]
357:		and eax, 65535
359:		cmp ax, 0
360:		jge gmtime$71
361:		neg ax
363:		neg eax
365:	

gmtime$71:	; totalDays = totalDays - £temporary3582
366:		sub [bp + 14], eax
368:	

gmtime$72:	; ++month
369:		inc word [bp + 54]
371:	

gmtime$73:	; goto 62
372:		jmp gmtime$62
374:	

gmtime$74:	; g_timeStruct$tm_mon = month
375:		mov ax, [bp + 54]
376:		mov [@27$g_timeStruct + 8], ax
378:	

gmtime$75:	; £temporary3587 = totalDays + 1
379:		mov eax, [bp + 14]
380:		add eax, 1
382:	

gmtime$76:	; £temporary3588 = int_to_int £temporary3587 (Signed_Long_Int -> Signed_Int)
385:		cmp eax, 0
386:		jge gmtime$77
387:		neg eax
389:		neg ax
391:	

gmtime$77:	; g_timeStruct$tm_mday = £temporary3588
392:		mov [@27$g_timeStruct + 6], ax
394:	

gmtime$78:	; g_timeStruct$tm_isdst = -1
395:		mov word [@27$g_timeStruct + 16], -1
397:	

gmtime$79:	; return_value = (@27$g_timeStruct,0)
398:		mov bx, @27$g_timeStruct
400:	

gmtime$80:	; return
401:		mov ax, [bp]
402:		mov di, [bp + 4]
403:		mov bp, [bp + 2]
404:		jmp ax
406:	

gmtime$81:	; ++year
407:		inc word [bp + 8]
409:	

gmtime$82:	; £temporary3591 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
410:		mov ax, [bp + 28]
412:		and eax, 65535
414:		cmp ax, 0
415:		jge gmtime$83
416:		neg ax
418:		neg eax
420:	

gmtime$83:	; totalDays = totalDays - £temporary3591
421:		sub [bp + 14], eax
423:	

gmtime$84:	; goto 25
424:		jmp gmtime$25
426:	

gmtime$85:	; return_value = 0
427:		mov bx, 0
429:	

gmtime$86:	; return
430:		mov ax, [bp]
431:		mov di, [bp + 4]
432:		mov bp, [bp + 2]
433:		jmp ax
435:	

gmtime$87:	; function end gmtime
1:	

difftime:	; £temporary3594 = time2 - time1
2:		mov eax, [bp + 10]
3:		sub eax, [bp + 6]
5:	

difftime$1:	; £temporary3595 = int_to_float £temporary3594 (Unsigned_Long_Int -> Double)
6:		mov [container4bytes#], eax
7:		fild dword [container4bytes#]
9:	

difftime$2:	; return_value = £temporary3595
11:	

difftime$3:	; return
12:		mov ax, [bp]
13:		mov di, [bp + 4]
14:		mov bp, [bp + 2]
15:		jmp ax
17:	

difftime$4:	; function end difftime
1:	

asctime:	; localeConvPtr = 0
2:		mov word [bp + 8], 0
4:	

asctime$1:	; if localeConvPtr == 0 goto 5
5:		cmp word [bp + 8], 0
6:		je asctime$5
8:	

asctime$2:	; £temporary3597 -> localeConvPtr = *localeConvPtr, offset 4
9:		mov si, [bp + 8]
11:	

asctime$3:	; £temporary3601 = £temporary3597 -> localeConvPtr
12:		mov ax, [si + 4]
14:	

asctime$4:	; goto 6
15:		jmp asctime$6
17:	

asctime$5:	; £temporary3601 = 0
18:		mov ax, 0
20:	

asctime$6:	; shortDayList = £temporary3601
21:		mov [bp + 10], ax
23:	

asctime$7:	; if localeConvPtr == 0 goto 11
24:		cmp word [bp + 8], 0
25:		je asctime$11
27:	

asctime$8:	; £temporary3603 -> localeConvPtr = *localeConvPtr, offset 8
28:		mov si, [bp + 8]
30:	

asctime$9:	; £temporary3607 = £temporary3603 -> localeConvPtr
31:		mov ax, [si + 8]
33:	

asctime$10:	; goto 12
34:		jmp asctime$12
36:	

asctime$11:	; £temporary3607 = 0
37:		mov ax, 0
39:	

asctime$12:	; shortMonthList = £temporary3607
40:		mov [bp + 12], ax
42:	

asctime$13:	; if shortDayList == 0 goto 16
43:		cmp word [bp + 10], 0
44:		je asctime$16
46:	

asctime$14:	; £temporary3612 = shortDayList
47:		mov ax, [bp + 10]
49:	

asctime$15:	; goto 17
50:		jmp asctime$17
52:	

asctime$16:	; £temporary3612 = g_defaultShortDayList
53:		mov ax, @32$g_defaultShortDayList
55:	

asctime$17:	; shortDayList = £temporary3612
56:		mov [bp + 10], ax
58:	

asctime$18:	; if shortMonthList == 0 goto 21
59:		cmp word [bp + 12], 0
60:		je asctime$21
62:	

asctime$19:	; £temporary3617 = shortMonthList
63:		mov ax, [bp + 12]
65:	

asctime$20:	; goto 22
66:		jmp asctime$22
68:	

asctime$21:	; £temporary3617 = g_defaultShortMonthList
69:		mov ax, @34$g_defaultShortMonthList
71:	

asctime$22:	; shortMonthList = £temporary3617
72:		mov [bp + 12], ax
74:	

asctime$23:	; call header integral zero 0 stack zero 0
76:	

asctime$24:	; parameter g_timeString, offset 6
77:		mov word [bp + 20], @31$g_timeString
79:	

asctime$25:	; parameter string_25s2025s2025i2025i3A25i3A25i2025i#, offset 8
80:		mov word [bp + 22], string_25s2025s2025i2025i3A25i3A25i2025i#
82:	

asctime$26:	; £temporary3618 -> tp = *tp, offset 12
83:		mov si, [bp + 6]
85:	

asctime$27:	; £temporary3620 = £temporary3618 -> tp * 2
86:		mov ax, [si + 12]
88:		xor dx, dx
89:		mul word [int2$2#]
95:	

asctime$28:	; £temporary3621 = shortDayList + £temporary3620
96:		mov si, [bp + 10]
97:		add si, ax
99:	

asctime$29:	; £temporary3619 -> £temporary3621 = *£temporary3621
101:	

asctime$30:	; parameter £temporary3619 -> £temporary3621, offset 10
102:		mov ax, [si]
103:		mov [bp + 24], ax
105:	

asctime$31:	; £temporary3622 -> tp = *tp, offset 8
106:		mov si, [bp + 6]
108:	

asctime$32:	; £temporary3624 = £temporary3622 -> tp * 2
109:		mov ax, [si + 8]
111:		xor dx, dx
112:		mul word [int2$2#]
118:	

asctime$33:	; £temporary3625 = shortMonthList + £temporary3624
119:		mov si, [bp + 12]
120:		add si, ax
122:	

asctime$34:	; £temporary3623 -> £temporary3625 = *£temporary3625
124:	

asctime$35:	; parameter £temporary3623 -> £temporary3625, offset 12
125:		mov ax, [si]
126:		mov [bp + 26], ax
128:	

asctime$36:	; £temporary3626 -> tp = *tp, offset 6
129:		mov si, [bp + 6]
131:	

asctime$37:	; parameter £temporary3626 -> tp, offset 14
132:		mov ax, [si + 6]
133:		mov [bp + 28], ax
135:	

asctime$38:	; £temporary3627 -> tp = *tp, offset 4
136:		mov si, [bp + 6]
138:	

asctime$39:	; parameter £temporary3627 -> tp, offset 16
139:		mov ax, [si + 4]
140:		mov [bp + 30], ax
142:	

asctime$40:	; £temporary3628 -> tp = *tp, offset 2
143:		mov si, [bp + 6]
145:	

asctime$41:	; parameter £temporary3628 -> tp, offset 18
146:		mov ax, [si + 2]
147:		mov [bp + 32], ax
149:	

asctime$42:	; £temporary3629 -> tp = *tp
150:		mov si, [bp + 6]
152:	

asctime$43:	; parameter £temporary3629 -> tp, offset 20
153:		mov ax, [si]
154:		mov [bp + 34], ax
156:	

asctime$44:	; £temporary3630 -> tp = *tp, offset 10
157:		mov si, [bp + 6]
159:	

asctime$45:	; £temporary3631 = £temporary3630 -> tp + 1900
160:		mov ax, [si + 10]
161:		add ax, 1900
163:	

asctime$46:	; parameter £temporary3631, offset 22
164:		mov [bp + 36], ax
166:	

asctime$47:	; call function noellipse-ellipse sprintf, extra 0
167:		mov word [bp + 14], asctime$48
168:		mov [bp + 16], bp
169:		add bp, 14
170:		mov di, bp
171:		add di, 14
172:		jmp sprintf
174:	

asctime$48:	; post call
176:	

asctime$49:	; return_value = g_timeString
177:		mov bx, @31$g_timeString
179:	

asctime$50:	; return
180:		mov ax, [bp]
181:		mov di, [bp + 4]
182:		mov bp, [bp + 2]
183:		jmp ax
185:	

asctime$51:	; function end asctime
1:	

ctime:	; call header integral zero 0 stack zero 0
3:	

ctime$1:	; call header integral zero 0 stack zero 0
5:	

ctime$2:	; parameter time, offset 6
6:		mov ax, [bp + 6]
7:		mov [bp + 14], ax
9:	

ctime$3:	; call function noellipse-noellipse localtime
10:		mov word [bp + 8], ctime$4
11:		mov [bp + 10], bp
12:		add bp, 8
13:		jmp localtime
15:	

ctime$4:	; post call
17:	

ctime$5:	; £temporary3642 = return_value
22:	

ctime$6:	; parameter £temporary3642, offset 6
23:		mov [bp + 14], bx
25:	

ctime$7:	; call function noellipse-noellipse asctime
26:		mov word [bp + 8], ctime$8
27:		mov [bp + 10], bp
28:		add bp, 8
29:		jmp asctime
31:	

ctime$8:	; post call
33:	

ctime$9:	; £temporary3643 = return_value
38:	

ctime$10:	; return_value = £temporary3643
40:	

ctime$11:	; return
41:		mov ax, [bp]
42:		mov di, [bp + 4]
43:		mov bp, [bp + 2]
44:		jmp ax
46:	

ctime$12:	; function end ctime
1:	

localtime:	; call header integral zero 0 stack zero 0
3:	

localtime$1:	; parameter timePtr, offset 6
4:		mov ax, [bp + 6]
5:		mov [bp + 14], ax
7:	

localtime$2:	; call function noellipse-noellipse gmtime
8:		mov word [bp + 8], localtime$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp gmtime
13:	

localtime$3:	; post call
15:	

localtime$4:	; £temporary3646 = return_value
20:	

localtime$5:	; tmPtr = £temporary3646
21:		mov [bp + 8], bx
23:	

localtime$6:	; call header integral zero 0 stack zero 0
25:	

localtime$7:	; call function noellipse-noellipse localeconv
26:		mov word [bp + 10], localtime$8
27:		mov [bp + 12], bp
28:		add bp, 10
29:		jmp localeconv
31:	

localtime$8:	; post call
33:	

localtime$9:	; £temporary3647 = return_value
38:	

localtime$10:	; localeConvPtr = £temporary3647
39:		mov [bp + 10], bx
41:	

localtime$11:	; timeZone = 0
42:		mov word [bp + 12], 0
44:	

localtime$12:	; if localeConvPtr == 0 goto 21
45:		cmp word [bp + 10], 0
46:		je localtime$21
48:	

localtime$13:	; £temporary3649 -> tmPtr = *tmPtr, offset 16
49:		mov si, [bp + 8]
51:	

localtime$14:	; if £temporary3649 -> tmPtr == 0 goto 18
52:		cmp word [si + 16], 0
53:		je localtime$18
55:	

localtime$15:	; £temporary3650 -> localeConvPtr = *localeConvPtr
56:		mov si, [bp + 10]
58:	

localtime$16:	; £temporary3656 = £temporary3650 -> localeConvPtr
59:		mov ax, [si]
61:	

localtime$17:	; goto 20
62:		jmp localtime$20
64:	

localtime$18:	; £temporary3651 -> localeConvPtr = *localeConvPtr, offset 2
65:		mov si, [bp + 10]
67:	

localtime$19:	; £temporary3656 = £temporary3651 -> localeConvPtr
68:		mov ax, [si + 2]
70:	

localtime$20:	; timeZone = £temporary3656
71:		mov [bp + 12], ax
73:	

localtime$21:	; £temporary3657 -> timePtr = *timePtr
74:		mov si, [bp + 6]
76:	

localtime$22:	; £temporary3658 = timeZone * 3600
77:		mov ax, [bp + 12]
79:		xor dx, dx
80:		imul word [int2$3600#]
86:	

localtime$23:	; £temporary3659 = int_to_int £temporary3658 (Signed_Int -> Unsigned_Long_Int)
88:		and eax, 65535
90:	

localtime$24:	; time = £temporary3657 -> timePtr + £temporary3659
91:		mov ebx, [si]
92:		add ebx, eax
93:		mov [bp + 14], ebx
95:	

localtime$25:	; call header integral zero 0 stack zero 0
97:	

localtime$26:	; £temporary3661 = &time
98:		mov si, bp
99:		add si, 14
101:	

localtime$27:	; parameter £temporary3661, offset 6
102:		mov [bp + 24], si
104:	

localtime$28:	; call function noellipse-noellipse gmtime
105:		mov word [bp + 18], localtime$29
106:		mov [bp + 20], bp
107:		add bp, 18
108:		jmp gmtime
110:	

localtime$29:	; post call
112:	

localtime$30:	; £temporary3662 = return_value
117:	

localtime$31:	; return_value = £temporary3662
119:	

localtime$32:	; return
120:		mov ax, [bp]
121:		mov di, [bp + 4]
122:		mov bp, [bp + 2]
123:		jmp ax
125:	

localtime$33:	; function end localtime
1:	

strftime:	; call header integral zero 0 stack zero 0
3:	

strftime$1:	; call function noellipse-noellipse localeconv
4:		mov word [bp + 14], strftime$2
5:		mov [bp + 16], bp
6:		add bp, 14
7:		jmp localeconv
9:	

strftime$2:	; post call
11:	

strftime$3:	; £temporary3666 = return_value
16:	

strftime$4:	; localeConvPtr = £temporary3666
17:		mov [bp + 14], bx
19:	

strftime$5:	; if localeConvPtr == 0 goto 9
20:		cmp word [bp + 14], 0
21:		je strftime$9
23:	

strftime$6:	; £temporary3668 -> localeConvPtr = *localeConvPtr, offset 4
24:		mov si, [bp + 14]
26:	

strftime$7:	; £temporary3672 = £temporary3668 -> localeConvPtr
27:		mov ax, [si + 4]
29:	

strftime$8:	; goto 10
30:		jmp strftime$10
32:	

strftime$9:	; £temporary3672 = 0
33:		mov ax, 0
35:	

strftime$10:	; shortDayList = £temporary3672
36:		mov [bp + 16], ax
38:	

strftime$11:	; if localeConvPtr == 0 goto 15
39:		cmp word [bp + 14], 0
40:		je strftime$15
42:	

strftime$12:	; £temporary3674 -> localeConvPtr = *localeConvPtr, offset 8
43:		mov si, [bp + 14]
45:	

strftime$13:	; £temporary3678 = £temporary3674 -> localeConvPtr
46:		mov ax, [si + 8]
48:	

strftime$14:	; goto 16
49:		jmp strftime$16
51:	

strftime$15:	; £temporary3678 = 0
52:		mov ax, 0
54:	

strftime$16:	; shortMonthList = £temporary3678
55:		mov [bp + 18], ax
57:	

strftime$17:	; if localeConvPtr == 0 goto 21
58:		cmp word [bp + 14], 0
59:		je strftime$21
61:	

strftime$18:	; £temporary3680 -> localeConvPtr = *localeConvPtr, offset 6
62:		mov si, [bp + 14]
64:	

strftime$19:	; £temporary3684 = £temporary3680 -> localeConvPtr
65:		mov ax, [si + 6]
67:	

strftime$20:	; goto 22
68:		jmp strftime$22
70:	

strftime$21:	; £temporary3684 = 0
71:		mov ax, 0
73:	

strftime$22:	; longDayList = £temporary3684
74:		mov [bp + 20], ax
76:	

strftime$23:	; if localeConvPtr == 0 goto 27
77:		cmp word [bp + 14], 0
78:		je strftime$27
80:	

strftime$24:	; £temporary3686 -> localeConvPtr = *localeConvPtr, offset 10
81:		mov si, [bp + 14]
83:	

strftime$25:	; £temporary3690 = £temporary3686 -> localeConvPtr
84:		mov ax, [si + 10]
86:	

strftime$26:	; goto 28
87:		jmp strftime$28
89:	

strftime$27:	; £temporary3690 = 0
90:		mov ax, 0
92:	

strftime$28:	; longMonthList = £temporary3690
93:		mov [bp + 22], ax
95:	

strftime$29:	; £temporary3691 -> tp = *tp, offset 10
96:		mov si, [bp + 12]
98:	

strftime$30:	; £temporary3692 = £temporary3691 -> tp - 69
99:		mov ax, [si + 10]
100:		sub ax, 69
102:	

strftime$31:	; leapDays = £temporary3692 / 4
104:		xor dx, dx
105:		idiv word [int2$4#]
106:		mov [bp + 24], ax
108:	

strftime$32:	; £temporary3694 -> tp = *tp, offset 10
109:		mov si, [bp + 12]
111:	

strftime$33:	; £temporary3695 = £temporary3694 -> tp - 70
112:		mov ax, [si + 10]
113:		sub ax, 70
115:	

strftime$34:	; £temporary3696 = £temporary3695 * 365
117:		xor dx, dx
118:		imul word [int2$365#]
124:	

strftime$35:	; £temporary3697 = £temporary3696 + leapDays
125:		add ax, [bp + 24]
127:	

strftime$36:	; £temporary3698 -> tp = *tp, offset 14
128:		mov si, [bp + 12]
130:	

strftime$37:	; £temporary3699 = £temporary3697 + £temporary3698 -> tp
131:		add ax, [si + 14]
133:	

strftime$38:	; £temporary3700 = int_to_int £temporary3699 (Signed_Int -> Signed_Long_Int)
135:		and eax, 65535
137:		cmp ax, 0
138:		jge strftime$39
139:		neg ax
141:		neg eax
143:	

strftime$39:	; totalDays = £temporary3700
144:		mov [bp + 26], eax
146:	

strftime$40:	; call header integral zero 0 stack zero 0
148:	

strftime$41:	; parameter s, offset 6
149:		mov ax, [bp + 6]
150:		mov [bp + 40], ax
152:	

strftime$42:	; parameter string_#, offset 8
153:		mov word [bp + 42], string_#
155:	

strftime$43:	; call function noellipse-noellipse strcpy
156:		mov word [bp + 34], strftime$44
157:		mov [bp + 36], bp
158:		add bp, 34
159:		jmp strcpy
161:	

strftime$44:	; post call
163:	

strftime$45:	; if shortDayList == 0 goto 48
164:		cmp word [bp + 16], 0
165:		je strftime$48
167:	

strftime$46:	; £temporary3706 = shortDayList
168:		mov ax, [bp + 16]
170:	

strftime$47:	; goto 49
171:		jmp strftime$49
173:	

strftime$48:	; £temporary3706 = g_defaultShortDayList
174:		mov ax, @32$g_defaultShortDayList
176:	

strftime$49:	; shortDayList = £temporary3706
177:		mov [bp + 16], ax
179:	

strftime$50:	; if longDayList == 0 goto 53
180:		cmp word [bp + 20], 0
181:		je strftime$53
183:	

strftime$51:	; £temporary3711 = longDayList
184:		mov ax, [bp + 20]
186:	

strftime$52:	; goto 54
187:		jmp strftime$54
189:	

strftime$53:	; £temporary3711 = g_defaultLongDayList
190:		mov ax, @33$g_defaultLongDayList
192:	

strftime$54:	; longDayList = £temporary3711
193:		mov [bp + 20], ax
195:	

strftime$55:	; if shortMonthList == 0 goto 58
196:		cmp word [bp + 18], 0
197:		je strftime$58
199:	

strftime$56:	; £temporary3716 = shortMonthList
200:		mov ax, [bp + 18]
202:	

strftime$57:	; goto 59
203:		jmp strftime$59
205:	

strftime$58:	; £temporary3716 = g_defaultShortMonthList
206:		mov ax, @34$g_defaultShortMonthList
208:	

strftime$59:	; shortMonthList = £temporary3716
209:		mov [bp + 18], ax
211:	

strftime$60:	; if longMonthList == 0 goto 63
212:		cmp word [bp + 22], 0
213:		je strftime$63
215:	

strftime$61:	; £temporary3721 = longMonthList
216:		mov ax, [bp + 22]
218:	

strftime$62:	; goto 64
219:		jmp strftime$64
221:	

strftime$63:	; £temporary3721 = g_defaultLongMonthList
222:		mov ax, @35$g_defaultLongMonthList
224:	

strftime$64:	; longMonthList = £temporary3721
225:		mov [bp + 22], ax
227:	

strftime$65:	; if totalDays >= 3 goto 70
228:		cmp dword [bp + 26], 3
229:		jge strftime$70
231:	

strftime$66:	; £temporary3723 = totalDays + 4
232:		mov eax, [bp + 26]
233:		add eax, 4
235:	

strftime$67:	; £temporary3724 = int_to_int £temporary3723 (Signed_Long_Int -> Signed_Int)
238:		cmp eax, 0
239:		jge strftime$68
240:		neg eax
242:		neg ax
244:	

strftime$68:	; yearDaySunday = £temporary3724
245:		mov [bp + 30], ax
247:	

strftime$69:	; goto 74
248:		jmp strftime$74
250:	

strftime$70:	; £temporary3725 = totalDays - 3
251:		mov eax, [bp + 26]
252:		sub eax, 3
254:	

strftime$71:	; £temporary3726 = £temporary3725 % 7
256:		xor edx, edx
257:		idiv dword [int4$7#]
263:	

strftime$72:	; £temporary3727 = int_to_int £temporary3726 (Signed_Long_Int -> Signed_Int)
266:		cmp edx, 0
267:		jge strftime$73
268:		neg edx
270:		neg dx
272:	

strftime$73:	; yearDaySunday = £temporary3727
273:		mov [bp + 30], dx
275:	

strftime$74:	; if totalDays >= 4 goto 79
276:		cmp dword [bp + 26], 4
277:		jge strftime$79
279:	

strftime$75:	; £temporary3729 = totalDays + 3
280:		mov eax, [bp + 26]
281:		add eax, 3
283:	

strftime$76:	; £temporary3730 = int_to_int £temporary3729 (Signed_Long_Int -> Signed_Int)
286:		cmp eax, 0
287:		jge strftime$77
288:		neg eax
290:		neg ax
292:	

strftime$77:	; yearDayMonday = £temporary3730
293:		mov [bp + 32], ax
295:	

strftime$78:	; goto 83
296:		jmp strftime$83
298:	

strftime$79:	; £temporary3731 = totalDays - 4
299:		mov eax, [bp + 26]
300:		sub eax, 4
302:	

strftime$80:	; £temporary3732 = £temporary3731 % 7
304:		xor edx, edx
305:		idiv dword [int4$7#]
311:	

strftime$81:	; £temporary3733 = int_to_int £temporary3732 (Signed_Long_Int -> Signed_Int)
314:		cmp edx, 0
315:		jge strftime$82
316:		neg edx
318:		neg dx
320:	

strftime$82:	; yearDayMonday = £temporary3733
321:		mov [bp + 32], dx
323:	

strftime$83:	; index = 0
324:		mov word [bp + 34], 0
326:	

strftime$84:	; £temporary3735 = fmt + index
327:		mov si, [bp + 10]
328:		add si, [bp + 34]
330:	

strftime$85:	; £temporary3734 -> £temporary3735 = *£temporary3735
332:	

strftime$86:	; if £temporary3734 -> £temporary3735 == 0 goto 354
333:		cmp byte [si], 0
334:		je strftime$354
336:	

strftime$87:	; £temporary3739 = fmt + index
337:		mov si, [bp + 10]
338:		add si, [bp + 34]
340:	

strftime$88:	; £temporary3738 -> £temporary3739 = *£temporary3739
342:	

strftime$89:	; if £temporary3738 -> £temporary3739 != 37 goto 329
343:		cmp byte [si], 37
344:		jne strftime$329
346:	

strftime$90:	; £temporary3741 = index + 1
347:		mov ax, [bp + 34]
348:		add ax, 1
350:	

strftime$91:	; £temporary3743 = fmt + £temporary3741
351:		mov si, [bp + 10]
352:		add si, ax
354:	

strftime$92:	; £temporary3742 -> £temporary3743 = *£temporary3743
355:		mov al, [si]
356:		mov [bp + 56], al
358:	

strftime$93:	; case £temporary3742 -> £temporary3743 == 97 goto 117
359:		mov al, [bp + 56]
360:		cmp al, 97
361:		je strftime$117
363:	

strftime$94:	; case £temporary3742 -> £temporary3743 == 65 goto 127
364:		cmp al, 65
365:		je strftime$127
367:	

strftime$95:	; case £temporary3742 -> £temporary3743 == 98 goto 137
368:		cmp al, 98
369:		je strftime$137
371:	

strftime$96:	; case £temporary3742 -> £temporary3743 == 66 goto 147
372:		cmp al, 66
373:		je strftime$147
375:	

strftime$97:	; case £temporary3742 -> £temporary3743 == 99 goto 157
376:		cmp al, 99
377:		je strftime$157
379:	

strftime$98:	; case £temporary3742 -> £temporary3743 == 100 goto 177
380:		cmp al, 100
381:		je strftime$177
383:	

strftime$99:	; case £temporary3742 -> £temporary3743 == 72 goto 185
384:		cmp al, 72
385:		je strftime$185
387:	

strftime$100:	; case £temporary3742 -> £temporary3743 == 73 goto 193
388:		cmp al, 73
389:		je strftime$193
391:	

strftime$101:	; case £temporary3742 -> £temporary3743 == 106 goto 202
392:		cmp al, 106
393:		je strftime$202
395:	

strftime$102:	; case £temporary3742 -> £temporary3743 == 109 goto 210
396:		cmp al, 109
397:		je strftime$210
399:	

strftime$103:	; case £temporary3742 -> £temporary3743 == 77 goto 219
400:		cmp al, 77
401:		je strftime$219
403:	

strftime$104:	; case £temporary3742 -> £temporary3743 == 112 goto 227
404:		cmp al, 112
405:		je strftime$227
407:	

strftime$105:	; case £temporary3742 -> £temporary3743 == 83 goto 239
408:		cmp al, 83
409:		je strftime$239
411:	

strftime$106:	; case £temporary3742 -> £temporary3743 == 85 goto 247
412:		cmp al, 85
413:		je strftime$247
415:	

strftime$107:	; case £temporary3742 -> £temporary3743 == 119 goto 254
416:		cmp al, 119
417:		je strftime$254
419:	

strftime$108:	; case £temporary3742 -> £temporary3743 == 87 goto 262
420:		cmp al, 87
421:		je strftime$262
423:	

strftime$109:	; case £temporary3742 -> £temporary3743 == 120 goto 269
424:		cmp al, 120
425:		je strftime$269
427:	

strftime$110:	; case £temporary3742 -> £temporary3743 == 88 goto 281
428:		cmp al, 88
429:		je strftime$281
431:	

strftime$111:	; case £temporary3742 -> £temporary3743 == 121 goto 293
432:		cmp al, 121
433:		je strftime$293
435:	

strftime$112:	; case £temporary3742 -> £temporary3743 == 89 goto 302
436:		cmp al, 89
437:		je strftime$302
439:	

strftime$113:	; case £temporary3742 -> £temporary3743 == 90 goto 311
440:		cmp al, 90
441:		je strftime$311
443:	

strftime$114:	; case £temporary3742 -> £temporary3743 == 37 goto 317
444:		cmp al, 37
445:		je strftime$317
447:	

strftime$115:	; case end £temporary3742 -> £temporary3743
449:	

strftime$116:	; goto 322
450:		jmp strftime$322
452:	

strftime$117:	; call header integral zero 0 stack zero 0
454:	

strftime$118:	; parameter add, offset 6
455:		mov [bp + 62], bp
456:		add word [bp + 62], 36
458:	

strftime$119:	; £temporary3744 -> tp = *tp, offset 12
459:		mov si, [bp + 12]
461:	

strftime$120:	; £temporary3746 = £temporary3744 -> tp * 2
462:		mov ax, [si + 12]
464:		xor dx, dx
465:		mul word [int2$2#]
471:	

strftime$121:	; £temporary3747 = shortDayList + £temporary3746
472:		mov si, [bp + 16]
473:		add si, ax
475:	

strftime$122:	; £temporary3745 -> £temporary3747 = *£temporary3747
477:	

strftime$123:	; parameter £temporary3745 -> £temporary3747, offset 8
478:		mov ax, [si]
479:		mov [bp + 64], ax
481:	

strftime$124:	; call function noellipse-noellipse strcpy
482:		mov word [bp + 56], strftime$125
483:		mov [bp + 58], bp
484:		add bp, 56
485:		jmp strcpy
487:	

strftime$125:	; post call
489:	

strftime$126:	; goto 327
490:		jmp strftime$327
492:	

strftime$127:	; call header integral zero 0 stack zero 0
494:	

strftime$128:	; parameter add, offset 6
495:		mov [bp + 62], bp
496:		add word [bp + 62], 36
498:	

strftime$129:	; £temporary3749 -> tp = *tp, offset 12
499:		mov si, [bp + 12]
501:	

strftime$130:	; £temporary3751 = £temporary3749 -> tp * 2
502:		mov ax, [si + 12]
504:		xor dx, dx
505:		mul word [int2$2#]
511:	

strftime$131:	; £temporary3752 = longDayList + £temporary3751
512:		mov si, [bp + 20]
513:		add si, ax
515:	

strftime$132:	; £temporary3750 -> £temporary3752 = *£temporary3752
517:	

strftime$133:	; parameter £temporary3750 -> £temporary3752, offset 8
518:		mov ax, [si]
519:		mov [bp + 64], ax
521:	

strftime$134:	; call function noellipse-noellipse strcpy
522:		mov word [bp + 56], strftime$135
523:		mov [bp + 58], bp
524:		add bp, 56
525:		jmp strcpy
527:	

strftime$135:	; post call
529:	

strftime$136:	; goto 327
530:		jmp strftime$327
532:	

strftime$137:	; call header integral zero 0 stack zero 0
534:	

strftime$138:	; parameter add, offset 6
535:		mov [bp + 62], bp
536:		add word [bp + 62], 36
538:	

strftime$139:	; £temporary3754 -> tp = *tp, offset 8
539:		mov si, [bp + 12]
541:	

strftime$140:	; £temporary3756 = £temporary3754 -> tp * 2
542:		mov ax, [si + 8]
544:		xor dx, dx
545:		mul word [int2$2#]
551:	

strftime$141:	; £temporary3757 = shortMonthList + £temporary3756
552:		mov si, [bp + 18]
553:		add si, ax
555:	

strftime$142:	; £temporary3755 -> £temporary3757 = *£temporary3757
557:	

strftime$143:	; parameter £temporary3755 -> £temporary3757, offset 8
558:		mov ax, [si]
559:		mov [bp + 64], ax
561:	

strftime$144:	; call function noellipse-noellipse strcpy
562:		mov word [bp + 56], strftime$145
563:		mov [bp + 58], bp
564:		add bp, 56
565:		jmp strcpy
567:	

strftime$145:	; post call
569:	

strftime$146:	; goto 327
570:		jmp strftime$327
572:	

strftime$147:	; call header integral zero 0 stack zero 0
574:	

strftime$148:	; parameter add, offset 6
575:		mov [bp + 62], bp
576:		add word [bp + 62], 36
578:	

strftime$149:	; £temporary3759 -> tp = *tp, offset 8
579:		mov si, [bp + 12]
581:	

strftime$150:	; £temporary3761 = £temporary3759 -> tp * 2
582:		mov ax, [si + 8]
584:		xor dx, dx
585:		mul word [int2$2#]
591:	

strftime$151:	; £temporary3762 = longMonthList + £temporary3761
592:		mov si, [bp + 22]
593:		add si, ax
595:	

strftime$152:	; £temporary3760 -> £temporary3762 = *£temporary3762
597:	

strftime$153:	; parameter £temporary3760 -> £temporary3762, offset 8
598:		mov ax, [si]
599:		mov [bp + 64], ax
601:	

strftime$154:	; call function noellipse-noellipse strcpy
602:		mov word [bp + 56], strftime$155
603:		mov [bp + 58], bp
604:		add bp, 56
605:		jmp strcpy
607:	

strftime$155:	; post call
609:	

strftime$156:	; goto 327
610:		jmp strftime$327
612:	

strftime$157:	; call header integral zero 0 stack zero 0
614:	

strftime$158:	; parameter add, offset 6
615:		mov [bp + 62], bp
616:		add word [bp + 62], 36
618:	

strftime$159:	; parameter string_25d2D25d2D25d2025d3A25d3A25d#, offset 8
619:		mov word [bp + 64], string_25d2D25d2D25d2025d3A25d3A25d#
621:	

strftime$160:	; £temporary3764 -> tp = *tp, offset 10
622:		mov si, [bp + 12]
624:	

strftime$161:	; £temporary3765 = £temporary3764 -> tp + 1900
625:		mov ax, [si + 10]
626:		add ax, 1900
628:	

strftime$162:	; parameter £temporary3765, offset 10
629:		mov [bp + 66], ax
631:	

strftime$163:	; £temporary3766 -> tp = *tp, offset 8
632:		mov si, [bp + 12]
634:	

strftime$164:	; £temporary3767 = £temporary3766 -> tp + 1
635:		mov ax, [si + 8]
636:		add ax, 1
638:	

strftime$165:	; parameter £temporary3767, offset 12
639:		mov [bp + 68], ax
641:	

strftime$166:	; £temporary3768 -> tp = *tp, offset 6
642:		mov si, [bp + 12]
644:	

strftime$167:	; parameter £temporary3768 -> tp, offset 14
645:		mov ax, [si + 6]
646:		mov [bp + 70], ax
648:	

strftime$168:	; £temporary3769 -> tp = *tp, offset 4
649:		mov si, [bp + 12]
651:	

strftime$169:	; parameter £temporary3769 -> tp, offset 16
652:		mov ax, [si + 4]
653:		mov [bp + 72], ax
655:	

strftime$170:	; £temporary3770 -> tp = *tp, offset 2
656:		mov si, [bp + 12]
658:	

strftime$171:	; parameter £temporary3770 -> tp, offset 18
659:		mov ax, [si + 2]
660:		mov [bp + 74], ax
662:	

strftime$172:	; £temporary3771 -> tp = *tp
663:		mov si, [bp + 12]
665:	

strftime$173:	; parameter £temporary3771 -> tp, offset 20
666:		mov ax, [si]
667:		mov [bp + 76], ax
669:	

strftime$174:	; call function noellipse-ellipse sprintf, extra 0
670:		mov word [bp + 56], strftime$175
671:		mov [bp + 58], bp
672:		add bp, 56
673:		mov di, bp
674:		add di, 12
675:		jmp sprintf
677:	

strftime$175:	; post call
679:	

strftime$176:	; goto 327
680:		jmp strftime$327
682:	

strftime$177:	; call header integral zero 0 stack zero 0
684:	

strftime$178:	; parameter add, offset 6
685:		mov [bp + 62], bp
686:		add word [bp + 62], 36
688:	

strftime$179:	; parameter string_25d#, offset 8
689:		mov word [bp + 64], string_25d#
691:	

strftime$180:	; £temporary3773 -> tp = *tp, offset 6
692:		mov si, [bp + 12]
694:	

strftime$181:	; parameter £temporary3773 -> tp, offset 10
695:		mov ax, [si + 6]
696:		mov [bp + 66], ax
698:	

strftime$182:	; call function noellipse-ellipse sprintf, extra 0
699:		mov word [bp + 56], strftime$183
700:		mov [bp + 58], bp
701:		add bp, 56
702:		mov di, bp
703:		add di, 2
704:		jmp sprintf
706:	

strftime$183:	; post call
708:	

strftime$184:	; goto 327
709:		jmp strftime$327
711:	

strftime$185:	; call header integral zero 0 stack zero 0
713:	

strftime$186:	; parameter add, offset 6
714:		mov [bp + 62], bp
715:		add word [bp + 62], 36
717:	

strftime$187:	; parameter string_25d#, offset 8
718:		mov word [bp + 64], string_25d#
720:	

strftime$188:	; £temporary3775 -> tp = *tp, offset 4
721:		mov si, [bp + 12]
723:	

strftime$189:	; parameter £temporary3775 -> tp, offset 10
724:		mov ax, [si + 4]
725:		mov [bp + 66], ax
727:	

strftime$190:	; call function noellipse-ellipse sprintf, extra 0
728:		mov word [bp + 56], strftime$191
729:		mov [bp + 58], bp
730:		add bp, 56
731:		mov di, bp
732:		add di, 2
733:		jmp sprintf
735:	

strftime$191:	; post call
737:	

strftime$192:	; goto 327
738:		jmp strftime$327
740:	

strftime$193:	; call header integral zero 0 stack zero 0
742:	

strftime$194:	; parameter add, offset 6
743:		mov [bp + 62], bp
744:		add word [bp + 62], 36
746:	

strftime$195:	; parameter string_25d#, offset 8
747:		mov word [bp + 64], string_25d#
749:	

strftime$196:	; £temporary3777 -> tp = *tp, offset 4
750:		mov si, [bp + 12]
752:	

strftime$197:	; £temporary3778 = £temporary3777 -> tp % 12
753:		mov ax, [si + 4]
755:		xor dx, dx
756:		idiv word [int2$12#]
762:	

strftime$198:	; parameter £temporary3778, offset 10
763:		mov [bp + 66], dx
765:	

strftime$199:	; call function noellipse-ellipse sprintf, extra 0
766:		mov word [bp + 56], strftime$200
767:		mov [bp + 58], bp
768:		add bp, 56
769:		mov di, bp
770:		add di, 2
771:		jmp sprintf
773:	

strftime$200:	; post call
775:	

strftime$201:	; goto 327
776:		jmp strftime$327
778:	

strftime$202:	; call header integral zero 0 stack zero 0
780:	

strftime$203:	; parameter add, offset 6
781:		mov [bp + 62], bp
782:		add word [bp + 62], 36
784:	

strftime$204:	; parameter string_25d#, offset 8
785:		mov word [bp + 64], string_25d#
787:	

strftime$205:	; £temporary3780 -> tp = *tp, offset 14
788:		mov si, [bp + 12]
790:	

strftime$206:	; parameter £temporary3780 -> tp, offset 10
791:		mov ax, [si + 14]
792:		mov [bp + 66], ax
794:	

strftime$207:	; call function noellipse-ellipse sprintf, extra 0
795:		mov word [bp + 56], strftime$208
796:		mov [bp + 58], bp
797:		add bp, 56
798:		mov di, bp
799:		add di, 2
800:		jmp sprintf
802:	

strftime$208:	; post call
804:	

strftime$209:	; goto 327
805:		jmp strftime$327
807:	

strftime$210:	; call header integral zero 0 stack zero 0
809:	

strftime$211:	; parameter add, offset 6
810:		mov [bp + 62], bp
811:		add word [bp + 62], 36
813:	

strftime$212:	; parameter string_25d#, offset 8
814:		mov word [bp + 64], string_25d#
816:	

strftime$213:	; £temporary3782 -> tp = *tp, offset 8
817:		mov si, [bp + 12]
819:	

strftime$214:	; £temporary3783 = £temporary3782 -> tp + 1
820:		mov ax, [si + 8]
821:		add ax, 1
823:	

strftime$215:	; parameter £temporary3783, offset 10
824:		mov [bp + 66], ax
826:	

strftime$216:	; call function noellipse-ellipse sprintf, extra 0
827:		mov word [bp + 56], strftime$217
828:		mov [bp + 58], bp
829:		add bp, 56
830:		mov di, bp
831:		add di, 2
832:		jmp sprintf
834:	

strftime$217:	; post call
836:	

strftime$218:	; goto 327
837:		jmp strftime$327
839:	

strftime$219:	; call header integral zero 0 stack zero 0
841:	

strftime$220:	; parameter add, offset 6
842:		mov [bp + 62], bp
843:		add word [bp + 62], 36
845:	

strftime$221:	; parameter string_25d#, offset 8
846:		mov word [bp + 64], string_25d#
848:	

strftime$222:	; £temporary3785 -> tp = *tp, offset 2
849:		mov si, [bp + 12]
851:	

strftime$223:	; parameter £temporary3785 -> tp, offset 10
852:		mov ax, [si + 2]
853:		mov [bp + 66], ax
855:	

strftime$224:	; call function noellipse-ellipse sprintf, extra 0
856:		mov word [bp + 56], strftime$225
857:		mov [bp + 58], bp
858:		add bp, 56
859:		mov di, bp
860:		add di, 2
861:		jmp sprintf
863:	

strftime$225:	; post call
865:	

strftime$226:	; goto 327
866:		jmp strftime$327
868:	

strftime$227:	; call header integral zero 0 stack zero 0
870:	

strftime$228:	; parameter add, offset 6
871:		mov [bp + 62], bp
872:		add word [bp + 62], 36
874:	

strftime$229:	; parameter string_25s#, offset 8
875:		mov word [bp + 64], string_25s#
877:	

strftime$230:	; £temporary3787 -> tp = *tp, offset 4
878:		mov si, [bp + 12]
880:	

strftime$231:	; if £temporary3787 -> tp >= 12 goto 234
881:		cmp word [si + 4], 12
882:		jge strftime$234
884:	

strftime$232:	; £temporary3792 = string_AM#
885:		mov ax, string_AM#
887:	

strftime$233:	; goto 235
888:		jmp strftime$235
890:	

strftime$234:	; £temporary3792 = string_PM#
891:		mov ax, string_PM#
893:	

strftime$235:	; parameter £temporary3792, offset 10
894:		mov [bp + 66], ax
896:	

strftime$236:	; call function noellipse-ellipse sprintf, extra 0
897:		mov word [bp + 56], strftime$237
898:		mov [bp + 58], bp
899:		add bp, 56
900:		mov di, bp
901:		add di, 2
902:		jmp sprintf
904:	

strftime$237:	; post call
906:	

strftime$238:	; goto 327
907:		jmp strftime$327
909:	

strftime$239:	; call header integral zero 0 stack zero 0
911:	

strftime$240:	; parameter add, offset 6
912:		mov [bp + 62], bp
913:		add word [bp + 62], 36
915:	

strftime$241:	; parameter string_25d#, offset 8
916:		mov word [bp + 64], string_25d#
918:	

strftime$242:	; £temporary3794 -> tp = *tp
919:		mov si, [bp + 12]
921:	

strftime$243:	; parameter £temporary3794 -> tp, offset 10
922:		mov ax, [si]
923:		mov [bp + 66], ax
925:	

strftime$244:	; call function noellipse-ellipse sprintf, extra 0
926:		mov word [bp + 56], strftime$245
927:		mov [bp + 58], bp
928:		add bp, 56
929:		mov di, bp
930:		add di, 2
931:		jmp sprintf
933:	

strftime$245:	; post call
935:	

strftime$246:	; goto 327
936:		jmp strftime$327
938:	

strftime$247:	; call header integral zero 0 stack zero 0
940:	

strftime$248:	; parameter add, offset 6
941:		mov [bp + 62], bp
942:		add word [bp + 62], 36
944:	

strftime$249:	; parameter string_25d#, offset 8
945:		mov word [bp + 64], string_25d#
947:	

strftime$250:	; parameter yearDaySunday, offset 10
948:		mov ax, [bp + 30]
949:		mov [bp + 66], ax
951:	

strftime$251:	; call function noellipse-ellipse sprintf, extra 0
952:		mov word [bp + 56], strftime$252
953:		mov [bp + 58], bp
954:		add bp, 56
955:		mov di, bp
956:		add di, 2
957:		jmp sprintf
959:	

strftime$252:	; post call
961:	

strftime$253:	; goto 327
962:		jmp strftime$327
964:	

strftime$254:	; call header integral zero 0 stack zero 0
966:	

strftime$255:	; parameter add, offset 6
967:		mov [bp + 62], bp
968:		add word [bp + 62], 36
970:	

strftime$256:	; parameter string_25d#, offset 8
971:		mov word [bp + 64], string_25d#
973:	

strftime$257:	; £temporary3797 -> tp = *tp, offset 12
974:		mov si, [bp + 12]
976:	

strftime$258:	; parameter £temporary3797 -> tp, offset 10
977:		mov ax, [si + 12]
978:		mov [bp + 66], ax
980:	

strftime$259:	; call function noellipse-ellipse sprintf, extra 0
981:		mov word [bp + 56], strftime$260
982:		mov [bp + 58], bp
983:		add bp, 56
984:		mov di, bp
985:		add di, 2
986:		jmp sprintf
988:	

strftime$260:	; post call
990:	

strftime$261:	; goto 327
991:		jmp strftime$327
993:	

strftime$262:	; call header integral zero 0 stack zero 0
995:	

strftime$263:	; parameter add, offset 6
996:		mov [bp + 62], bp
997:		add word [bp + 62], 36
999:	

strftime$264:	; parameter string_25d#, offset 8
1000:		mov word [bp + 64], string_25d#
1002:	

strftime$265:	; parameter yearDayMonday, offset 10
1003:		mov ax, [bp + 32]
1004:		mov [bp + 66], ax
1006:	

strftime$266:	; call function noellipse-ellipse sprintf, extra 0
1007:		mov word [bp + 56], strftime$267
1008:		mov [bp + 58], bp
1009:		add bp, 56
1010:		mov di, bp
1011:		add di, 2
1012:		jmp sprintf
1014:	

strftime$267:	; post call
1016:	

strftime$268:	; goto 327
1017:		jmp strftime$327
1019:	

strftime$269:	; call header integral zero 0 stack zero 0
1021:	

strftime$270:	; parameter add, offset 6
1022:		mov [bp + 62], bp
1023:		add word [bp + 62], 36
1025:	

strftime$271:	; parameter string_2502d3A2502d3A2502d#, offset 8
1026:		mov word [bp + 64], string_2502d3A2502d3A2502d#
1028:	

strftime$272:	; £temporary3800 -> tp = *tp, offset 4
1029:		mov si, [bp + 12]
1031:	

strftime$273:	; parameter £temporary3800 -> tp, offset 10
1032:		mov ax, [si + 4]
1033:		mov [bp + 66], ax
1035:	

strftime$274:	; £temporary3801 -> tp = *tp, offset 2
1036:		mov si, [bp + 12]
1038:	

strftime$275:	; parameter £temporary3801 -> tp, offset 12
1039:		mov ax, [si + 2]
1040:		mov [bp + 68], ax
1042:	

strftime$276:	; £temporary3802 -> tp = *tp
1043:		mov si, [bp + 12]
1045:	

strftime$277:	; parameter £temporary3802 -> tp, offset 14
1046:		mov ax, [si]
1047:		mov [bp + 70], ax
1049:	

strftime$278:	; call function noellipse-ellipse sprintf, extra 0
1050:		mov word [bp + 56], strftime$279
1051:		mov [bp + 58], bp
1052:		add bp, 56
1053:		mov di, bp
1054:		add di, 6
1055:		jmp sprintf
1057:	

strftime$279:	; post call
1059:	

strftime$280:	; goto 327
1060:		jmp strftime$327
1062:	

strftime$281:	; call header integral zero 0 stack zero 0
1064:	

strftime$282:	; parameter add, offset 6
1065:		mov [bp + 62], bp
1066:		add word [bp + 62], 36
1068:	

strftime$283:	; parameter string_25d3A25d3A25d#, offset 8
1069:		mov word [bp + 64], string_25d3A25d3A25d#
1071:	

strftime$284:	; £temporary3804 -> tp = *tp, offset 4
1072:		mov si, [bp + 12]
1074:	

strftime$285:	; parameter £temporary3804 -> tp, offset 10
1075:		mov ax, [si + 4]
1076:		mov [bp + 66], ax
1078:	

strftime$286:	; £temporary3805 -> tp = *tp, offset 2
1079:		mov si, [bp + 12]
1081:	

strftime$287:	; parameter £temporary3805 -> tp, offset 12
1082:		mov ax, [si + 2]
1083:		mov [bp + 68], ax
1085:	

strftime$288:	; £temporary3806 -> tp = *tp
1086:		mov si, [bp + 12]
1088:	

strftime$289:	; parameter £temporary3806 -> tp, offset 14
1089:		mov ax, [si]
1090:		mov [bp + 70], ax
1092:	

strftime$290:	; call function noellipse-ellipse sprintf, extra 0
1093:		mov word [bp + 56], strftime$291
1094:		mov [bp + 58], bp
1095:		add bp, 56
1096:		mov di, bp
1097:		add di, 6
1098:		jmp sprintf
1100:	

strftime$291:	; post call
1102:	

strftime$292:	; goto 327
1103:		jmp strftime$327
1105:	

strftime$293:	; call header integral zero 0 stack zero 0
1107:	

strftime$294:	; parameter add, offset 6
1108:		mov [bp + 62], bp
1109:		add word [bp + 62], 36
1111:	

strftime$295:	; parameter string_25d#, offset 8
1112:		mov word [bp + 64], string_25d#
1114:	

strftime$296:	; £temporary3808 -> tp = *tp, offset 10
1115:		mov si, [bp + 12]
1117:	

strftime$297:	; £temporary3809 = £temporary3808 -> tp % 100
1118:		mov ax, [si + 10]
1120:		xor dx, dx
1121:		idiv word [int2$100#]
1127:	

strftime$298:	; parameter £temporary3809, offset 10
1128:		mov [bp + 66], dx
1130:	

strftime$299:	; call function noellipse-ellipse sprintf, extra 0
1131:		mov word [bp + 56], strftime$300
1132:		mov [bp + 58], bp
1133:		add bp, 56
1134:		mov di, bp
1135:		add di, 2
1136:		jmp sprintf
1138:	

strftime$300:	; post call
1140:	

strftime$301:	; goto 327
1141:		jmp strftime$327
1143:	

strftime$302:	; call header integral zero 0 stack zero 0
1145:	

strftime$303:	; parameter add, offset 6
1146:		mov [bp + 62], bp
1147:		add word [bp + 62], 36
1149:	

strftime$304:	; parameter string_25d#, offset 8
1150:		mov word [bp + 64], string_25d#
1152:	

strftime$305:	; £temporary3811 -> tp = *tp, offset 10
1153:		mov si, [bp + 12]
1155:	

strftime$306:	; £temporary3812 = £temporary3811 -> tp + 1900
1156:		mov ax, [si + 10]
1157:		add ax, 1900
1159:	

strftime$307:	; parameter £temporary3812, offset 10
1160:		mov [bp + 66], ax
1162:	

strftime$308:	; call function noellipse-ellipse sprintf, extra 0
1163:		mov word [bp + 56], strftime$309
1164:		mov [bp + 58], bp
1165:		add bp, 56
1166:		mov di, bp
1167:		add di, 2
1168:		jmp sprintf
1170:	

strftime$309:	; post call
1172:	

strftime$310:	; goto 327
1173:		jmp strftime$327
1175:	

strftime$311:	; call header integral zero 0 stack zero 0
1177:	

strftime$312:	; parameter add, offset 6
1178:		mov [bp + 62], bp
1179:		add word [bp + 62], 36
1181:	

strftime$313:	; parameter string_#, offset 8
1182:		mov word [bp + 64], string_#
1184:	

strftime$314:	; call function noellipse-noellipse strcpy
1185:		mov word [bp + 56], strftime$315
1186:		mov [bp + 58], bp
1187:		add bp, 56
1188:		jmp strcpy
1190:	

strftime$315:	; post call
1192:	

strftime$316:	; goto 327
1193:		jmp strftime$327
1195:	

strftime$317:	; call header integral zero 0 stack zero 0
1197:	

strftime$318:	; parameter add, offset 6
1198:		mov [bp + 62], bp
1199:		add word [bp + 62], 36
1201:	

strftime$319:	; parameter string_25#, offset 8
1202:		mov word [bp + 64], string_25#
1204:	

strftime$320:	; call function noellipse-noellipse strcpy
1205:		mov word [bp + 56], strftime$321
1206:		mov [bp + 58], bp
1207:		add bp, 56
1208:		jmp strcpy
1210:	

strftime$321:	; post call
1212:	

strftime$322:	; call header integral zero 0 stack zero 0
1214:	

strftime$323:	; parameter add, offset 6
1215:		mov [bp + 62], bp
1216:		add word [bp + 62], 36
1218:	

strftime$324:	; parameter string_#, offset 8
1219:		mov word [bp + 64], string_#
1221:	

strftime$325:	; call function noellipse-noellipse strcpy
1222:		mov word [bp + 56], strftime$326
1223:		mov [bp + 58], bp
1224:		add bp, 56
1225:		jmp strcpy
1227:	

strftime$326:	; post call
1229:	

strftime$327:	; ++index
1230:		inc word [bp + 34]
1232:	

strftime$328:	; goto 335
1233:		jmp strftime$335
1235:	

strftime$329:	; £temporary3818 -> add = *add
1236:		mov si, bp
1237:		add si, 36
1239:	

strftime$330:	; £temporary3820 = fmt + index
1240:		mov di, [bp + 10]
1241:		add di, [bp + 34]
1243:	

strftime$331:	; £temporary3819 -> £temporary3820 = *£temporary3820
1245:	

strftime$332:	; £temporary3818 -> add = £temporary3819 -> £temporary3820
1246:		mov al, [di]
1247:		mov [si], al
1249:	

strftime$333:	; £temporary3821 -> add = *add, offset 1
1250:		mov si, bp
1251:		add si, 36
1253:	

strftime$334:	; £temporary3821 -> add = 0
1254:		mov byte [si + 1], 0
1256:	

strftime$335:	; call header integral zero 0 stack zero 0
1258:	

strftime$336:	; parameter s, offset 6
1259:		mov ax, [bp + 6]
1260:		mov [bp + 62], ax
1262:	

strftime$337:	; call function noellipse-noellipse strlen
1263:		mov word [bp + 56], strftime$338
1264:		mov [bp + 58], bp
1265:		add bp, 56
1266:		jmp strlen
1268:	

strftime$338:	; post call
1270:	

strftime$339:	; £temporary3822 = return_value
1275:	

strftime$340:	; call header integral no zero 1 stack zero 0
1276:		mov [bp + 56], bx
1278:	

strftime$341:	; parameter add, offset 6
1279:		mov [bp + 64], bp
1280:		add word [bp + 64], 36
1282:	

strftime$342:	; call function noellipse-noellipse strlen
1283:		mov word [bp + 58], strftime$343
1284:		mov [bp + 60], bp
1285:		add bp, 58
1286:		jmp strlen
1288:	

strftime$343:	; post call
1289:		mov bx, [bp + 56]
1291:		mov ax, bx
1293:	

strftime$344:	; £temporary3823 = return_value
1298:	

strftime$345:	; £temporary3824 = £temporary3822 + £temporary3823
1299:		add ax, bx
1301:	

strftime$346:	; if £temporary3824 >= smax goto 354
1302:		cmp ax, [bp + 8]
1303:		jge strftime$354
1305:	

strftime$347:	; call header integral zero 0 stack zero 0
1307:	

strftime$348:	; parameter s, offset 6
1308:		mov ax, [bp + 6]
1309:		mov [bp + 62], ax
1311:	

strftime$349:	; parameter add, offset 8
1312:		mov [bp + 64], bp
1313:		add word [bp + 64], 36
1315:	

strftime$350:	; call function noellipse-noellipse strcat
1316:		mov word [bp + 56], strftime$351
1317:		mov [bp + 58], bp
1318:		add bp, 56
1319:		jmp strcat
1321:	

strftime$351:	; post call
1323:	

strftime$352:	; ++index
1324:		inc word [bp + 34]
1326:	

strftime$353:	; goto 84
1327:		jmp strftime$84
1329:	

strftime$354:	; call header integral zero 0 stack zero 0
1331:	

strftime$355:	; parameter s, offset 6
1332:		mov ax, [bp + 6]
1333:		mov [bp + 40], ax
1335:	

strftime$356:	; call function noellipse-noellipse strlen
1336:		mov word [bp + 34], strftime$357
1337:		mov [bp + 36], bp
1338:		add bp, 34
1339:		jmp strlen
1341:	

strftime$357:	; post call
1343:	

strftime$358:	; £temporary3827 = return_value
1348:	

strftime$359:	; return_value = £temporary3827
1350:	

strftime$360:	; return
1351:		mov ax, [bp]
1352:		mov di, [bp + 4]
1353:		mov bp, [bp + 2]
1354:		jmp ax
1356:	

strftime$361:	; function end strftime
