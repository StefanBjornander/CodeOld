1:	

exp:	; push 1
2:		fld1
4:	

exp$1:	; pop float index
5:		fstp qword [bp + 14]
7:	

exp$2:	; push 1
8:		fld1
10:	

exp$3:	; pop float sum
11:		fstp qword [bp + 30]
13:	

exp$4:	; push 1
14:		fld1
16:	

exp$5:	; pop float faculty
17:		fstp qword [bp + 38]
19:	

exp$6:	; push float x
20:		fld qword [bp + 6]
22:	

exp$7:	; pop float power
23:		fstp qword [bp + 46]
25:	

exp$8:	; push float power
26:		fld qword [bp + 46]
28:	

exp$9:	; push float faculty
29:		fld qword [bp + 38]
31:	

exp$10:	; £temporary520 = power / faculty
32:		fdiv
34:	

exp$11:	; pop float term
35:		fstp qword [bp + 22]
37:	

exp$12:	; push float sum
38:		fld qword [bp + 30]
40:	

exp$13:	; push float term
41:		fld qword [bp + 22]
43:	

exp$14:	; £temporary521 = sum + term
44:		fadd
46:	

exp$15:	; pop float sum
47:		fstp qword [bp + 30]
49:	

exp$16:	; push float power
50:		fld qword [bp + 46]
52:	

exp$17:	; push float x
53:		fld qword [bp + 6]
55:	

exp$18:	; £temporary522 = power * x
56:		fmul
58:	

exp$19:	; pop float power
59:		fstp qword [bp + 46]
61:	

exp$20:	; push float faculty
62:		fld qword [bp + 38]
64:	

exp$21:	; push float index
65:		fld qword [bp + 14]
67:	

exp$22:	; push 1
68:		fld1
70:	

exp$23:	; index = index + 1
71:		fadd
73:	

exp$24:	; top float index
74:		fst qword [bp + 14]
76:	

exp$25:	; £temporary524 = faculty * £temporary523
77:		fmul
79:	

exp$26:	; pop float faculty
80:		fstp qword [bp + 38]
82:	

exp$27:	; call header integral zero 0 stack zero 0
84:	

exp$28:	; push float term
85:		fld qword [bp + 22]
87:	

exp$29:	; parameter term, offset 6
88:		fstp qword [bp + 60]
90:	

exp$30:	; call function noellipse-noellipse fabs
91:		mov word [bp + 54], exp$31
92:		mov [bp + 56], bp
93:		add bp, 54
94:		jmp fabs
96:	

exp$31:	; post call
98:	

exp$32:	; £temporary525 = return_value
100:	

exp$33:	; push float 0.000000001
101:		fld qword [float8$0.000000001#]
103:	

exp$34:	; if £temporary525 >= 0.000000001 goto 8
104:		fcompp
105:		fstsw ax
106:		sahf
107:		jbe exp$8
109:	

exp$35:	; push float sum
110:		fld qword [bp + 30]
112:	

exp$36:	; return_value = sum
114:	

exp$37:	; return
115:		mov ax, [bp]
116:		mov di, [bp + 4]
117:		mov bp, [bp + 2]
118:		jmp ax
120:	

exp$38:	; function end exp
1:	

log:	; push float x
2:		fld qword [bp + 6]
4:	

log$1:	; push 0
5:		fldz
7:	

log$2:	; if x <= 0 goto 76
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jae log$76
13:	

log$3:	; n = 0
14:		mov word [bp + 14], 0
16:	

log$4:	; push float x
17:		fld qword [bp + 6]
19:	

log$5:	; push 1
20:		fld1
22:	

log$6:	; if x <= 1 goto 16
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae log$16
28:	

log$7:	; push float x
29:		fld qword [bp + 6]
31:	

log$8:	; push 1
32:		fld1
34:	

log$9:	; if x <= 1 goto 28
35:		fcompp
36:		fstsw ax
37:		sahf
38:		jae log$28
40:	

log$10:	; push float x
41:		fld qword [bp + 6]
43:	

log$11:	; push float 2.71
44:		fld qword [float8$2.71#]
46:	

log$12:	; £temporary531 = x / 2.71
47:		fdiv
49:	

log$13:	; pop float x
50:		fstp qword [bp + 6]
52:	

log$14:	; ++n
53:		inc word [bp + 14]
55:	

log$15:	; goto 7
56:		jmp log$7
58:	

log$16:	; push float x
59:		fld qword [bp + 6]
61:	

log$17:	; push float 0.368
62:		fld qword [float8$0.368#]
64:	

log$18:	; if x >= 0.368 goto 28
65:		fcompp
66:		fstsw ax
67:		sahf
68:		jbe log$28
70:	

log$19:	; push float x
71:		fld qword [bp + 6]
73:	

log$20:	; push float 0.368
74:		fld qword [float8$0.368#]
76:	

log$21:	; if x >= 0.368 goto 28
77:		fcompp
78:		fstsw ax
79:		sahf
80:		jbe log$28
82:	

log$22:	; push float x
83:		fld qword [bp + 6]
85:	

log$23:	; push float 2.71
86:		fld qword [float8$2.71#]
88:	

log$24:	; £temporary535 = x * 2.71
89:		fmul
91:	

log$25:	; pop float x
92:		fstp qword [bp + 6]
94:	

log$26:	; --n
95:		dec word [bp + 14]
97:	

log$27:	; goto 19
98:		jmp log$19
100:	

log$28:	; push 1
101:		fld1
103:	

log$29:	; pop float index
104:		fstp qword [bp + 16]
106:	

log$30:	; push 0
107:		fldz
109:	

log$31:	; pop float sum
110:		fstp qword [bp + 32]
112:	

log$32:	; push 1
113:		fld1
115:	

log$33:	; pop float sign
116:		fstp qword [bp + 40]
118:	

log$34:	; push float x
119:		fld qword [bp + 6]
121:	

log$35:	; push 1
122:		fld1
124:	

log$36:	; £temporary537 = x - 1
125:		fsub
127:	

log$37:	; pop float x_minus_1
128:		fstp qword [bp + 48]
130:	

log$38:	; push float x_minus_1
131:		fld qword [bp + 48]
133:	

log$39:	; pop float power
134:		fstp qword [bp + 56]
136:	

log$40:	; push float sign
137:		fld qword [bp + 40]
139:	

log$41:	; push float power
140:		fld qword [bp + 56]
142:	

log$42:	; £temporary538 = sign * power
143:		fmul
145:	

log$43:	; push float index
146:		fld qword [bp + 16]
148:	

log$44:	; push 1
149:		fld1
151:	

log$45:	; index = index + 1
152:		fadd
154:	

log$46:	; top float index
155:		fst qword [bp + 16]
157:	

log$47:	; push 1
158:		fld1
160:	

log$48:	; index = index - 1
161:		fsub
163:	

log$49:	; £temporary540 = £temporary538 / £temporary539
164:		fdiv
166:	

log$50:	; pop float term
167:		fstp qword [bp + 24]
169:	

log$51:	; push float sum
170:		fld qword [bp + 32]
172:	

log$52:	; push float term
173:		fld qword [bp + 24]
175:	

log$53:	; £temporary541 = sum + term
176:		fadd
178:	

log$54:	; pop float sum
179:		fstp qword [bp + 32]
181:	

log$55:	; push float power
182:		fld qword [bp + 56]
184:	

log$56:	; push float x_minus_1
185:		fld qword [bp + 48]
187:	

log$57:	; £temporary542 = power * x_minus_1
188:		fmul
190:	

log$58:	; pop float power
191:		fstp qword [bp + 56]
193:	

log$59:	; push float sign
194:		fld qword [bp + 40]
196:	

log$60:	; push float -1.0
197:		fld qword [float8$minus1.0#]
199:	

log$61:	; £temporary543 = sign * -1.0
200:		fmul
202:	

log$62:	; pop float sign
203:		fstp qword [bp + 40]
205:	

log$63:	; call header integral zero 0 stack zero 0
207:	

log$64:	; push float term
208:		fld qword [bp + 24]
210:	

log$65:	; parameter term, offset 6
211:		fstp qword [bp + 70]
213:	

log$66:	; call function noellipse-noellipse fabs
214:		mov word [bp + 64], log$67
215:		mov [bp + 66], bp
216:		add bp, 64
217:		jmp fabs
219:	

log$67:	; post call
221:	

log$68:	; £temporary544 = return_value
223:	

log$69:	; push float 0.000000001
224:		fld qword [float8$0.000000001#]
226:	

log$70:	; if £temporary544 >= 0.000000001 goto 40
227:		fcompp
228:		fstsw ax
229:		sahf
230:		jbe log$40
232:	

log$71:	; push float sum
233:		fld qword [bp + 32]
235:	

log$72:	; £temporary546 = int_to_float n (Signed_Int -> Double)
236:		fild word [bp + 14]
238:	

log$73:	; £temporary547 = sum + £temporary546
239:		fadd
241:	

log$74:	; return_value = £temporary547
243:	

log$75:	; return
244:		mov ax, [bp]
245:		mov di, [bp + 4]
246:		mov bp, [bp + 2]
247:		jmp ax
249:	

log$76:	; errno = 6
250:		mov word [errno], 6
252:	

log$77:	; push 0
253:		fldz
255:	

log$78:	; return_value = 0
257:	

log$79:	; return
258:		mov ax, [bp]
259:		mov di, [bp + 4]
260:		mov bp, [bp + 2]
261:		jmp ax
263:	

log$80:	; function end log
1:	

log10:	; call header integral zero 0 stack zero 0
3:	

log10$1:	; push float x
4:		fld qword [bp + 6]
6:	

log10$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

log10$3:	; call function noellipse-noellipse log
10:		mov word [bp + 14], log10$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp log
15:	

log10$4:	; post call
17:	

log10$5:	; £temporary549 = return_value
19:	

log10$6:	; push float 2.3025850929940456840179914
20:		fld qword [float8$2.3025850929940456840179914#]
22:	

log10$7:	; £temporary550 = £temporary549 / 2.3025850929940456840179914
23:		fdiv
25:	

log10$8:	; return_value = £temporary550
27:	

log10$9:	; return
28:		mov ax, [bp]
29:		mov di, [bp + 4]
30:		mov bp, [bp + 2]
31:		jmp ax
33:	

log10$10:	; function end log10
1:	

pow:	; push float x
2:		fld qword [bp + 6]
4:	

pow$1:	; push 0
5:		fldz
7:	

pow$2:	; if x <= 0 goto 18
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jae pow$18
13:	

pow$3:	; call header integral zero 0 stack zero 0
15:	

pow$4:	; push float y
16:		fld qword [bp + 14]
18:	

pow$5:	; call header integral zero 0 stack no zero 1
19:		fstp qword [bp + 22]
21:	

pow$6:	; push float x
22:		fld qword [bp + 6]
24:	

pow$7:	; parameter x, offset 6
25:		fstp qword [bp + 36]
27:	

pow$8:	; call function noellipse-noellipse log
28:		mov word [bp + 30], pow$9
29:		mov [bp + 32], bp
30:		add bp, 30
31:		jmp log
33:	

pow$9:	; post call
34:		fstp qword [bp + 30]
35:		fld qword [bp + 22]
36:		fld qword [bp + 30]
38:	

pow$10:	; £temporary553 = return_value
40:	

pow$11:	; £temporary554 = y * £temporary553
41:		fmul
43:	

pow$12:	; parameter £temporary554, offset 6
44:		fstp qword [bp + 28]
46:	

pow$13:	; call function noellipse-noellipse exp
47:		mov word [bp + 22], pow$14
48:		mov [bp + 24], bp
49:		add bp, 22
50:		jmp exp
52:	

pow$14:	; post call
54:	

pow$15:	; £temporary555 = return_value
56:	

pow$16:	; return_value = £temporary555
58:	

pow$17:	; return
59:		mov ax, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp ax
64:	

pow$18:	; push float x
65:		fld qword [bp + 6]
67:	

pow$19:	; push 0
68:		fldz
70:	

pow$20:	; if x != 0 goto 27
71:		fcompp
72:		fstsw ax
73:		sahf
74:		jne pow$27
76:	

pow$21:	; push float y
77:		fld qword [bp + 14]
79:	

pow$22:	; push 0
80:		fldz
82:	

pow$23:	; if y != 0 goto 27
83:		fcompp
84:		fstsw ax
85:		sahf
86:		jne pow$27
88:	

pow$24:	; push 1
89:		fld1
91:	

pow$25:	; return_value = 1
93:	

pow$26:	; return
94:		mov ax, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp ax
99:	

pow$27:	; push float x
100:		fld qword [bp + 6]
102:	

pow$28:	; push 0
103:		fldz
105:	

pow$29:	; if x != 0 goto 36
106:		fcompp
107:		fstsw ax
108:		sahf
109:		jne pow$36
111:	

pow$30:	; push float y
112:		fld qword [bp + 14]
114:	

pow$31:	; push 0
115:		fldz
117:	

pow$32:	; if y <= 0 goto 36
118:		fcompp
119:		fstsw ax
120:		sahf
121:		jae pow$36
123:	

pow$33:	; push 0
124:		fldz
126:	

pow$34:	; return_value = 0
128:	

pow$35:	; return
129:		mov ax, [bp]
130:		mov di, [bp + 4]
131:		mov bp, [bp + 2]
132:		jmp ax
134:	

pow$36:	; push float x
135:		fld qword [bp + 6]
137:	

pow$37:	; push 0
138:		fldz
140:	

pow$38:	; if x >= 0 goto 90
141:		fcompp
142:		fstsw ax
143:		sahf
144:		jbe pow$90
146:	

pow$39:	; call header integral zero 0 stack zero 0
148:	

pow$40:	; push float y
149:		fld qword [bp + 14]
151:	

pow$41:	; parameter y, offset 6
152:		fstp qword [bp + 28]
154:	

pow$42:	; call function noellipse-noellipse floor
155:		mov word [bp + 22], pow$43
156:		mov [bp + 24], bp
157:		add bp, 22
158:		jmp floor
160:	

pow$43:	; post call
162:	

pow$44:	; £temporary563 = return_value
164:	

pow$45:	; call header integral zero 0 stack no zero 1
165:		fstp qword [bp + 22]
167:	

pow$46:	; push float y
168:		fld qword [bp + 14]
170:	

pow$47:	; parameter y, offset 6
171:		fstp qword [bp + 36]
173:	

pow$48:	; call function noellipse-noellipse ceil
174:		mov word [bp + 30], pow$49
175:		mov [bp + 32], bp
176:		add bp, 30
177:		jmp ceil
179:	

pow$49:	; post call
180:		fstp qword [bp + 30]
181:		fld qword [bp + 22]
182:		fld qword [bp + 30]
184:	

pow$50:	; £temporary564 = return_value
186:	

pow$51:	; if £temporary563 != £temporary564 goto 90
187:		fcompp
188:		fstsw ax
189:		sahf
190:		jne pow$90
192:	

pow$52:	; push float y
193:		fld qword [bp + 14]
195:	

pow$53:	; £temporary567 = float_to_int y (Double -> Signed_Long_Int)
196:		fistp dword [container4bytes#]
197:		mov eax, [container4bytes#]
199:	

pow$54:	; long_y = £temporary567
200:		mov [bp + 22], eax
202:	

pow$55:	; £temporary568 = long_y % 2
203:		mov eax, [bp + 22]
205:		xor edx, edx
206:		idiv dword [int4$2#]
212:	

pow$56:	; if £temporary568 != 0 goto 73
213:		cmp edx, 0
214:		jne pow$73
216:	

pow$57:	; call header integral zero 0 stack zero 0
218:	

pow$58:	; push float y
219:		fld qword [bp + 14]
221:	

pow$59:	; call header integral zero 0 stack no zero 1
222:		fstp qword [bp + 26]
224:	

pow$60:	; push float x
225:		fld qword [bp + 6]
227:	

pow$61:	; £temporary570 = -x
228:		fchs
230:	

pow$62:	; parameter £temporary570, offset 6
231:		fstp qword [bp + 40]
233:	

pow$63:	; call function noellipse-noellipse log
234:		mov word [bp + 34], pow$64
235:		mov [bp + 36], bp
236:		add bp, 34
237:		jmp log
239:	

pow$64:	; post call
240:		fstp qword [bp + 34]
241:		fld qword [bp + 26]
242:		fld qword [bp + 34]
244:	

pow$65:	; £temporary571 = return_value
246:	

pow$66:	; £temporary572 = y * £temporary571
247:		fmul
249:	

pow$67:	; parameter £temporary572, offset 6
250:		fstp qword [bp + 32]
252:	

pow$68:	; call function noellipse-noellipse exp
253:		mov word [bp + 26], pow$69
254:		mov [bp + 28], bp
255:		add bp, 26
256:		jmp exp
258:	

pow$69:	; post call
260:	

pow$70:	; £temporary573 = return_value
262:	

pow$71:	; return_value = £temporary573
264:	

pow$72:	; return
265:		mov ax, [bp]
266:		mov di, [bp + 4]
267:		mov bp, [bp + 2]
268:		jmp ax
270:	

pow$73:	; call header integral zero 0 stack zero 0
272:	

pow$74:	; push float y
273:		fld qword [bp + 14]
275:	

pow$75:	; call header integral zero 0 stack no zero 1
276:		fstp qword [bp + 26]
278:	

pow$76:	; push float x
279:		fld qword [bp + 6]
281:	

pow$77:	; £temporary574 = -x
282:		fchs
284:	

pow$78:	; parameter £temporary574, offset 6
285:		fstp qword [bp + 40]
287:	

pow$79:	; call function noellipse-noellipse log
288:		mov word [bp + 34], pow$80
289:		mov [bp + 36], bp
290:		add bp, 34
291:		jmp log
293:	

pow$80:	; post call
294:		fstp qword [bp + 34]
295:		fld qword [bp + 26]
296:		fld qword [bp + 34]
298:	

pow$81:	; £temporary575 = return_value
300:	

pow$82:	; £temporary576 = y * £temporary575
301:		fmul
303:	

pow$83:	; parameter £temporary576, offset 6
304:		fstp qword [bp + 32]
306:	

pow$84:	; call function noellipse-noellipse exp
307:		mov word [bp + 26], pow$85
308:		mov [bp + 28], bp
309:		add bp, 26
310:		jmp exp
312:	

pow$85:	; post call
314:	

pow$86:	; £temporary577 = return_value
316:	

pow$87:	; £temporary578 = -£temporary577
317:		fchs
319:	

pow$88:	; return_value = £temporary578
321:	

pow$89:	; return
322:		mov ax, [bp]
323:		mov di, [bp + 4]
324:		mov bp, [bp + 2]
325:		jmp ax
327:	

pow$90:	; errno = 6
328:		mov word [errno], 6
330:	

pow$91:	; push 0
331:		fldz
333:	

pow$92:	; return_value = 0
335:	

pow$93:	; return
336:		mov ax, [bp]
337:		mov di, [bp + 4]
338:		mov bp, [bp + 2]
339:		jmp ax
341:	

pow$94:	; function end pow
1:	

ldexp:	; push float x
2:		fld qword [bp + 6]
4:	

ldexp$1:	; call header integral zero 0 stack no zero 1
5:		fstp qword [bp + 16]
7:	

ldexp$2:	; push float 2
8:		fld qword [float8$2#]
10:	

ldexp$3:	; parameter 2, offset 6
11:		fstp qword [bp + 30]
13:	

ldexp$4:	; £temporary587 = int_to_float n (Signed_Int -> Double)
14:		fild word [bp + 14]
16:	

ldexp$5:	; parameter £temporary587, offset 14
17:		fstp qword [bp + 38]
19:	

ldexp$6:	; call function noellipse-noellipse pow
20:		mov word [bp + 24], ldexp$7
21:		mov [bp + 26], bp
22:		add bp, 24
23:		jmp pow
25:	

ldexp$7:	; post call
26:		fstp qword [bp + 24]
27:		fld qword [bp + 16]
28:		fld qword [bp + 24]
30:	

ldexp$8:	; £temporary588 = return_value
32:	

ldexp$9:	; £temporary589 = x * £temporary588
33:		fmul
35:	

ldexp$10:	; return_value = £temporary589
37:	

ldexp$11:	; return
38:		mov ax, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp ax
43:	

ldexp$12:	; function end ldexp
1:	

@24$log2:	; call header integral zero 0 stack zero 0
3:	

@24$log2$1:	; push float x
4:		fld qword [bp + 6]
6:	

@24$log2$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

@24$log2$3:	; call function noellipse-noellipse log
10:		mov word [bp + 14], @24$log2$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp log
15:	

@24$log2$4:	; post call
17:	

@24$log2$5:	; £temporary592 = return_value
19:	

@24$log2$6:	; push float 0.6931471805599453094172321
20:		fld qword [float8$0.6931471805599453094172321#]
22:	

@24$log2$7:	; £temporary593 = £temporary592 / 0.6931471805599453094172321
23:		fdiv
25:	

@24$log2$8:	; £temporary594 = float_to_int £temporary593 (Double -> Signed_Int)
26:		fistp word [container2bytes#]
27:		mov bx, [container2bytes#]
29:	

@24$log2$9:	; return_value = £temporary594
31:	

@24$log2$10:	; return
32:		mov ax, [bp]
33:		mov di, [bp + 4]
34:		mov bp, [bp + 2]
35:		jmp ax
37:	

@24$log2$11:	; function end log2
1:	

frexp:	; push float x
2:		fld qword [bp + 6]
4:	

frexp$1:	; push 0
5:		fldz
7:	

frexp$2:	; if x == 0 goto 42
8:		fcompp
9:		fstsw ax
10:		sahf
11:		je frexp$42
13:	

frexp$3:	; call header integral zero 0 stack zero 0
15:	

frexp$4:	; call header integral zero 0 stack zero 0
17:	

frexp$5:	; push float x
18:		fld qword [bp + 6]
20:	

frexp$6:	; parameter x, offset 6
21:		fstp qword [bp + 22]
23:	

frexp$7:	; call function noellipse-noellipse fabs
24:		mov word [bp + 16], frexp$8
25:		mov [bp + 18], bp
26:		add bp, 16
27:		jmp fabs
29:	

frexp$8:	; post call
31:	

frexp$9:	; £temporary597 = return_value
33:	

frexp$10:	; parameter £temporary597, offset 6
34:		fstp qword [bp + 22]
36:	

frexp$11:	; call function noellipse-noellipse log2
37:		mov word [bp + 16], frexp$12
38:		mov [bp + 18], bp
39:		add bp, 16
40:		jmp @24$log2
42:	

frexp$12:	; post call
44:	

frexp$13:	; £temporary598 = return_value
49:	

frexp$14:	; £temporary599 = int_to_int £temporary598 (Signed_Int -> Signed_Int)
52:	

frexp$15:	; exponent = £temporary599
53:		mov [bp + 16], bx
55:	

frexp$16:	; call header integral zero 0 stack zero 0
57:	

frexp$17:	; push float 2
58:		fld qword [float8$2#]
60:	

frexp$18:	; parameter 2, offset 6
61:		fstp qword [bp + 24]
63:	

frexp$19:	; £temporary600 = int_to_float exponent (Signed_Int -> Double)
64:		fild word [bp + 16]
66:	

frexp$20:	; parameter £temporary600, offset 14
67:		fstp qword [bp + 32]
69:	

frexp$21:	; call function noellipse-noellipse pow
70:		mov word [bp + 18], frexp$22
71:		mov [bp + 20], bp
72:		add bp, 18
73:		jmp pow
75:	

frexp$22:	; post call
77:	

frexp$23:	; £temporary601 = return_value
79:	

frexp$24:	; push float x
80:		fld qword [bp + 6]
82:	

frexp$25:	; if £temporary601 >= x goto 27
83:		fcompp
84:		fstsw ax
85:		sahf
86:		jbe frexp$27
88:	

frexp$26:	; ++exponent
89:		inc word [bp + 16]
91:	

frexp$27:	; if p == 0 goto 30
92:		cmp word [bp + 14], 0
93:		je frexp$30
95:	

frexp$28:	; £temporary605 -> p = *p
96:		mov si, [bp + 14]
98:	

frexp$29:	; £temporary605 -> p = exponent
99:		mov ax, [bp + 16]
100:		mov [si], ax
102:	

frexp$30:	; push float x
103:		fld qword [bp + 6]
105:	

frexp$31:	; call header integral zero 0 stack no zero 1
106:		fstp qword [bp + 18]
108:	

frexp$32:	; push float 2
109:		fld qword [float8$2#]
111:	

frexp$33:	; parameter 2, offset 6
112:		fstp qword [bp + 32]
114:	

frexp$34:	; £temporary606 = int_to_float exponent (Signed_Int -> Double)
115:		fild word [bp + 16]
117:	

frexp$35:	; parameter £temporary606, offset 14
118:		fstp qword [bp + 40]
120:	

frexp$36:	; call function noellipse-noellipse pow
121:		mov word [bp + 26], frexp$37
122:		mov [bp + 28], bp
123:		add bp, 26
124:		jmp pow
126:	

frexp$37:	; post call
127:		fstp qword [bp + 26]
128:		fld qword [bp + 18]
129:		fld qword [bp + 26]
131:	

frexp$38:	; £temporary607 = return_value
133:	

frexp$39:	; £temporary608 = x / £temporary607
134:		fdiv
136:	

frexp$40:	; return_value = £temporary608
138:	

frexp$41:	; return
139:		mov ax, [bp]
140:		mov di, [bp + 4]
141:		mov bp, [bp + 2]
142:		jmp ax
144:	

frexp$42:	; if p == 0 goto 45
145:		cmp word [bp + 14], 0
146:		je frexp$45
148:	

frexp$43:	; £temporary610 -> p = *p
149:		mov si, [bp + 14]
151:	

frexp$44:	; £temporary610 -> p = 0
152:		mov word [si], 0
154:	

frexp$45:	; push 0
155:		fldz
157:	

frexp$46:	; return_value = 0
159:	

frexp$47:	; return
160:		mov ax, [bp]
161:		mov di, [bp + 4]
162:		mov bp, [bp + 2]
163:		jmp ax
165:	

frexp$48:	; function end frexp
1:	

sqrt:	; push float x
2:		fld qword [bp + 6]
4:	

sqrt$1:	; push 0
5:		fldz
7:	

sqrt$2:	; if x < 0 goto 28
8:		fcompp
9:		fstsw ax
10:		sahf
11:		ja sqrt$28
13:	

sqrt$3:	; push 1
14:		fld1
16:	

sqrt$4:	; pop float root_i_plus_1
17:		fstp qword [bp + 22]
19:	

sqrt$5:	; push float root_i_plus_1
20:		fld qword [bp + 22]
22:	

sqrt$6:	; pop float root_i
23:		fstp qword [bp + 14]
25:	

sqrt$7:	; push float root_i
26:		fld qword [bp + 14]
28:	

sqrt$8:	; push float x
29:		fld qword [bp + 6]
31:	

sqrt$9:	; push float root_i
32:		fld qword [bp + 14]
34:	

sqrt$10:	; £temporary618 = x / root_i
35:		fdiv
37:	

sqrt$11:	; £temporary619 = root_i + £temporary618
38:		fadd
40:	

sqrt$12:	; push float 2
41:		fld qword [float8$2#]
43:	

sqrt$13:	; £temporary620 = £temporary619 / 2
44:		fdiv
46:	

sqrt$14:	; pop float root_i_plus_1
47:		fstp qword [bp + 22]
49:	

sqrt$15:	; call header integral zero 0 stack zero 0
51:	

sqrt$16:	; push float root_i_plus_1
52:		fld qword [bp + 22]
54:	

sqrt$17:	; push float root_i
55:		fld qword [bp + 14]
57:	

sqrt$18:	; £temporary621 = root_i_plus_1 - root_i
58:		fsub
60:	

sqrt$19:	; parameter £temporary621, offset 6
61:		fstp qword [bp + 36]
63:	

sqrt$20:	; call function noellipse-noellipse fabs
64:		mov word [bp + 30], sqrt$21
65:		mov [bp + 32], bp
66:		add bp, 30
67:		jmp fabs
69:	

sqrt$21:	; post call
71:	

sqrt$22:	; £temporary622 = return_value
73:	

sqrt$23:	; push float 0.000000001
74:		fld qword [float8$0.000000001#]
76:	

sqrt$24:	; if £temporary622 >= 0.000000001 goto 5
77:		fcompp
78:		fstsw ax
79:		sahf
80:		jbe sqrt$5
82:	

sqrt$25:	; push float root_i_plus_1
83:		fld qword [bp + 22]
85:	

sqrt$26:	; return_value = root_i_plus_1
87:	

sqrt$27:	; return
88:		mov ax, [bp]
89:		mov di, [bp + 4]
90:		mov bp, [bp + 2]
91:		jmp ax
93:	

sqrt$28:	; errno = 6
94:		mov word [errno], 6
96:	

sqrt$29:	; push 0
97:		fldz
99:	

sqrt$30:	; return_value = 0
101:	

sqrt$31:	; return
102:		mov ax, [bp]
103:		mov di, [bp + 4]
104:		mov bp, [bp + 2]
105:		jmp ax
107:	

sqrt$32:	; function end sqrt
1:	

modf:	; call header integral zero 0 stack zero 0
3:	

modf$1:	; push float x
4:		fld qword [bp + 6]
6:	

modf$2:	; parameter x, offset 6
7:		fstp qword [bp + 22]
9:	

modf$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 16], modf$4
11:		mov [bp + 18], bp
12:		add bp, 16
13:		jmp fabs
15:	

modf$4:	; post call
17:	

modf$5:	; £temporary625 = return_value
19:	

modf$6:	; pop float abs_x
20:		fstp qword [bp + 16]
22:	

modf$7:	; push float abs_x
23:		fld qword [bp + 16]
25:	

modf$8:	; £temporary626 = float_to_int abs_x (Double -> Signed_Long_Int)
26:		fistp dword [container4bytes#]
27:		mov eax, [container4bytes#]
29:	

modf$9:	; £temporary627 = int_to_float £temporary626 (Signed_Long_Int -> Double)
30:		mov [container4bytes#], eax
31:		fild dword [container4bytes#]
33:	

modf$10:	; pop float integral
34:		fstp qword [bp + 24]
36:	

modf$11:	; push float abs_x
37:		fld qword [bp + 16]
39:	

modf$12:	; push float integral
40:		fld qword [bp + 24]
42:	

modf$13:	; £temporary628 = abs_x - integral
43:		fsub
45:	

modf$14:	; pop float fractional
46:		fstp qword [bp + 32]
48:	

modf$15:	; if p == 0 goto 26
49:		cmp word [bp + 14], 0
50:		je modf$26
52:	

modf$16:	; £temporary630 -> p = *p
53:		mov si, [bp + 14]
55:	

modf$17:	; push float x
56:		fld qword [bp + 6]
58:	

modf$18:	; push 0
59:		fldz
61:	

modf$19:	; if x <= 0 goto 23
62:		fcompp
63:		fstsw ax
64:		sahf
65:		jae modf$23
67:	

modf$20:	; push float integral
68:		fld qword [bp + 24]
70:	

modf$21:	; decrease stack
72:	

modf$22:	; goto 25
73:		jmp modf$25
75:	

modf$23:	; push float integral
76:		fld qword [bp + 24]
78:	

modf$24:	; £temporary632 = -integral
79:		fchs
81:	

modf$25:	; pop float £temporary630 -> p
82:		fstp qword [si]
84:	

modf$26:	; push float x
85:		fld qword [bp + 6]
87:	

modf$27:	; push 0
88:		fldz
90:	

modf$28:	; if x <= 0 goto 32
91:		fcompp
92:		fstsw ax
93:		sahf
94:		jae modf$32
96:	

modf$29:	; push float fractional
97:		fld qword [bp + 32]
99:	

modf$30:	; decrease stack
101:	

modf$31:	; goto 34
102:		jmp modf$34
104:	

modf$32:	; push float fractional
105:		fld qword [bp + 32]
107:	

modf$33:	; £temporary638 = -fractional
108:		fchs
110:	

modf$34:	; return_value = £temporary642
112:	

modf$35:	; return
113:		mov ax, [bp]
114:		mov di, [bp + 4]
115:		mov bp, [bp + 2]
116:		jmp ax
118:	

modf$36:	; function end modf
1:	

fmod:	; push float y
2:		fld qword [bp + 14]
4:	

fmod$1:	; push 0
5:		fldz
7:	

fmod$2:	; if y == 0 goto 28
8:		fcompp
9:		fstsw ax
10:		sahf
11:		je fmod$28
13:	

fmod$3:	; call header integral zero 0 stack zero 0
15:	

fmod$4:	; push float x
16:		fld qword [bp + 6]
18:	

fmod$5:	; push float y
19:		fld qword [bp + 14]
21:	

fmod$6:	; push float x
22:		fld qword [bp + 6]
24:	

fmod$7:	; push float y
25:		fld qword [bp + 14]
27:	

fmod$8:	; £temporary645 = x / y
28:		fdiv
30:	

fmod$9:	; £temporary646 = float_to_int £temporary645 (Double -> Signed_Int)
31:		fistp word [container2bytes#]
32:		mov ax, [container2bytes#]
34:	

fmod$10:	; £temporary647 = int_to_float £temporary646 (Signed_Int -> Double)
35:		mov [container2bytes#], ax
36:		fild word [container2bytes#]
38:	

fmod$11:	; £temporary648 = y * £temporary647
39:		fmul
41:	

fmod$12:	; £temporary649 = x - £temporary648
42:		fsub
44:	

fmod$13:	; parameter £temporary649, offset 6
45:		fstp qword [bp + 28]
47:	

fmod$14:	; call function noellipse-noellipse fabs
48:		mov word [bp + 22], fmod$15
49:		mov [bp + 24], bp
50:		add bp, 22
51:		jmp fabs
53:	

fmod$15:	; post call
55:	

fmod$16:	; £temporary650 = return_value
57:	

fmod$17:	; pop float remainder
58:		fstp qword [bp + 22]
60:	

fmod$18:	; push float x
61:		fld qword [bp + 6]
63:	

fmod$19:	; push 0
64:		fldz
66:	

fmod$20:	; if x <= 0 goto 24
67:		fcompp
68:		fstsw ax
69:		sahf
70:		jae fmod$24
72:	

fmod$21:	; push float remainder
73:		fld qword [bp + 22]
75:	

fmod$22:	; decrease stack
77:	

fmod$23:	; goto 26
78:		jmp fmod$26
80:	

fmod$24:	; push float remainder
81:		fld qword [bp + 22]
83:	

fmod$25:	; £temporary652 = -remainder
84:		fchs
86:	

fmod$26:	; return_value = £temporary656
88:	

fmod$27:	; return
89:		mov ax, [bp]
90:		mov di, [bp + 4]
91:		mov bp, [bp + 2]
92:		jmp ax
94:	

fmod$28:	; errno = 6
95:		mov word [errno], 6
97:	

fmod$29:	; push 0
98:		fldz
100:	

fmod$30:	; return_value = 0
102:	

fmod$31:	; return
103:		mov ax, [bp]
104:		mov di, [bp + 4]
105:		mov bp, [bp + 2]
106:		jmp ax
108:	

fmod$32:	; function end fmod
1:	

sin:	; call header integral zero 0 stack zero 0
3:	

sin$1:	; push float x
4:		fld qword [bp + 6]
6:	

sin$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

sin$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 14], sin$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp fabs
15:	

sin$4:	; post call
17:	

sin$5:	; £temporary658 = return_value
19:	

sin$6:	; push float 6.28
20:		fld qword [float8$6.28#]
22:	

sin$7:	; if £temporary658 <= 6.28 goto 17
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae sin$17
28:	

sin$8:	; call header integral zero 0 stack zero 0
30:	

sin$9:	; push float x
31:		fld qword [bp + 6]
33:	

sin$10:	; parameter x, offset 6
34:		fstp qword [bp + 20]
36:	

sin$11:	; push float 6.28
37:		fld qword [float8$6.28#]
39:	

sin$12:	; parameter 6.28, offset 14
40:		fstp qword [bp + 28]
42:	

sin$13:	; call function noellipse-noellipse fmod
43:		mov word [bp + 14], sin$14
44:		mov [bp + 16], bp
45:		add bp, 14
46:		jmp fmod
48:	

sin$14:	; post call
50:	

sin$15:	; £temporary660 = return_value
52:	

sin$16:	; pop float x
53:		fstp qword [bp + 6]
55:	

sin$17:	; push 1
56:		fld1
58:	

sin$18:	; pop float index
59:		fstp qword [bp + 14]
61:	

sin$19:	; push 0
62:		fldz
64:	

sin$20:	; pop float sum
65:		fstp qword [bp + 30]
67:	

sin$21:	; push 1
68:		fld1
70:	

sin$22:	; pop float sign
71:		fstp qword [bp + 38]
73:	

sin$23:	; push float x
74:		fld qword [bp + 6]
76:	

sin$24:	; pop float power
77:		fstp qword [bp + 46]
79:	

sin$25:	; push 1
80:		fld1
82:	

sin$26:	; pop float faculty
83:		fstp qword [bp + 54]
85:	

sin$27:	; push float sign
86:		fld qword [bp + 38]
88:	

sin$28:	; push float power
89:		fld qword [bp + 46]
91:	

sin$29:	; £temporary661 = sign * power
92:		fmul
94:	

sin$30:	; push float faculty
95:		fld qword [bp + 54]
97:	

sin$31:	; £temporary662 = £temporary661 / faculty
98:		fdiv
100:	

sin$32:	; pop float term
101:		fstp qword [bp + 22]
103:	

sin$33:	; push float sum
104:		fld qword [bp + 30]
106:	

sin$34:	; push float term
107:		fld qword [bp + 22]
109:	

sin$35:	; £temporary663 = sum + term
110:		fadd
112:	

sin$36:	; pop float sum
113:		fstp qword [bp + 30]
115:	

sin$37:	; push float sign
116:		fld qword [bp + 38]
118:	

sin$38:	; push float -1
119:		fld qword [float8$minus1#]
121:	

sin$39:	; £temporary664 = sign * -1
122:		fmul
124:	

sin$40:	; pop float sign
125:		fstp qword [bp + 38]
127:	

sin$41:	; push float power
128:		fld qword [bp + 46]
130:	

sin$42:	; push float x
131:		fld qword [bp + 6]
133:	

sin$43:	; push float x
134:		fld qword [bp + 6]
136:	

sin$44:	; £temporary665 = x * x
137:		fmul
139:	

sin$45:	; £temporary666 = power * £temporary665
140:		fmul
142:	

sin$46:	; pop float power
143:		fstp qword [bp + 46]
145:	

sin$47:	; push float faculty
146:		fld qword [bp + 54]
148:	

sin$48:	; push float index
149:		fld qword [bp + 14]
151:	

sin$49:	; push 1
152:		fld1
154:	

sin$50:	; index = index + 1
155:		fadd
157:	

sin$51:	; top float index
158:		fst qword [bp + 14]
160:	

sin$52:	; push float index
161:		fld qword [bp + 14]
163:	

sin$53:	; push 1
164:		fld1
166:	

sin$54:	; index = index + 1
167:		fadd
169:	

sin$55:	; top float index
170:		fst qword [bp + 14]
172:	

sin$56:	; £temporary669 = £temporary667 * £temporary668
173:		fmul
175:	

sin$57:	; £temporary670 = faculty * £temporary669
176:		fmul
178:	

sin$58:	; pop float faculty
179:		fstp qword [bp + 54]
181:	

sin$59:	; call header integral zero 0 stack zero 0
183:	

sin$60:	; push float term
184:		fld qword [bp + 22]
186:	

sin$61:	; parameter term, offset 6
187:		fstp qword [bp + 68]
189:	

sin$62:	; call function noellipse-noellipse fabs
190:		mov word [bp + 62], sin$63
191:		mov [bp + 64], bp
192:		add bp, 62
193:		jmp fabs
195:	

sin$63:	; post call
197:	

sin$64:	; £temporary671 = return_value
199:	

sin$65:	; push float 0.000000001
200:		fld qword [float8$0.000000001#]
202:	

sin$66:	; if £temporary671 >= 0.000000001 goto 27
203:		fcompp
204:		fstsw ax
205:		sahf
206:		jbe sin$27
208:	

sin$67:	; push float sum
209:		fld qword [bp + 30]
211:	

sin$68:	; return_value = sum
213:	

sin$69:	; return
214:		mov ax, [bp]
215:		mov di, [bp + 4]
216:		mov bp, [bp + 2]
217:		jmp ax
219:	

sin$70:	; function end sin
1:	

cos:	; call header integral zero 0 stack zero 0
3:	

cos$1:	; push float x
4:		fld qword [bp + 6]
6:	

cos$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

cos$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 14], cos$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp fabs
15:	

cos$4:	; post call
17:	

cos$5:	; £temporary677 = return_value
19:	

cos$6:	; push float 6.28
20:		fld qword [float8$6.28#]
22:	

cos$7:	; if £temporary677 <= 6.28 goto 17
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae cos$17
28:	

cos$8:	; call header integral zero 0 stack zero 0
30:	

cos$9:	; push float x
31:		fld qword [bp + 6]
33:	

cos$10:	; parameter x, offset 6
34:		fstp qword [bp + 20]
36:	

cos$11:	; push float 6.28
37:		fld qword [float8$6.28#]
39:	

cos$12:	; parameter 6.28, offset 14
40:		fstp qword [bp + 28]
42:	

cos$13:	; call function noellipse-noellipse fmod
43:		mov word [bp + 14], cos$14
44:		mov [bp + 16], bp
45:		add bp, 14
46:		jmp fmod
48:	

cos$14:	; post call
50:	

cos$15:	; £temporary679 = return_value
52:	

cos$16:	; pop float x
53:		fstp qword [bp + 6]
55:	

cos$17:	; push 0
56:		fldz
58:	

cos$18:	; pop float index
59:		fstp qword [bp + 14]
61:	

cos$19:	; push 0
62:		fldz
64:	

cos$20:	; pop float sum
65:		fstp qword [bp + 30]
67:	

cos$21:	; push 1
68:		fld1
70:	

cos$22:	; pop float sign
71:		fstp qword [bp + 38]
73:	

cos$23:	; push 1
74:		fld1
76:	

cos$24:	; pop float power
77:		fstp qword [bp + 46]
79:	

cos$25:	; push 1
80:		fld1
82:	

cos$26:	; pop float faculty
83:		fstp qword [bp + 54]
85:	

cos$27:	; push float sign
86:		fld qword [bp + 38]
88:	

cos$28:	; push float power
89:		fld qword [bp + 46]
91:	

cos$29:	; £temporary680 = sign * power
92:		fmul
94:	

cos$30:	; push float faculty
95:		fld qword [bp + 54]
97:	

cos$31:	; £temporary681 = £temporary680 / faculty
98:		fdiv
100:	

cos$32:	; pop float term
101:		fstp qword [bp + 22]
103:	

cos$33:	; push float sum
104:		fld qword [bp + 30]
106:	

cos$34:	; push float term
107:		fld qword [bp + 22]
109:	

cos$35:	; £temporary682 = sum + term
110:		fadd
112:	

cos$36:	; pop float sum
113:		fstp qword [bp + 30]
115:	

cos$37:	; push float sign
116:		fld qword [bp + 38]
118:	

cos$38:	; push float -1
119:		fld qword [float8$minus1#]
121:	

cos$39:	; £temporary683 = sign * -1
122:		fmul
124:	

cos$40:	; pop float sign
125:		fstp qword [bp + 38]
127:	

cos$41:	; push float power
128:		fld qword [bp + 46]
130:	

cos$42:	; push float x
131:		fld qword [bp + 6]
133:	

cos$43:	; push float x
134:		fld qword [bp + 6]
136:	

cos$44:	; £temporary684 = x * x
137:		fmul
139:	

cos$45:	; £temporary685 = power * £temporary684
140:		fmul
142:	

cos$46:	; pop float power
143:		fstp qword [bp + 46]
145:	

cos$47:	; push float faculty
146:		fld qword [bp + 54]
148:	

cos$48:	; push float index
149:		fld qword [bp + 14]
151:	

cos$49:	; push 1
152:		fld1
154:	

cos$50:	; index = index + 1
155:		fadd
157:	

cos$51:	; top float index
158:		fst qword [bp + 14]
160:	

cos$52:	; push float index
161:		fld qword [bp + 14]
163:	

cos$53:	; push 1
164:		fld1
166:	

cos$54:	; index = index + 1
167:		fadd
169:	

cos$55:	; top float index
170:		fst qword [bp + 14]
172:	

cos$56:	; £temporary688 = £temporary686 * £temporary687
173:		fmul
175:	

cos$57:	; £temporary689 = faculty * £temporary688
176:		fmul
178:	

cos$58:	; pop float faculty
179:		fstp qword [bp + 54]
181:	

cos$59:	; call header integral zero 0 stack zero 0
183:	

cos$60:	; push float term
184:		fld qword [bp + 22]
186:	

cos$61:	; parameter term, offset 6
187:		fstp qword [bp + 68]
189:	

cos$62:	; call function noellipse-noellipse fabs
190:		mov word [bp + 62], cos$63
191:		mov [bp + 64], bp
192:		add bp, 62
193:		jmp fabs
195:	

cos$63:	; post call
197:	

cos$64:	; £temporary690 = return_value
199:	

cos$65:	; push float 0.000000001
200:		fld qword [float8$0.000000001#]
202:	

cos$66:	; if £temporary690 >= 0.000000001 goto 27
203:		fcompp
204:		fstsw ax
205:		sahf
206:		jbe cos$27
208:	

cos$67:	; push float sum
209:		fld qword [bp + 30]
211:	

cos$68:	; return_value = sum
213:	

cos$69:	; return
214:		mov ax, [bp]
215:		mov di, [bp + 4]
216:		mov bp, [bp + 2]
217:		jmp ax
219:	

cos$70:	; function end cos
1:	

tan:	; call header integral zero 0 stack zero 0
3:	

tan$1:	; push float x
4:		fld qword [bp + 6]
6:	

tan$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

tan$3:	; call function noellipse-noellipse cos
10:		mov word [bp + 14], tan$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp cos
15:	

tan$4:	; post call
17:	

tan$5:	; £temporary696 = return_value
19:	

tan$6:	; pop float cos_of_x
20:		fstp qword [bp + 14]
22:	

tan$7:	; push float cos_of_x
23:		fld qword [bp + 14]
25:	

tan$8:	; push 0
26:		fldz
28:	

tan$9:	; if cos_of_x == 0 goto 20
29:		fcompp
30:		fstsw ax
31:		sahf
32:		je tan$20
34:	

tan$10:	; call header integral zero 0 stack zero 0
36:	

tan$11:	; push float x
37:		fld qword [bp + 6]
39:	

tan$12:	; parameter x, offset 6
40:		fstp qword [bp + 28]
42:	

tan$13:	; call function noellipse-noellipse sin
43:		mov word [bp + 22], tan$14
44:		mov [bp + 24], bp
45:		add bp, 22
46:		jmp sin
48:	

tan$14:	; post call
50:	

tan$15:	; £temporary698 = return_value
52:	

tan$16:	; push float cos_of_x
53:		fld qword [bp + 14]
55:	

tan$17:	; £temporary699 = £temporary698 / cos_of_x
56:		fdiv
58:	

tan$18:	; return_value = £temporary699
60:	

tan$19:	; return
61:		mov ax, [bp]
62:		mov di, [bp + 4]
63:		mov bp, [bp + 2]
64:		jmp ax
66:	

tan$20:	; errno = 6
67:		mov word [errno], 6
69:	

tan$21:	; push 0
70:		fldz
72:	

tan$22:	; return_value = 0
74:	

tan$23:	; return
75:		mov ax, [bp]
76:		mov di, [bp + 4]
77:		mov bp, [bp + 2]
78:		jmp ax
80:	

tan$24:	; function end tan
1:	

asin:	; push float x
2:		fld qword [bp + 6]
4:	

asin$1:	; push 1
5:		fld1
7:	

asin$2:	; if x != 1 goto 6
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jne asin$6
13:	

asin$3:	; push float 1.57
14:		fld qword [float8$1.57#]
16:	

asin$4:	; return_value = 1.57
18:	

asin$5:	; return
19:		mov ax, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp ax
24:	

asin$6:	; push float x
25:		fld qword [bp + 6]
27:	

asin$7:	; push 0
28:		fldz
30:	

asin$8:	; if x >= 0 goto 19
31:		fcompp
32:		fstsw ax
33:		sahf
34:		jbe asin$19
36:	

asin$9:	; call header integral zero 0 stack zero 0
38:	

asin$10:	; push float x
39:		fld qword [bp + 6]
41:	

asin$11:	; £temporary704 = -x
42:		fchs
44:	

asin$12:	; parameter £temporary704, offset 6
45:		fstp qword [bp + 20]
47:	

asin$13:	; call function noellipse-noellipse asin
48:		mov word [bp + 14], asin$14
49:		mov [bp + 16], bp
50:		add bp, 14
51:		jmp asin
53:	

asin$14:	; post call
55:	

asin$15:	; £temporary705 = return_value
57:	

asin$16:	; £temporary706 = -£temporary705
58:		fchs
60:	

asin$17:	; return_value = £temporary706
62:	

asin$18:	; return
63:		mov ax, [bp]
64:		mov di, [bp + 4]
65:		mov bp, [bp + 2]
66:		jmp ax
68:	

asin$19:	; push float x
69:		fld qword [bp + 6]
71:	

asin$20:	; push 1
72:		fld1
74:	

asin$21:	; if x >= 1 goto 41
75:		fcompp
76:		fstsw ax
77:		sahf
78:		jbe asin$41
80:	

asin$22:	; call header integral zero 0 stack zero 0
82:	

asin$23:	; push float x
83:		fld qword [bp + 6]
85:	

asin$24:	; call header integral zero 0 stack no zero 1
86:		fstp qword [bp + 14]
88:	

asin$25:	; push 1
89:		fld1
91:	

asin$26:	; push float x
92:		fld qword [bp + 6]
94:	

asin$27:	; push float x
95:		fld qword [bp + 6]
97:	

asin$28:	; £temporary708 = x * x
98:		fmul
100:	

asin$29:	; £temporary709 = 1 - £temporary708
101:		fsub
103:	

asin$30:	; parameter £temporary709, offset 6
104:		fstp qword [bp + 28]
106:	

asin$31:	; call function noellipse-noellipse sqrt
107:		mov word [bp + 22], asin$32
108:		mov [bp + 24], bp
109:		add bp, 22
110:		jmp sqrt
112:	

asin$32:	; post call
113:		fstp qword [bp + 22]
114:		fld qword [bp + 14]
115:		fld qword [bp + 22]
117:	

asin$33:	; £temporary710 = return_value
119:	

asin$34:	; £temporary711 = x / £temporary710
120:		fdiv
122:	

asin$35:	; parameter £temporary711, offset 6
123:		fstp qword [bp + 20]
125:	

asin$36:	; call function noellipse-noellipse atan
126:		mov word [bp + 14], asin$37
127:		mov [bp + 16], bp
128:		add bp, 14
129:		jmp atan
131:	

asin$37:	; post call
133:	

asin$38:	; £temporary712 = return_value
135:	

asin$39:	; return_value = £temporary712
137:	

asin$40:	; return
138:		mov ax, [bp]
139:		mov di, [bp + 4]
140:		mov bp, [bp + 2]
141:		jmp ax
143:	

asin$41:	; errno = 6
144:		mov word [errno], 6
146:	

asin$42:	; push 0
147:		fldz
149:	

asin$43:	; return_value = 0
151:	

asin$44:	; return
152:		mov ax, [bp]
153:		mov di, [bp + 4]
154:		mov bp, [bp + 2]
155:		jmp ax
157:	

asin$45:	; function end asin
1:	

acos:	; push float x
2:		fld qword [bp + 6]
4:	

acos$1:	; push 0
5:		fldz
7:	

acos$2:	; if x != 0 goto 6
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jne acos$6
13:	

acos$3:	; push float 1.57
14:		fld qword [float8$1.57#]
16:	

acos$4:	; return_value = 1.57
18:	

acos$5:	; return
19:		mov ax, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp ax
24:	

acos$6:	; push float x
25:		fld qword [bp + 6]
27:	

acos$7:	; push 0
28:		fldz
30:	

acos$8:	; if x >= 0 goto 20
31:		fcompp
32:		fstsw ax
33:		sahf
34:		jbe acos$20
36:	

acos$9:	; push float 3.14
37:		fld qword [float8$3.14#]
39:	

acos$10:	; call header integral zero 0 stack no zero 1
40:		fstp qword [bp + 14]
42:	

acos$11:	; push float x
43:		fld qword [bp + 6]
45:	

acos$12:	; £temporary718 = -x
46:		fchs
48:	

acos$13:	; parameter £temporary718, offset 6
49:		fstp qword [bp + 28]
51:	

acos$14:	; call function noellipse-noellipse acos
52:		mov word [bp + 22], acos$15
53:		mov [bp + 24], bp
54:		add bp, 22
55:		jmp acos
57:	

acos$15:	; post call
58:		fstp qword [bp + 22]
59:		fld qword [bp + 14]
60:		fld qword [bp + 22]
62:	

acos$16:	; £temporary719 = return_value
64:	

acos$17:	; £temporary720 = 3.14 - £temporary719
65:		fsub
67:	

acos$18:	; return_value = £temporary720
69:	

acos$19:	; return
70:		mov ax, [bp]
71:		mov di, [bp + 4]
72:		mov bp, [bp + 2]
73:		jmp ax
75:	

acos$20:	; push float x
76:		fld qword [bp + 6]
78:	

acos$21:	; push 1
79:		fld1
81:	

acos$22:	; if x > 1 goto 42
82:		fcompp
83:		fstsw ax
84:		sahf
85:		jb acos$42
87:	

acos$23:	; call header integral zero 0 stack zero 0
89:	

acos$24:	; call header integral zero 0 stack zero 0
91:	

acos$25:	; push 1
92:		fld1
94:	

acos$26:	; push float x
95:		fld qword [bp + 6]
97:	

acos$27:	; push float x
98:		fld qword [bp + 6]
100:	

acos$28:	; £temporary722 = x * x
101:		fmul
103:	

acos$29:	; £temporary723 = 1 - £temporary722
104:		fsub
106:	

acos$30:	; parameter £temporary723, offset 6
107:		fstp qword [bp + 20]
109:	

acos$31:	; call function noellipse-noellipse sqrt
110:		mov word [bp + 14], acos$32
111:		mov [bp + 16], bp
112:		add bp, 14
113:		jmp sqrt
115:	

acos$32:	; post call
117:	

acos$33:	; £temporary724 = return_value
119:	

acos$34:	; push float x
120:		fld qword [bp + 6]
122:	

acos$35:	; £temporary725 = £temporary724 / x
123:		fdiv
125:	

acos$36:	; parameter £temporary725, offset 6
126:		fstp qword [bp + 20]
128:	

acos$37:	; call function noellipse-noellipse atan
129:		mov word [bp + 14], acos$38
130:		mov [bp + 16], bp
131:		add bp, 14
132:		jmp atan
134:	

acos$38:	; post call
136:	

acos$39:	; £temporary726 = return_value
138:	

acos$40:	; return_value = £temporary726
140:	

acos$41:	; return
141:		mov ax, [bp]
142:		mov di, [bp + 4]
143:		mov bp, [bp + 2]
144:		jmp ax
146:	

acos$42:	; errno = 6
147:		mov word [errno], 6
149:	

acos$43:	; push 0
150:		fldz
152:	

acos$44:	; return_value = 0
154:	

acos$45:	; return
155:		mov ax, [bp]
156:		mov di, [bp + 4]
157:		mov bp, [bp + 2]
158:		jmp ax
160:	

acos$46:	; function end acos
1:	

atan:	; push float x
2:		fld qword [bp + 6]
4:	

atan$1:	; push 0
5:		fldz
7:	

atan$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe atan$13
13:	

atan$3:	; call header integral zero 0 stack zero 0
15:	

atan$4:	; push float x
16:		fld qword [bp + 6]
18:	

atan$5:	; £temporary731 = -x
19:		fchs
21:	

atan$6:	; parameter £temporary731, offset 6
22:		fstp qword [bp + 20]
24:	

atan$7:	; call function noellipse-noellipse atan
25:		mov word [bp + 14], atan$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp atan
30:	

atan$8:	; post call
32:	

atan$9:	; £temporary732 = return_value
34:	

atan$10:	; £temporary733 = -£temporary732
35:		fchs
37:	

atan$11:	; return_value = £temporary733
39:	

atan$12:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

atan$13:	; push float x
46:		fld qword [bp + 6]
48:	

atan$14:	; push 1
49:		fld1
51:	

atan$15:	; if x <= 1 goto 28
52:		fcompp
53:		fstsw ax
54:		sahf
55:		jae atan$28
57:	

atan$16:	; push float 1.57
58:		fld qword [float8$1.57#]
60:	

atan$17:	; call header integral zero 0 stack no zero 1
61:		fstp qword [bp + 14]
63:	

atan$18:	; push 1
64:		fld1
66:	

atan$19:	; push float x
67:		fld qword [bp + 6]
69:	

atan$20:	; £temporary735 = 1 / x
70:		fdiv
72:	

atan$21:	; parameter £temporary735, offset 6
73:		fstp qword [bp + 28]
75:	

atan$22:	; call function noellipse-noellipse atan
76:		mov word [bp + 22], atan$23
77:		mov [bp + 24], bp
78:		add bp, 22
79:		jmp atan
81:	

atan$23:	; post call
82:		fstp qword [bp + 22]
83:		fld qword [bp + 14]
84:		fld qword [bp + 22]
86:	

atan$24:	; £temporary736 = return_value
88:	

atan$25:	; £temporary737 = 1.57 - £temporary736
89:		fsub
91:	

atan$26:	; return_value = £temporary737
93:	

atan$27:	; return
94:		mov ax, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp ax
99:	

atan$28:	; push float x
100:		fld qword [bp + 6]
102:	

atan$29:	; push float 0.5
103:		fld qword [float8$0.5#]
105:	

atan$30:	; if x <= 0.5 goto 54
106:		fcompp
107:		fstsw ax
108:		sahf
109:		jae atan$54
111:	

atan$31:	; push float 2
112:		fld qword [float8$2#]
114:	

atan$32:	; call header integral zero 0 stack no zero 1
115:		fstp qword [bp + 14]
117:	

atan$33:	; push float x
118:		fld qword [bp + 6]
120:	

atan$34:	; push 1
121:		fld1
123:	

atan$35:	; call header integral zero 0 stack no zero 3
124:		fstp qword [bp + 22]
125:		fstp qword [bp + 30]
127:	

atan$36:	; push 1
128:		fld1
130:	

atan$37:	; push float x
131:		fld qword [bp + 6]
133:	

atan$38:	; push float x
134:		fld qword [bp + 6]
136:	

atan$39:	; £temporary739 = x * x
137:		fmul
139:	

atan$40:	; £temporary740 = 1 + £temporary739
140:		fadd
142:	

atan$41:	; parameter £temporary740, offset 6
143:		fstp qword [bp + 44]
145:	

atan$42:	; call function noellipse-noellipse sqrt
146:		mov word [bp + 46], atan$43
147:		mov [bp + 48], bp
148:		add bp, 46
149:		jmp sqrt
151:	

atan$43:	; post call
152:		fstp qword [bp + 38]
153:		fld qword [bp + 30]
154:		fld qword [bp + 22]
155:		fld qword [bp + 38]
157:	

atan$44:	; £temporary741 = return_value
159:	

atan$45:	; £temporary742 = 1 + £temporary741
160:		fadd
162:	

atan$46:	; £temporary743 = x / £temporary742
163:		fdiv
165:	

atan$47:	; parameter £temporary743, offset 6
166:		fstp qword [bp + 28]
168:	

atan$48:	; call function noellipse-noellipse atan
169:		mov word [bp + 22], atan$49
170:		mov [bp + 24], bp
171:		add bp, 22
172:		jmp atan
174:	

atan$49:	; post call
175:		fstp qword [bp + 22]
176:		fld qword [bp + 14]
177:		fld qword [bp + 22]
179:	

atan$50:	; £temporary744 = return_value
181:	

atan$51:	; £temporary745 = 2 * £temporary744
182:		fmul
184:	

atan$52:	; return_value = £temporary745
186:	

atan$53:	; return
187:		mov ax, [bp]
188:		mov di, [bp + 4]
189:		mov bp, [bp + 2]
190:		jmp ax
192:	

atan$54:	; push 0
193:		fldz
195:	

atan$55:	; pop float sum
196:		fstp qword [bp + 22]
198:	

atan$56:	; push 1
199:		fld1
201:	

atan$57:	; pop float sign
202:		fstp qword [bp + 30]
204:	

atan$58:	; push 1
205:		fld1
207:	

atan$59:	; pop float denominator
208:		fstp qword [bp + 38]
210:	

atan$60:	; push float x
211:		fld qword [bp + 6]
213:	

atan$61:	; pop float product
214:		fstp qword [bp + 46]
216:	

atan$62:	; push float sign
217:		fld qword [bp + 30]
219:	

atan$63:	; push float product
220:		fld qword [bp + 46]
222:	

atan$64:	; £temporary746 = sign * product
223:		fmul
225:	

atan$65:	; push float denominator
226:		fld qword [bp + 38]
228:	

atan$66:	; £temporary747 = £temporary746 / denominator
229:		fdiv
231:	

atan$67:	; pop float term
232:		fstp qword [bp + 14]
234:	

atan$68:	; push float sum
235:		fld qword [bp + 22]
237:	

atan$69:	; push float term
238:		fld qword [bp + 14]
240:	

atan$70:	; £temporary748 = sum + term
241:		fadd
243:	

atan$71:	; pop float sum
244:		fstp qword [bp + 22]
246:	

atan$72:	; push float sign
247:		fld qword [bp + 30]
249:	

atan$73:	; £temporary749 = -sign
250:		fchs
252:	

atan$74:	; pop float sign
253:		fstp qword [bp + 30]
255:	

atan$75:	; push float product
256:		fld qword [bp + 46]
258:	

atan$76:	; push float x
259:		fld qword [bp + 6]
261:	

atan$77:	; push float x
262:		fld qword [bp + 6]
264:	

atan$78:	; £temporary750 = x * x
265:		fmul
267:	

atan$79:	; £temporary751 = product * £temporary750
268:		fmul
270:	

atan$80:	; pop float product
271:		fstp qword [bp + 46]
273:	

atan$81:	; push float denominator
274:		fld qword [bp + 38]
276:	

atan$82:	; push float 2
277:		fld qword [float8$2#]
279:	

atan$83:	; £temporary752 = denominator + 2
280:		fadd
282:	

atan$84:	; pop float denominator
283:		fstp qword [bp + 38]
285:	

atan$85:	; call header integral zero 0 stack zero 0
287:	

atan$86:	; push float term
288:		fld qword [bp + 14]
290:	

atan$87:	; parameter term, offset 6
291:		fstp qword [bp + 60]
293:	

atan$88:	; call function noellipse-noellipse fabs
294:		mov word [bp + 54], atan$89
295:		mov [bp + 56], bp
296:		add bp, 54
297:		jmp fabs
299:	

atan$89:	; post call
301:	

atan$90:	; £temporary753 = return_value
303:	

atan$91:	; push float 0.000000001
304:		fld qword [float8$0.000000001#]
306:	

atan$92:	; if £temporary753 >= 0.000000001 goto 62
307:		fcompp
308:		fstsw ax
309:		sahf
310:		jbe atan$62
312:	

atan$93:	; push float sum
313:		fld qword [bp + 22]
315:	

atan$94:	; return_value = sum
317:	

atan$95:	; return
318:		mov ax, [bp]
319:		mov di, [bp + 4]
320:		mov bp, [bp + 2]
321:		jmp ax
323:	

atan$96:	; function end atan
1:	

atan2:	; push float y
2:		fld qword [bp + 14]
4:	

atan2$1:	; push 0
5:		fldz
7:	

atan2$2:	; if y <= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jae atan2$13
13:	

atan2$3:	; call header integral zero 0 stack zero 0
15:	

atan2$4:	; push float x
16:		fld qword [bp + 6]
18:	

atan2$5:	; push float y
19:		fld qword [bp + 14]
21:	

atan2$6:	; £temporary761 = x / y
22:		fdiv
24:	

atan2$7:	; parameter £temporary761, offset 6
25:		fstp qword [bp + 28]
27:	

atan2$8:	; call function noellipse-noellipse atan
28:		mov word [bp + 22], atan2$9
29:		mov [bp + 24], bp
30:		add bp, 22
31:		jmp atan
33:	

atan2$9:	; post call
35:	

atan2$10:	; £temporary762 = return_value
37:	

atan2$11:	; return_value = £temporary762
39:	

atan2$12:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

atan2$13:	; push float x
46:		fld qword [bp + 6]
48:	

atan2$14:	; push 0
49:		fldz
51:	

atan2$15:	; if x < 0 goto 31
52:		fcompp
53:		fstsw ax
54:		sahf
55:		ja atan2$31
57:	

atan2$16:	; push float y
58:		fld qword [bp + 14]
60:	

atan2$17:	; push 0
61:		fldz
63:	

atan2$18:	; if y >= 0 goto 31
64:		fcompp
65:		fstsw ax
66:		sahf
67:		jbe atan2$31
69:	

atan2$19:	; push float 3.14
70:		fld qword [float8$3.14#]
72:	

atan2$20:	; call header integral zero 0 stack no zero 1
73:		fstp qword [bp + 22]
75:	

atan2$21:	; push float x
76:		fld qword [bp + 6]
78:	

atan2$22:	; push float y
79:		fld qword [bp + 14]
81:	

atan2$23:	; £temporary766 = x / y
82:		fdiv
84:	

atan2$24:	; parameter £temporary766, offset 6
85:		fstp qword [bp + 36]
87:	

atan2$25:	; call function noellipse-noellipse atan
88:		mov word [bp + 30], atan2$26
89:		mov [bp + 32], bp
90:		add bp, 30
91:		jmp atan
93:	

atan2$26:	; post call
94:		fstp qword [bp + 30]
95:		fld qword [bp + 22]
96:		fld qword [bp + 30]
98:	

atan2$27:	; £temporary767 = return_value
100:	

atan2$28:	; £temporary768 = 3.14 + £temporary767
101:		fadd
103:	

atan2$29:	; return_value = £temporary768
105:	

atan2$30:	; return
106:		mov ax, [bp]
107:		mov di, [bp + 4]
108:		mov bp, [bp + 2]
109:		jmp ax
111:	

atan2$31:	; push float x
112:		fld qword [bp + 6]
114:	

atan2$32:	; push 0
115:		fldz
117:	

atan2$33:	; if x >= 0 goto 49
118:		fcompp
119:		fstsw ax
120:		sahf
121:		jbe atan2$49
123:	

atan2$34:	; push float y
124:		fld qword [bp + 14]
126:	

atan2$35:	; push 0
127:		fldz
129:	

atan2$36:	; if y >= 0 goto 49
130:		fcompp
131:		fstsw ax
132:		sahf
133:		jbe atan2$49
135:	

atan2$37:	; push float -3.14
136:		fld qword [float8$minus3.14#]
138:	

atan2$38:	; call header integral zero 0 stack no zero 1
139:		fstp qword [bp + 22]
141:	

atan2$39:	; push float x
142:		fld qword [bp + 6]
144:	

atan2$40:	; push float y
145:		fld qword [bp + 14]
147:	

atan2$41:	; £temporary772 = x / y
148:		fdiv
150:	

atan2$42:	; parameter £temporary772, offset 6
151:		fstp qword [bp + 36]
153:	

atan2$43:	; call function noellipse-noellipse atan
154:		mov word [bp + 30], atan2$44
155:		mov [bp + 32], bp
156:		add bp, 30
157:		jmp atan
159:	

atan2$44:	; post call
160:		fstp qword [bp + 30]
161:		fld qword [bp + 22]
162:		fld qword [bp + 30]
164:	

atan2$45:	; £temporary773 = return_value
166:	

atan2$46:	; £temporary774 = -3.14 + £temporary773
167:		fadd
169:	

atan2$47:	; return_value = £temporary774
171:	

atan2$48:	; return
172:		mov ax, [bp]
173:		mov di, [bp + 4]
174:		mov bp, [bp + 2]
175:		jmp ax
177:	

atan2$49:	; push float x
178:		fld qword [bp + 6]
180:	

atan2$50:	; push 0
181:		fldz
183:	

atan2$51:	; if x <= 0 goto 58
184:		fcompp
185:		fstsw ax
186:		sahf
187:		jae atan2$58
189:	

atan2$52:	; push float y
190:		fld qword [bp + 14]
192:	

atan2$53:	; push 0
193:		fldz
195:	

atan2$54:	; if y != 0 goto 58
196:		fcompp
197:		fstsw ax
198:		sahf
199:		jne atan2$58
201:	

atan2$55:	; push float 1.57
202:		fld qword [float8$1.57#]
204:	

atan2$56:	; return_value = 1.57
206:	

atan2$57:	; return
207:		mov ax, [bp]
208:		mov di, [bp + 4]
209:		mov bp, [bp + 2]
210:		jmp ax
212:	

atan2$58:	; push float x
213:		fld qword [bp + 6]
215:	

atan2$59:	; push 0
216:		fldz
218:	

atan2$60:	; if x >= 0 goto 67
219:		fcompp
220:		fstsw ax
221:		sahf
222:		jbe atan2$67
224:	

atan2$61:	; push float y
225:		fld qword [bp + 14]
227:	

atan2$62:	; push 0
228:		fldz
230:	

atan2$63:	; if y != 0 goto 67
231:		fcompp
232:		fstsw ax
233:		sahf
234:		jne atan2$67
236:	

atan2$64:	; push float -1.57
237:		fld qword [float8$minus1.57#]
239:	

atan2$65:	; return_value = -1.57
241:	

atan2$66:	; return
242:		mov ax, [bp]
243:		mov di, [bp + 4]
244:		mov bp, [bp + 2]
245:		jmp ax
247:	

atan2$67:	; errno = 6
248:		mov word [errno], 6
250:	

atan2$68:	; push 0
251:		fldz
253:	

atan2$69:	; return_value = 0
255:	

atan2$70:	; return
256:		mov ax, [bp]
257:		mov di, [bp + 4]
258:		mov bp, [bp + 2]
259:		jmp ax
261:	

atan2$71:	; function end atan2
1:	

sinh:	; call header integral zero 0 stack zero 0
3:	

sinh$1:	; push float x
4:		fld qword [bp + 6]
6:	

sinh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

sinh$3:	; call function noellipse-noellipse exp
10:		mov word [bp + 14], sinh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp exp
15:	

sinh$4:	; post call
17:	

sinh$5:	; £temporary784 = return_value
19:	

sinh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

sinh$7:	; push float x
23:		fld qword [bp + 6]
25:	

sinh$8:	; £temporary785 = -x
26:		fchs
28:	

sinh$9:	; parameter £temporary785, offset 6
29:		fstp qword [bp + 28]
31:	

sinh$10:	; call function noellipse-noellipse exp
32:		mov word [bp + 22], sinh$11
33:		mov [bp + 24], bp
34:		add bp, 22
35:		jmp exp
37:	

sinh$11:	; post call
38:		fstp qword [bp + 22]
39:		fld qword [bp + 14]
40:		fld qword [bp + 22]
42:	

sinh$12:	; £temporary786 = return_value
44:	

sinh$13:	; £temporary787 = £temporary784 - £temporary786
45:		fsub
47:	

sinh$14:	; push float 2
48:		fld qword [float8$2#]
50:	

sinh$15:	; £temporary788 = £temporary787 / 2
51:		fdiv
53:	

sinh$16:	; return_value = £temporary788
55:	

sinh$17:	; return
56:		mov ax, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp ax
61:	

sinh$18:	; function end sinh
1:	

cosh:	; call header integral zero 0 stack zero 0
3:	

cosh$1:	; push float x
4:		fld qword [bp + 6]
6:	

cosh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

cosh$3:	; call function noellipse-noellipse exp
10:		mov word [bp + 14], cosh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp exp
15:	

cosh$4:	; post call
17:	

cosh$5:	; £temporary791 = return_value
19:	

cosh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

cosh$7:	; push float x
23:		fld qword [bp + 6]
25:	

cosh$8:	; £temporary792 = -x
26:		fchs
28:	

cosh$9:	; parameter £temporary792, offset 6
29:		fstp qword [bp + 28]
31:	

cosh$10:	; call function noellipse-noellipse exp
32:		mov word [bp + 22], cosh$11
33:		mov [bp + 24], bp
34:		add bp, 22
35:		jmp exp
37:	

cosh$11:	; post call
38:		fstp qword [bp + 22]
39:		fld qword [bp + 14]
40:		fld qword [bp + 22]
42:	

cosh$12:	; £temporary793 = return_value
44:	

cosh$13:	; £temporary794 = £temporary791 + £temporary793
45:		fadd
47:	

cosh$14:	; push float 2
48:		fld qword [float8$2#]
50:	

cosh$15:	; £temporary795 = £temporary794 / 2
51:		fdiv
53:	

cosh$16:	; return_value = £temporary795
55:	

cosh$17:	; return
56:		mov ax, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp ax
61:	

cosh$18:	; function end cosh
1:	

tanh:	; call header integral zero 0 stack zero 0
3:	

tanh$1:	; push float x
4:		fld qword [bp + 6]
6:	

tanh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

tanh$3:	; call function noellipse-noellipse sinh
10:		mov word [bp + 14], tanh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp sinh
15:	

tanh$4:	; post call
17:	

tanh$5:	; £temporary798 = return_value
19:	

tanh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

tanh$7:	; push float x
23:		fld qword [bp + 6]
25:	

tanh$8:	; parameter x, offset 6
26:		fstp qword [bp + 28]
28:	

tanh$9:	; call function noellipse-noellipse cosh
29:		mov word [bp + 22], tanh$10
30:		mov [bp + 24], bp
31:		add bp, 22
32:		jmp cosh
34:	

tanh$10:	; post call
35:		fstp qword [bp + 22]
36:		fld qword [bp + 14]
37:		fld qword [bp + 22]
39:	

tanh$11:	; £temporary799 = return_value
41:	

tanh$12:	; £temporary800 = £temporary798 / £temporary799
42:		fdiv
44:	

tanh$13:	; return_value = £temporary800
46:	

tanh$14:	; return
47:		mov ax, [bp]
48:		mov di, [bp + 4]
49:		mov bp, [bp + 2]
50:		jmp ax
52:	

tanh$15:	; function end tanh
1:	

floor:	; push float x
2:		fld qword [bp + 6]
4:	

floor$1:	; push 0
5:		fldz
7:	

floor$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe floor$13
13:	

floor$3:	; call header integral zero 0 stack zero 0
15:	

floor$4:	; push float x
16:		fld qword [bp + 6]
18:	

floor$5:	; £temporary804 = -x
19:		fchs
21:	

floor$6:	; parameter £temporary804, offset 6
22:		fstp qword [bp + 20]
24:	

floor$7:	; call function noellipse-noellipse ceil
25:		mov word [bp + 14], floor$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp ceil
30:	

floor$8:	; post call
32:	

floor$9:	; £temporary805 = return_value
34:	

floor$10:	; £temporary806 = -£temporary805
35:		fchs
37:	

floor$11:	; return_value = £temporary806
39:	

floor$12:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

floor$13:	; push float x
46:		fld qword [bp + 6]
48:	

floor$14:	; £temporary807 = float_to_int x (Double -> Signed_Long_Int)
49:		fistp dword [container4bytes#]
50:		mov eax, [container4bytes#]
52:	

floor$15:	; £temporary808 = int_to_float £temporary807 (Signed_Long_Int -> Double)
53:		mov [container4bytes#], eax
54:		fild dword [container4bytes#]
56:	

floor$16:	; return_value = £temporary808
58:	

floor$17:	; return
59:		mov ax, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp ax
64:	

floor$18:	; function end floor
1:	

ceil:	; push float x
2:		fld qword [bp + 6]
4:	

ceil$1:	; push 0
5:		fldz
7:	

ceil$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe ceil$13
13:	

ceil$3:	; call header integral zero 0 stack zero 0
15:	

ceil$4:	; push float x
16:		fld qword [bp + 6]
18:	

ceil$5:	; £temporary811 = -x
19:		fchs
21:	

ceil$6:	; parameter £temporary811, offset 6
22:		fstp qword [bp + 20]
24:	

ceil$7:	; call function noellipse-noellipse floor
25:		mov word [bp + 14], ceil$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp floor
30:	

ceil$8:	; post call
32:	

ceil$9:	; £temporary812 = return_value
34:	

ceil$10:	; £temporary813 = -£temporary812
35:		fchs
37:	

ceil$11:	; return_value = £temporary813
39:	

ceil$12:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

ceil$13:	; push float x
46:		fld qword [bp + 6]
48:	

ceil$14:	; push float 0.999999999999
49:		fld qword [float8$0.999999999999#]
51:	

ceil$15:	; £temporary814 = x + 0.999999999999
52:		fadd
54:	

ceil$16:	; £temporary815 = float_to_int £temporary814 (Double -> Signed_Long_Int)
55:		fistp dword [container4bytes#]
56:		mov eax, [container4bytes#]
58:	

ceil$17:	; £temporary816 = int_to_float £temporary815 (Signed_Long_Int -> Double)
59:		mov [container4bytes#], eax
60:		fild dword [container4bytes#]
62:	

ceil$18:	; return_value = £temporary816
64:	

ceil$19:	; return
65:		mov ax, [bp]
66:		mov di, [bp + 4]
67:		mov bp, [bp + 2]
68:		jmp ax
70:	

ceil$20:	; function end ceil
1:	

round:	; push float x
2:		fld qword [bp + 6]
4:	

round$1:	; push 0
5:		fldz
7:	

round$2:	; if x >= 0 goto 8
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe round$8
13:	

round$3:	; push float x
14:		fld qword [bp + 6]
16:	

round$4:	; push float 0.5
17:		fld qword [float8$0.5#]
19:	

round$5:	; £temporary819 = x - 0.5
20:		fsub
22:	

round$6:	; decrease stack
24:	

round$7:	; goto 11
25:		jmp round$11
27:	

round$8:	; push float x
28:		fld qword [bp + 6]
30:	

round$9:	; push float 0.5
31:		fld qword [float8$0.5#]
33:	

round$10:	; £temporary820 = x + 0.5
34:		fadd
36:	

round$11:	; £temporary825 = float_to_int £temporary824 (Double -> Signed_Long_Int)
37:		fistp dword [container4bytes#]
38:		mov eax, [container4bytes#]
40:	

round$12:	; £temporary826 = int_to_float £temporary825 (Signed_Long_Int -> Double)
41:		mov [container4bytes#], eax
42:		fild dword [container4bytes#]
44:	

round$13:	; return_value = £temporary826
46:	

round$14:	; return
47:		mov ax, [bp]
48:		mov di, [bp + 4]
49:		mov bp, [bp + 2]
50:		jmp ax
52:	

round$15:	; function end round
1:	

fabs:	; push float x
2:		fld qword [bp + 6]
4:	

fabs$1:	; push 0
5:		fldz
7:	

fabs$2:	; if x >= 0 goto 7
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe fabs$7
13:	

fabs$3:	; push float x
14:		fld qword [bp + 6]
16:	

fabs$4:	; £temporary828 = -x
17:		fchs
19:	

fabs$5:	; decrease stack
21:	

fabs$6:	; goto 8
22:		jmp fabs$8
24:	

fabs$7:	; push float x
25:		fld qword [bp + 6]
27:	

fabs$8:	; return_value = £temporary832
29:	

fabs$9:	; return
30:		mov ax, [bp]
31:		mov di, [bp + 4]
32:		mov bp, [bp + 2]
33:		jmp ax
35:	

fabs$10:	; function end fabs
