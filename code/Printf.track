1:	

putc:	; g_outStatus = 0
2:		mov word [g_outStatus], 0
4:	

putc$1:	; £temporary1740 = int_to_int stream (Pointer -> Pointer)
5:		mov a1181, [bp + 8]
8:	

putc$2:	; g_outDevice = £temporary1740
9:		mov [g_outDevice], a1181
11:	

putc$3:	; call header integral zero 0 stack zero 0
13:	

putc$4:	; £temporary1741 = int_to_int i (Signed_Int -> Signed_Char)
14:		mov a1182, [bp + 6]
17:		cmp a1182, 0
18:		jge putc$5
19:		neg a1182
21:		neg a1182
23:	

putc$5:	; parameter £temporary1741, offset 6
24:		mov [bp + 16], a1182
26:	

putc$6:	; call function noellipse-noellipse printChar
27:		mov word [bp + 10], putc$7
28:		mov [bp + 12], bp
29:		add bp, 10
30:		jmp printChar
32:	

putc$7:	; post call
34:	

putc$8:	; return_value = 1
35:		mov a1183, 1
37:	

putc$9:	; return
38:		mov t1184, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp t1184
43:	

putc$10:	; function end putc
1:	

fputc:	; g_outStatus = 0
2:		mov word [g_outStatus], 0
4:	

fputc$1:	; £temporary1744 = int_to_int stream (Pointer -> Pointer)
5:		mov a1185, [bp + 8]
8:	

fputc$2:	; g_outDevice = £temporary1744
9:		mov [g_outDevice], a1185
11:	

fputc$3:	; call header integral zero 0 stack zero 0
13:	

fputc$4:	; £temporary1745 = int_to_int i (Signed_Int -> Signed_Char)
14:		mov a1186, [bp + 6]
17:		cmp a1186, 0
18:		jge fputc$5
19:		neg a1186
21:		neg a1186
23:	

fputc$5:	; parameter £temporary1745, offset 6
24:		mov [bp + 16], a1186
26:	

fputc$6:	; call function noellipse-noellipse printChar
27:		mov word [bp + 10], fputc$7
28:		mov [bp + 12], bp
29:		add bp, 10
30:		jmp printChar
32:	

fputc$7:	; post call
34:	

fputc$8:	; return_value = 1
35:		mov a1187, 1
37:	

fputc$9:	; return
38:		mov t1188, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp t1188
43:	

fputc$10:	; function end fputc
1:	

putchar:	; g_outStatus = 0
2:		mov word [g_outStatus], 0
4:	

putchar$1:	; £temporary1748 = int_to_int stdout (Pointer -> Pointer)
5:		mov a1189, [stdout]
8:	

putchar$2:	; g_outDevice = £temporary1748
9:		mov [g_outDevice], a1189
11:	

putchar$3:	; call header integral zero 0 stack zero 0
13:	

putchar$4:	; £temporary1749 = int_to_int i (Signed_Int -> Signed_Char)
14:		mov a1190, [bp + 6]
17:		cmp a1190, 0
18:		jge putchar$5
19:		neg a1190
21:		neg a1190
23:	

putchar$5:	; parameter £temporary1749, offset 6
24:		mov [bp + 14], a1190
26:	

putchar$6:	; call function noellipse-noellipse printChar
27:		mov word [bp + 8], putchar$7
28:		mov [bp + 10], bp
29:		add bp, 8
30:		jmp printChar
32:	

putchar$7:	; post call
34:	

putchar$8:	; return_value = 1
35:		mov a1191, 1
37:	

putchar$9:	; return
38:		mov t1192, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp t1192
43:	

putchar$10:	; function end putchar
1:	

printChar:	; case g_outStatus == 0 goto 5
2:		mov a1193, [g_outStatus]
3:		cmp a1193, 0
4:		je printChar$5
6:	

printChar$1:	; case g_outStatus == 1 goto 16
7:		cmp a1193, 1
8:		je printChar$16
10:	

printChar$2:	; case g_outStatus == 2 goto 24
11:		cmp a1193, 2
12:		je printChar$24
14:	

printChar$3:	; case end g_outStatus
16:	

printChar$4:	; goto 25
17:		jmp printChar$25
19:	

printChar$5:	; £temporary1752 = int_to_int g_outDevice (Pointer -> Pointer)
20:		mov a1194, [g_outDevice]
23:	

printChar$6:	; stream = £temporary1752
24:		mov [bp + 11], a1194
26:	

printChar$7:	; ah = 64
27:		mov a1195, 64
29:	

printChar$8:	; £temporary1755 -> stream = *stream, offset 2
30:		mov a1196, [bp + 11]
32:	

printChar$9:	; bx = £temporary1755 -> stream
33:		mov t1197, [a1196 + 2]
35:	

printChar$10:	; cx = 1
36:		mov a1198, 1
38:	

printChar$11:	; £temporary1758 = &c
39:		mov t1199, bp
40:		add t1199, 6
42:	

printChar$12:	; dx = £temporary1758
44:	

printChar$13:	; interrupt 33
45:		int 33
47:	

printChar$14:	; ++g_outChars
48:		inc word [g_outChars]
50:	

printChar$15:	; goto 25
51:		jmp printChar$25
53:	

printChar$16:	; £temporary1760 = int_to_int g_outDevice (Pointer -> Pointer)
54:		mov a1200, [g_outDevice]
57:	

printChar$17:	; outString = £temporary1760
58:		mov [bp + 9], a1200
60:	

printChar$18:	; £temporary1761 = g_outChars
61:		mov t1201, [g_outChars]
63:	

printChar$19:	; ++g_outChars
64:		inc word [g_outChars]
66:	

printChar$20:	; £temporary1763 = outString + £temporary1761
67:		mov a1202, [bp + 9]
68:		add a1202, t1201
70:	

printChar$21:	; £temporary1762 -> £temporary1763 = *£temporary1763
72:	

printChar$22:	; £temporary1762 -> £temporary1763 = c
73:		mov a1203, [bp + 6]
74:		mov [a1202], a1203
76:	

printChar$23:	; goto 25
77:		jmp printChar$25
79:	

printChar$24:	; ++g_outChars
80:		inc word [g_outChars]
82:	

printChar$25:	; return
83:		mov t1204, [bp]
84:		mov di, [bp + 4]
85:		mov bp, [bp + 2]
86:		jmp t1204
88:	

printChar$26:	; function end printChar
1:	

printString:	; if s == 0 goto 29
2:		cmp word [bp + 6], 0
3:		je printString$29
5:	

printString$1:	; if precision != 0 goto 14
6:		cmp word [bp + 8], 0
7:		jne printString$14
9:	

printString$2:	; index = 0
10:		mov word [bp + 10], 0
12:	

printString$3:	; £temporary1769 = s + index
13:		mov a1205, [bp + 6]
14:		add a1205, [bp + 10]
16:	

printString$4:	; £temporary1768 -> £temporary1769 = *£temporary1769
18:	

printString$5:	; if £temporary1768 -> £temporary1769 == 0 goto 53
19:		cmp byte [a1205], 0
20:		je printString$53
22:	

printString$6:	; call header integral zero 0 stack zero 0
24:	

printString$7:	; £temporary1773 = s + index
25:		mov a1206, [bp + 6]
26:		add a1206, [bp + 10]
28:	

printString$8:	; £temporary1772 -> £temporary1773 = *£temporary1773
30:	

printString$9:	; parameter £temporary1772 -> £temporary1773, offset 6
31:		mov t1207, [a1206]
32:		mov [bp + 18], t1207
34:	

printString$10:	; call function noellipse-noellipse printChar
35:		mov word [bp + 12], printString$11
36:		mov [bp + 14], bp
37:		add bp, 12
38:		jmp printChar
40:	

printString$11:	; post call
42:	

printString$12:	; ++index
43:		inc word [bp + 10]
45:	

printString$13:	; goto 3
46:		jmp printString$3
48:	

printString$14:	; index = 0
49:		mov word [bp + 10], 0
51:	

printString$15:	; £temporary1775 = precision
52:		mov t1208, [bp + 8]
54:	

printString$16:	; --precision
55:		dec word [bp + 8]
57:	

printString$17:	; if £temporary1775 <= 0 goto 53
58:		cmp t1208, 0
59:		jle printString$53
61:	

printString$18:	; £temporary1778 = s + index
62:		mov a1209, [bp + 6]
63:		add a1209, [bp + 10]
65:	

printString$19:	; £temporary1777 -> £temporary1778 = *£temporary1778
67:	

printString$20:	; if £temporary1777 -> £temporary1778 == 0 goto 53
68:		cmp byte [a1209], 0
69:		je printString$53
71:	

printString$21:	; call header integral zero 0 stack zero 0
73:	

printString$22:	; £temporary1783 = s + index
74:		mov a1210, [bp + 6]
75:		add a1210, [bp + 10]
77:	

printString$23:	; £temporary1782 -> £temporary1783 = *£temporary1783
79:	

printString$24:	; parameter £temporary1782 -> £temporary1783, offset 6
80:		mov t1211, [a1210]
81:		mov [bp + 18], t1211
83:	

printString$25:	; call function noellipse-noellipse printChar
84:		mov word [bp + 12], printString$26
85:		mov [bp + 14], bp
86:		add bp, 12
87:		jmp printChar
89:	

printString$26:	; post call
91:	

printString$27:	; ++index
92:		inc word [bp + 10]
94:	

printString$28:	; goto 15
95:		jmp printString$15
97:	

printString$29:	; call header integral zero 0 stack zero 0
99:	

printString$30:	; parameter 60, offset 6
100:		mov byte [bp + 16], 60
102:	

printString$31:	; call function noellipse-noellipse printChar
103:		mov word [bp + 10], printString$32
104:		mov [bp + 12], bp
105:		add bp, 10
106:		jmp printChar
108:	

printString$32:	; post call
110:	

printString$33:	; call header integral zero 0 stack zero 0
112:	

printString$34:	; parameter 78, offset 6
113:		mov byte [bp + 16], 78
115:	

printString$35:	; call function noellipse-noellipse printChar
116:		mov word [bp + 10], printString$36
117:		mov [bp + 12], bp
118:		add bp, 10
119:		jmp printChar
121:	

printString$36:	; post call
123:	

printString$37:	; call header integral zero 0 stack zero 0
125:	

printString$38:	; parameter 85, offset 6
126:		mov byte [bp + 16], 85
128:	

printString$39:	; call function noellipse-noellipse printChar
129:		mov word [bp + 10], printString$40
130:		mov [bp + 12], bp
131:		add bp, 10
132:		jmp printChar
134:	

printString$40:	; post call
136:	

printString$41:	; call header integral zero 0 stack zero 0
138:	

printString$42:	; parameter 76, offset 6
139:		mov byte [bp + 16], 76
141:	

printString$43:	; call function noellipse-noellipse printChar
142:		mov word [bp + 10], printString$44
143:		mov [bp + 12], bp
144:		add bp, 10
145:		jmp printChar
147:	

printString$44:	; post call
149:	

printString$45:	; call header integral zero 0 stack zero 0
151:	

printString$46:	; parameter 76, offset 6
152:		mov byte [bp + 16], 76
154:	

printString$47:	; call function noellipse-noellipse printChar
155:		mov word [bp + 10], printString$48
156:		mov [bp + 12], bp
157:		add bp, 10
158:		jmp printChar
160:	

printString$48:	; post call
162:	

printString$49:	; call header integral zero 0 stack zero 0
164:	

printString$50:	; parameter 62, offset 6
165:		mov byte [bp + 16], 62
167:	

printString$51:	; call function noellipse-noellipse printChar
168:		mov word [bp + 10], printString$52
169:		mov [bp + 12], bp
170:		add bp, 10
171:		jmp printChar
173:	

printString$52:	; post call
175:	

printString$53:	; return
176:		mov t1212, [bp]
177:		mov di, [bp + 4]
178:		mov bp, [bp + 2]
179:		jmp t1212
181:	

printString$54:	; function end printString
1:	

printLongIntRec:	; if longValue == 0 goto 15
2:		cmp dword [bp + 6], 0
3:		je printLongIntRec$15
5:	

printLongIntRec$1:	; £temporary1800 = longValue % 10
6:		mov a1213, [bp + 6]
8:		xor edx, edx
9:		idiv dword [int4$10#]
15:	

printLongIntRec$2:	; £temporary1801 = int_to_int £temporary1800 (Signed_Long_Int -> Signed_Int)
18:		cmp t1215, 0
19:		jge printLongIntRec$3
20:		neg t1215
22:		neg t1215
24:	

printLongIntRec$3:	; digit = £temporary1801
25:		mov [bp + 10], t1215
27:	

printLongIntRec$4:	; call header integral zero 0 stack zero 0
29:	

printLongIntRec$5:	; £temporary1802 = longValue / 10
30:		mov a1216, [bp + 6]
32:		xor edx, edx
33:		idiv dword [int4$10#]
39:	

printLongIntRec$6:	; parameter £temporary1802, offset 6
40:		mov [bp + 18], t1219
42:	

printLongIntRec$7:	; call function noellipse-noellipse printLongIntRec
43:		mov word [bp + 12], printLongIntRec$8
44:		mov [bp + 14], bp
45:		add bp, 12
46:		jmp printLongIntRec
48:	

printLongIntRec$8:	; post call
50:	

printLongIntRec$9:	; call header integral zero 0 stack zero 0
52:	

printLongIntRec$10:	; £temporary1804 = digit + 48
53:		mov a1220, [bp + 10]
54:		add a1220, 48
56:	

printLongIntRec$11:	; £temporary1805 = int_to_int £temporary1804 (Signed_Int -> Signed_Char)
59:		cmp a1220, 0
60:		jge printLongIntRec$12
61:		neg a1220
63:		neg a1220
65:	

printLongIntRec$12:	; parameter £temporary1805, offset 6
66:		mov [bp + 18], a1220
68:	

printLongIntRec$13:	; call function noellipse-noellipse printChar
69:		mov word [bp + 12], printLongIntRec$14
70:		mov [bp + 14], bp
71:		add bp, 12
72:		jmp printChar
74:	

printLongIntRec$14:	; post call
76:	

printLongIntRec$15:	; return
77:		mov t1221, [bp]
78:		mov di, [bp + 4]
79:		mov bp, [bp + 2]
80:		jmp t1221
82:	

printLongIntRec$16:	; function end printLongIntRec
1:	

printLongInt:	; if longValue >= 0 goto 8
2:		cmp dword [bp + 6], 0
3:		jge printLongInt$8
5:	

printLongInt$1:	; £temporary1810 = -longValue
6:		mov a1222, [bp + 6]
7:		neg a1222
9:	

printLongInt$2:	; longValue = £temporary1810
10:		mov [bp + 6], a1222
12:	

printLongInt$3:	; call header integral zero 0 stack zero 0
14:	

printLongInt$4:	; parameter 45, offset 6
15:		mov byte [bp + 20], 45
17:	

printLongInt$5:	; call function noellipse-noellipse printChar
18:		mov word [bp + 14], printLongInt$6
19:		mov [bp + 16], bp
20:		add bp, 14
21:		jmp printChar
23:	

printLongInt$6:	; post call
25:	

printLongInt$7:	; goto 19
26:		jmp printLongInt$19
28:	

printLongInt$8:	; if space == 0 goto 14
29:		cmp word [bp + 12], 0
30:		je printLongInt$14
32:	

printLongInt$9:	; call header integral zero 0 stack zero 0
34:	

printLongInt$10:	; parameter 32, offset 6
35:		mov byte [bp + 20], 32
37:	

printLongInt$11:	; call function noellipse-noellipse printChar
38:		mov word [bp + 14], printLongInt$12
39:		mov [bp + 16], bp
40:		add bp, 14
41:		jmp printChar
43:	

printLongInt$12:	; post call
45:	

printLongInt$13:	; goto 19
46:		jmp printLongInt$19
48:	

printLongInt$14:	; if plus == 0 goto 19
49:		cmp word [bp + 10], 0
50:		je printLongInt$19
52:	

printLongInt$15:	; call header integral zero 0 stack zero 0
54:	

printLongInt$16:	; parameter 43, offset 6
55:		mov byte [bp + 20], 43
57:	

printLongInt$17:	; call function noellipse-noellipse printChar
58:		mov word [bp + 14], printLongInt$18
59:		mov [bp + 16], bp
60:		add bp, 14
61:		jmp printChar
63:	

printLongInt$18:	; post call
65:	

printLongInt$19:	; if longValue != 0 goto 25
66:		cmp dword [bp + 6], 0
67:		jne printLongInt$25
69:	

printLongInt$20:	; call header integral zero 0 stack zero 0
71:	

printLongInt$21:	; parameter 48, offset 6
72:		mov byte [bp + 20], 48
74:	

printLongInt$22:	; call function noellipse-noellipse printChar
75:		mov word [bp + 14], printLongInt$23
76:		mov [bp + 16], bp
77:		add bp, 14
78:		jmp printChar
80:	

printLongInt$23:	; post call
82:	

printLongInt$24:	; goto 29
83:		jmp printLongInt$29
85:	

printLongInt$25:	; call header integral zero 0 stack zero 0
87:	

printLongInt$26:	; parameter longValue, offset 6
88:		mov a1223, [bp + 6]
89:		mov [bp + 20], a1223
91:	

printLongInt$27:	; call function noellipse-noellipse printLongIntRec
92:		mov word [bp + 14], printLongInt$28
93:		mov [bp + 16], bp
94:		add bp, 14
95:		jmp printLongIntRec
97:	

printLongInt$28:	; post call
99:	

printLongInt$29:	; return
100:		mov t1224, [bp]
101:		mov di, [bp + 4]
102:		mov bp, [bp + 2]
103:		jmp t1224
105:	

printLongInt$30:	; function end printLongInt
1:	

digitToChar:	; if digit >= 10 goto 5
2:		cmp word [bp + 6], 10
3:		jge digitToChar$5
5:	

digitToChar$1:	; £temporary1825 = digit + 48
6:		mov a1225, [bp + 6]
7:		add a1225, 48
9:	

digitToChar$2:	; £temporary1826 = int_to_int £temporary1825 (Signed_Int -> Signed_Char)
12:		cmp a1225, 0
13:		jge digitToChar$3
14:		neg a1225
16:		neg a1225
18:	

digitToChar$3:	; return_value = £temporary1826
20:	

digitToChar$4:	; return
21:		mov t1226, [bp]
22:		mov di, [bp + 4]
23:		mov bp, [bp + 2]
24:		jmp t1226
26:	

digitToChar$5:	; if capital == 0 goto 11
27:		cmp word [bp + 8], 0
28:		je digitToChar$11
30:	

digitToChar$6:	; £temporary1827 = digit - 10
31:		mov a1227, [bp + 6]
32:		sub a1227, 10
34:	

digitToChar$7:	; £temporary1828 = £temporary1827 + 65
35:		add a1227, 65
37:	

digitToChar$8:	; £temporary1829 = int_to_int £temporary1828 (Signed_Int -> Signed_Char)
40:		cmp a1227, 0
41:		jge digitToChar$9
42:		neg a1227
44:		neg a1227
46:	

digitToChar$9:	; return_value = £temporary1829
48:	

digitToChar$10:	; return
49:		mov t1228, [bp]
50:		mov di, [bp + 4]
51:		mov bp, [bp + 2]
52:		jmp t1228
54:	

digitToChar$11:	; £temporary1830 = digit - 10
55:		mov a1229, [bp + 6]
56:		sub a1229, 10
58:	

digitToChar$12:	; £temporary1831 = £temporary1830 + 97
59:		add a1229, 97
61:	

digitToChar$13:	; £temporary1832 = int_to_int £temporary1831 (Signed_Int -> Signed_Char)
64:		cmp a1229, 0
65:		jge digitToChar$14
66:		neg a1229
68:		neg a1229
70:	

digitToChar$14:	; return_value = £temporary1832
72:	

digitToChar$15:	; return
73:		mov t1230, [bp]
74:		mov di, [bp + 4]
75:		mov bp, [bp + 2]
76:		jmp t1230
78:	

digitToChar$16:	; function end digitToChar
1:	

printUnsignedLongRec:	; if unsignedValue <= 0 goto 22
2:		cmp dword [bp + 6], 0
3:		jbe printUnsignedLongRec$22
5:	

printUnsignedLongRec$1:	; £temporary1835 = unsignedValue % base
6:		mov a1231, [bp + 6]
8:		xor edx, edx
9:		div dword [bp + 10]
15:	

printUnsignedLongRec$2:	; £temporary1836 = int_to_int £temporary1835 (Unsigned_Long_Int -> Signed_Int)
18:	

printUnsignedLongRec$3:	; digit = £temporary1836
19:		mov [bp + 16], t1233
21:	

printUnsignedLongRec$4:	; call header integral zero 0 stack zero 0
23:	

printUnsignedLongRec$5:	; £temporary1837 = unsignedValue / base
24:		mov a1234, [bp + 6]
26:		xor edx, edx
27:		div dword [bp + 10]
33:	

printUnsignedLongRec$6:	; parameter £temporary1837, offset 6
34:		mov [bp + 24], t1237
36:	

printUnsignedLongRec$7:	; parameter base, offset 10
37:		mov a1238, [bp + 10]
38:		mov [bp + 28], a1238
40:	

printUnsignedLongRec$8:	; parameter capital, offset 14
41:		mov a1239, [bp + 14]
42:		mov [bp + 32], a1239
44:	

printUnsignedLongRec$9:	; call function noellipse-noellipse printUnsignedLongRec
45:		mov word [bp + 18], printUnsignedLongRec$10
46:		mov [bp + 20], bp
47:		add bp, 18
48:		jmp printUnsignedLongRec
50:	

printUnsignedLongRec$10:	; post call
52:	

printUnsignedLongRec$11:	; call header integral zero 0 stack zero 0
54:	

printUnsignedLongRec$12:	; parameter digit, offset 6
55:		mov a1240, [bp + 16]
56:		mov [bp + 24], a1240
58:	

printUnsignedLongRec$13:	; parameter capital, offset 8
59:		mov a1241, [bp + 14]
60:		mov [bp + 26], a1241
62:	

printUnsignedLongRec$14:	; call function noellipse-noellipse digitToChar
63:		mov word [bp + 18], printUnsignedLongRec$15
64:		mov [bp + 20], bp
65:		add bp, 18
66:		jmp digitToChar
68:	

printUnsignedLongRec$15:	; post call
70:	

printUnsignedLongRec$16:	; £temporary1839 = return_value
75:	

printUnsignedLongRec$17:	; c = £temporary1839
76:		mov [bp + 18], t1243
78:	

printUnsignedLongRec$18:	; call header integral zero 0 stack zero 0
80:	

printUnsignedLongRec$19:	; parameter c, offset 6
81:		mov a1244, [bp + 18]
82:		mov [bp + 25], a1244
84:	

printUnsignedLongRec$20:	; call function noellipse-noellipse printChar
85:		mov word [bp + 19], printUnsignedLongRec$21
86:		mov [bp + 21], bp
87:		add bp, 19
88:		jmp printChar
90:	

printUnsignedLongRec$21:	; post call
92:	

printUnsignedLongRec$22:	; return
93:		mov t1245, [bp]
94:		mov di, [bp + 4]
95:		mov bp, [bp + 2]
96:		jmp t1245
98:	

printUnsignedLongRec$23:	; function end printUnsignedLongRec
1:	

printUnsignedLong:	; if plus == 0 goto 5
2:		cmp word [bp + 10], 0
3:		je printUnsignedLong$5
5:	

printUnsignedLong$1:	; call header integral zero 0 stack zero 0
7:	

printUnsignedLong$2:	; parameter 43, offset 6
8:		mov byte [bp + 28], 43
10:	

printUnsignedLong$3:	; call function noellipse-noellipse printChar
11:		mov word [bp + 22], printUnsignedLong$4
12:		mov [bp + 24], bp
13:		add bp, 22
14:		jmp printChar
16:	

printUnsignedLong$4:	; post call
18:	

printUnsignedLong$5:	; if space == 0 goto 10
19:		cmp word [bp + 12], 0
20:		je printUnsignedLong$10
22:	

printUnsignedLong$6:	; call header integral zero 0 stack zero 0
24:	

printUnsignedLong$7:	; parameter 32, offset 6
25:		mov byte [bp + 28], 32
27:	

printUnsignedLong$8:	; call function noellipse-noellipse printChar
28:		mov word [bp + 22], printUnsignedLong$9
29:		mov [bp + 24], bp
30:		add bp, 22
31:		jmp printChar
33:	

printUnsignedLong$9:	; post call
35:	

printUnsignedLong$10:	; if grid == 0 goto 29
36:		cmp word [bp + 14], 0
37:		je printUnsignedLong$29
39:	

printUnsignedLong$11:	; if base != 8 goto 16
40:		cmp dword [bp + 16], 8
41:		jne printUnsignedLong$16
43:	

printUnsignedLong$12:	; call header integral zero 0 stack zero 0
45:	

printUnsignedLong$13:	; parameter 48, offset 6
46:		mov byte [bp + 28], 48
48:	

printUnsignedLong$14:	; call function noellipse-noellipse printChar
49:		mov word [bp + 22], printUnsignedLong$15
50:		mov [bp + 24], bp
51:		add bp, 22
52:		jmp printChar
54:	

printUnsignedLong$15:	; post call
56:	

printUnsignedLong$16:	; if base != 16 goto 29
57:		cmp dword [bp + 16], 16
58:		jne printUnsignedLong$29
60:	

printUnsignedLong$17:	; call header integral zero 0 stack zero 0
62:	

printUnsignedLong$18:	; parameter 48, offset 6
63:		mov byte [bp + 28], 48
65:	

printUnsignedLong$19:	; call function noellipse-noellipse printChar
66:		mov word [bp + 22], printUnsignedLong$20
67:		mov [bp + 24], bp
68:		add bp, 22
69:		jmp printChar
71:	

printUnsignedLong$20:	; post call
73:	

printUnsignedLong$21:	; call header integral zero 0 stack zero 0
75:	

printUnsignedLong$22:	; if capital == 0 goto 25
76:		cmp word [bp + 20], 0
77:		je printUnsignedLong$25
79:	

printUnsignedLong$23:	; £temporary1859 = 88
80:		mov t1246, 88
82:	

printUnsignedLong$24:	; goto 26
83:		jmp printUnsignedLong$26
85:	

printUnsignedLong$25:	; £temporary1859 = 120
86:		mov t1247, 120
88:	

printUnsignedLong$26:	; parameter £temporary1859, offset 6
89:		mov [bp + 28], t1247
91:	

printUnsignedLong$27:	; call function noellipse-noellipse printChar
92:		mov word [bp + 22], printUnsignedLong$28
93:		mov [bp + 24], bp
94:		add bp, 22
95:		jmp printChar
97:	

printUnsignedLong$28:	; post call
99:	

printUnsignedLong$29:	; if unsignedValue != 0 goto 35
100:		cmp dword [bp + 6], 0
101:		jne printUnsignedLong$35
103:	

printUnsignedLong$30:	; call header integral zero 0 stack zero 0
105:	

printUnsignedLong$31:	; parameter 48, offset 6
106:		mov byte [bp + 28], 48
108:	

printUnsignedLong$32:	; call function noellipse-noellipse printChar
109:		mov word [bp + 22], printUnsignedLong$33
110:		mov [bp + 24], bp
111:		add bp, 22
112:		jmp printChar
114:	

printUnsignedLong$33:	; post call
116:	

printUnsignedLong$34:	; goto 41
117:		jmp printUnsignedLong$41
119:	

printUnsignedLong$35:	; call header integral zero 0 stack zero 0
121:	

printUnsignedLong$36:	; parameter unsignedValue, offset 6
122:		mov a1248, [bp + 6]
123:		mov [bp + 28], a1248
125:	

printUnsignedLong$37:	; parameter base, offset 10
126:		mov a1249, [bp + 16]
127:		mov [bp + 32], a1249
129:	

printUnsignedLong$38:	; parameter capital, offset 14
130:		mov a1250, [bp + 20]
131:		mov [bp + 36], a1250
133:	

printUnsignedLong$39:	; call function noellipse-noellipse printUnsignedLongRec
134:		mov word [bp + 22], printUnsignedLong$40
135:		mov [bp + 24], bp
136:		add bp, 22
137:		jmp printUnsignedLongRec
139:	

printUnsignedLong$40:	; post call
141:	

printUnsignedLong$41:	; return
142:		mov t1251, [bp]
143:		mov di, [bp + 4]
144:		mov bp, [bp + 2]
145:		jmp t1251
147:	

printUnsignedLong$42:	; function end printUnsignedLong
1:	

printLongDoubleFraction:	; push float longDoubleValue
2:		fld qword [bp + 6]
4:	

printLongDoubleFraction$1:	; push float longDoubleValue
5:		fld qword [bp + 6]
7:	

printLongDoubleFraction$2:	; £temporary1874 = float_to_int longDoubleValue (Long_Double -> Signed_Long_Int)
8:		fistp dword [container4bytes#]
9:		mov t1252, [container4bytes#]
11:	

printLongDoubleFraction$3:	; £temporary1875 = int_to_float £temporary1874 (Signed_Long_Int -> Long_Double)
12:		mov [container4bytes#], t1252
13:		fild dword [container4bytes#]
15:	

printLongDoubleFraction$4:	; £temporary1876 = longDoubleValue - £temporary1875
16:		fsub
18:	

printLongDoubleFraction$5:	; pop float longDoubleValue
19:		fstp qword [bp + 6]
21:	

printLongDoubleFraction$6:	; if precision != 0 goto 8
22:		cmp word [bp + 16], 0
23:		jne printLongDoubleFraction$8
25:	

printLongDoubleFraction$7:	; precision = 6
26:		mov word [bp + 16], 6
28:	

printLongDoubleFraction$8:	; if grid != 0 goto 10
29:		cmp word [bp + 14], 0
30:		jne printLongDoubleFraction$10
32:	

printLongDoubleFraction$9:	; if precision <= 0 goto 14
33:		cmp word [bp + 16], 0
34:		jle printLongDoubleFraction$14
36:	

printLongDoubleFraction$10:	; call header integral zero 0 stack zero 0
38:	

printLongDoubleFraction$11:	; parameter 46, offset 6
39:		mov byte [bp + 24], 46
41:	

printLongDoubleFraction$12:	; call function noellipse-noellipse printChar
42:		mov word [bp + 18], printLongDoubleFraction$13
43:		mov [bp + 20], bp
44:		add bp, 18
45:		jmp printChar
47:	

printLongDoubleFraction$13:	; post call
49:	

printLongDoubleFraction$14:	; £temporary1882 = precision
50:		mov t1253, [bp + 16]
52:	

printLongDoubleFraction$15:	; --precision
53:		dec word [bp + 16]
55:	

printLongDoubleFraction$16:	; if £temporary1882 <= 0 goto 35
56:		cmp t1253, 0
57:		jle printLongDoubleFraction$35
59:	

printLongDoubleFraction$17:	; push float 10.0
60:		fld qword [float8$10.0#]
62:	

printLongDoubleFraction$18:	; push float longDoubleValue
63:		fld qword [bp + 6]
65:	

printLongDoubleFraction$19:	; £temporary1884 = 10.0 * longDoubleValue
66:		fmul
68:	

printLongDoubleFraction$20:	; pop float longDoubleValue10
69:		fstp qword [bp + 18]
71:	

printLongDoubleFraction$21:	; push float longDoubleValue10
72:		fld qword [bp + 18]
74:	

printLongDoubleFraction$22:	; £temporary1885 = float_to_int longDoubleValue10 (Long_Double -> Signed_Int)
75:		fistp word [container2bytes#]
76:		mov t1254, [container2bytes#]
78:	

printLongDoubleFraction$23:	; digitValue = £temporary1885
79:		mov [bp + 26], t1254
81:	

printLongDoubleFraction$24:	; call header integral zero 0 stack zero 0
83:	

printLongDoubleFraction$25:	; £temporary1886 = digitValue + 48
84:		mov a1255, [bp + 26]
85:		add a1255, 48
87:	

printLongDoubleFraction$26:	; £temporary1887 = int_to_int £temporary1886 (Signed_Int -> Signed_Char)
90:		cmp a1255, 0
91:		jge printLongDoubleFraction$27
92:		neg a1255
94:		neg a1255
96:	

printLongDoubleFraction$27:	; parameter £temporary1887, offset 6
97:		mov [bp + 34], a1255
99:	

printLongDoubleFraction$28:	; call function noellipse-noellipse printChar
100:		mov word [bp + 28], printLongDoubleFraction$29
101:		mov [bp + 30], bp
102:		add bp, 28
103:		jmp printChar
105:	

printLongDoubleFraction$29:	; post call
107:	

printLongDoubleFraction$30:	; push float longDoubleValue10
108:		fld qword [bp + 18]
110:	

printLongDoubleFraction$31:	; £temporary1889 = int_to_float digitValue (Signed_Int -> Long_Double)
111:		fild word [bp + 26]
113:	

printLongDoubleFraction$32:	; £temporary1890 = longDoubleValue10 - £temporary1889
114:		fsub
116:	

printLongDoubleFraction$33:	; pop float longDoubleValue
117:		fstp qword [bp + 6]
119:	

printLongDoubleFraction$34:	; goto 14
120:		jmp printLongDoubleFraction$14
122:	

printLongDoubleFraction$35:	; return
123:		mov t1256, [bp]
124:		mov di, [bp + 4]
125:		mov bp, [bp + 2]
126:		jmp t1256
128:	

printLongDoubleFraction$36:	; function end printLongDoubleFraction
1:	

printLongDoublePlain:	; push float longDoubleValue
2:		fld qword [bp + 6]
4:	

printLongDoublePlain$1:	; push float 0.0
5:		fldz
7:	

printLongDoublePlain$2:	; if longDoubleValue >= 0.0 goto 12
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe printLongDoublePlain$12
13:	

printLongDoublePlain$3:	; call header integral zero 0 stack zero 0
15:	

printLongDoublePlain$4:	; parameter 45, offset 6
16:		mov byte [bp + 28], 45
18:	

printLongDoublePlain$5:	; call function noellipse-noellipse printChar
19:		mov word [bp + 22], printLongDoublePlain$6
20:		mov [bp + 24], bp
21:		add bp, 22
22:		jmp printChar
24:	

printLongDoublePlain$6:	; post call
26:	

printLongDoublePlain$7:	; push float longDoubleValue
27:		fld qword [bp + 6]
29:	

printLongDoublePlain$8:	; £temporary1895 = -longDoubleValue
30:		fchs
32:	

printLongDoublePlain$9:	; pop float longDoubleValue
33:		fstp qword [bp + 6]
35:	

printLongDoublePlain$10:	; plus = 0
36:		mov word [bp + 14], 0
38:	

printLongDoublePlain$11:	; space = 0
39:		mov word [bp + 16], 0
41:	

printLongDoublePlain$12:	; push float longDoubleValue
42:		fld qword [bp + 6]
44:	

printLongDoublePlain$13:	; £temporary1896 = float_to_int longDoubleValue (Long_Double -> Signed_Long_Int)
45:		fistp dword [container4bytes#]
46:		mov t1257, [container4bytes#]
48:	

printLongDoublePlain$14:	; longValue = £temporary1896
49:		mov [bp + 22], t1257
51:	

printLongDoublePlain$15:	; call header integral zero 0 stack zero 0
53:	

printLongDoublePlain$16:	; parameter longValue, offset 6
54:		mov a1258, [bp + 22]
55:		mov [bp + 32], a1258
57:	

printLongDoublePlain$17:	; parameter plus, offset 10
58:		mov a1259, [bp + 14]
59:		mov [bp + 36], a1259
61:	

printLongDoublePlain$18:	; parameter space, offset 12
62:		mov a1260, [bp + 16]
63:		mov [bp + 38], a1260
65:	

printLongDoublePlain$19:	; call function noellipse-noellipse printLongInt
66:		mov word [bp + 26], printLongDoublePlain$20
67:		mov [bp + 28], bp
68:		add bp, 26
69:		jmp printLongInt
71:	

printLongDoublePlain$20:	; post call
73:	

printLongDoublePlain$21:	; push float longDoubleValue
74:		fld qword [bp + 6]
76:	

printLongDoublePlain$22:	; £temporary1898 = int_to_float longValue (Signed_Long_Int -> Long_Double)
77:		fild dword [bp + 22]
79:	

printLongDoublePlain$23:	; £temporary1899 = longDoubleValue - £temporary1898
80:		fsub
82:	

printLongDoublePlain$24:	; pop float longDoubleValue
83:		fstp qword [bp + 6]
85:	

printLongDoublePlain$25:	; call header integral zero 0 stack zero 0
87:	

printLongDoublePlain$26:	; push float longDoubleValue
88:		fld qword [bp + 6]
90:	

printLongDoublePlain$27:	; parameter longDoubleValue, offset 6
91:		fstp qword [bp + 32]
93:	

printLongDoublePlain$28:	; parameter grid, offset 14
94:		mov a1261, [bp + 18]
95:		mov [bp + 40], a1261
97:	

printLongDoublePlain$29:	; parameter precision, offset 16
98:		mov a1262, [bp + 20]
99:		mov [bp + 42], a1262
101:	

printLongDoublePlain$30:	; call function noellipse-noellipse printLongDoubleFraction
102:		mov word [bp + 26], printLongDoublePlain$31
103:		mov [bp + 28], bp
104:		add bp, 26
105:		jmp printLongDoubleFraction
107:	

printLongDoublePlain$31:	; post call
109:	

printLongDoublePlain$32:	; return
110:		mov t1263, [bp]
111:		mov di, [bp + 4]
112:		mov bp, [bp + 2]
113:		jmp t1263
115:	

printLongDoublePlain$33:	; function end printLongDoublePlain
1:	

printLongDoubleExpo:	; push float value
2:		fld qword [bp + 6]
4:	

printLongDoubleExpo$1:	; push float 0.0
5:		fldz
7:	

printLongDoubleExpo$2:	; if value != 0.0 goto 27
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jne printLongDoubleExpo$27
13:	

printLongDoubleExpo$3:	; call header integral zero 0 stack zero 0
15:	

printLongDoubleExpo$4:	; parameter 48, offset 6
16:		mov byte [bp + 30], 48
18:	

printLongDoubleExpo$5:	; call function noellipse-noellipse printChar
19:		mov word [bp + 24], printLongDoubleExpo$6
20:		mov [bp + 26], bp
21:		add bp, 24
22:		jmp printChar
24:	

printLongDoubleExpo$6:	; post call
26:	

printLongDoubleExpo$7:	; call header integral zero 0 stack zero 0
28:	

printLongDoubleExpo$8:	; push float 0.0
29:		fldz
31:	

printLongDoubleExpo$9:	; parameter 0.0, offset 6
32:		fstp qword [bp + 30]
34:	

printLongDoubleExpo$10:	; parameter precision, offset 14
35:		mov a1264, [bp + 20]
36:		mov [bp + 38], a1264
38:	

printLongDoubleExpo$11:	; parameter grid, offset 16
39:		mov a1265, [bp + 18]
40:		mov [bp + 40], a1265
42:	

printLongDoubleExpo$12:	; call function noellipse-noellipse printLongDoubleFraction
43:		mov word [bp + 24], printLongDoubleExpo$13
44:		mov [bp + 26], bp
45:		add bp, 24
46:		jmp printLongDoubleFraction
48:	

printLongDoubleExpo$13:	; post call
50:	

printLongDoubleExpo$14:	; call header integral zero 0 stack zero 0
52:	

printLongDoubleExpo$15:	; if capital == 0 goto 18
53:		cmp word [bp + 22], 0
54:		je printLongDoubleExpo$18
56:	

printLongDoubleExpo$16:	; £temporary1915 = 69
57:		mov t1266, 69
59:	

printLongDoubleExpo$17:	; goto 19
60:		jmp printLongDoubleExpo$19
62:	

printLongDoubleExpo$18:	; £temporary1915 = 101
63:		mov t1267, 101
65:	

printLongDoubleExpo$19:	; parameter £temporary1915, offset 6
66:		mov [bp + 30], t1267
68:	

printLongDoubleExpo$20:	; call function noellipse-noellipse printChar
69:		mov word [bp + 24], printLongDoubleExpo$21
70:		mov [bp + 26], bp
71:		add bp, 24
72:		jmp printChar
74:	

printLongDoubleExpo$21:	; post call
76:	

printLongDoubleExpo$22:	; call header integral zero 0 stack zero 0
78:	

printLongDoubleExpo$23:	; parameter 48, offset 6
79:		mov byte [bp + 30], 48
81:	

printLongDoubleExpo$24:	; call function noellipse-noellipse printChar
82:		mov word [bp + 24], printLongDoubleExpo$25
83:		mov [bp + 26], bp
84:		add bp, 24
85:		jmp printChar
87:	

printLongDoubleExpo$25:	; post call
89:	

printLongDoubleExpo$26:	; goto 80
90:		jmp printLongDoubleExpo$80
92:	

printLongDoubleExpo$27:	; push float value
93:		fld qword [bp + 6]
95:	

printLongDoubleExpo$28:	; push float 0.0
96:		fldz
98:	

printLongDoubleExpo$29:	; if value >= 0.0 goto 37
99:		fcompp
100:		fstsw ax
101:		sahf
102:		jbe printLongDoubleExpo$37
104:	

printLongDoubleExpo$30:	; call header integral zero 0 stack zero 0
106:	

printLongDoubleExpo$31:	; parameter 45, offset 6
107:		mov byte [bp + 30], 45
109:	

printLongDoubleExpo$32:	; call function noellipse-noellipse printChar
110:		mov word [bp + 24], printLongDoubleExpo$33
111:		mov [bp + 26], bp
112:		add bp, 24
113:		jmp printChar
115:	

printLongDoubleExpo$33:	; post call
117:	

printLongDoubleExpo$34:	; push float value
118:		fld qword [bp + 6]
120:	

printLongDoubleExpo$35:	; £temporary1920 = -value
121:		fchs
123:	

printLongDoubleExpo$36:	; pop float value
124:		fstp qword [bp + 6]
126:	

printLongDoubleExpo$37:	; call header integral zero 0 stack zero 0
128:	

printLongDoubleExpo$38:	; push float value
129:		fld qword [bp + 6]
131:	

printLongDoubleExpo$39:	; parameter value, offset 6
132:		fstp qword [bp + 30]
134:	

printLongDoubleExpo$40:	; call function noellipse-noellipse log10
135:		mov word [bp + 24], printLongDoubleExpo$41
136:		mov [bp + 26], bp
137:		add bp, 24
138:		jmp log10
140:	

printLongDoubleExpo$41:	; post call
142:	

printLongDoubleExpo$42:	; £temporary1921 = return_value
144:	

printLongDoubleExpo$43:	; £temporary1922 = float_to_int £temporary1921 (Double -> Signed_Int)
145:		fistp word [container2bytes#]
146:		mov t1268, [container2bytes#]
148:	

printLongDoubleExpo$44:	; expo = £temporary1922
149:		mov [bp + 24], t1268
151:	

printLongDoubleExpo$45:	; push float value
152:		fld qword [bp + 6]
154:	

printLongDoubleExpo$46:	; call header integral zero 0 stack no zero 1
155:		fstp qword [bp + 26]
157:	

printLongDoubleExpo$47:	; push float 10.0
158:		fld qword [float8$10.0#]
160:	

printLongDoubleExpo$48:	; parameter 10.0, offset 6
161:		fstp qword [bp + 40]
163:	

printLongDoubleExpo$49:	; £temporary1923 = int_to_float expo (Signed_Int -> Double)
164:		fild word [bp + 24]
166:	

printLongDoubleExpo$50:	; parameter £temporary1923, offset 14
167:		fstp qword [bp + 48]
169:	

printLongDoubleExpo$51:	; call function noellipse-noellipse pow
170:		mov word [bp + 34], printLongDoubleExpo$52
171:		mov [bp + 36], bp
172:		add bp, 34
173:		jmp pow
175:	

printLongDoubleExpo$52:	; post call
176:		fstp qword [bp + 34]
177:		fld qword [bp + 26]
178:		fld qword [bp + 34]
180:	

printLongDoubleExpo$53:	; £temporary1924 = return_value
182:	

printLongDoubleExpo$54:	; £temporary1925 = value / £temporary1924
183:		fdiv
185:	

printLongDoubleExpo$55:	; pop float value
186:		fstp qword [bp + 6]
188:	

printLongDoubleExpo$56:	; call header integral zero 0 stack zero 0
190:	

printLongDoubleExpo$57:	; push float value
191:		fld qword [bp + 6]
193:	

printLongDoubleExpo$58:	; parameter value, offset 6
194:		fstp qword [bp + 32]
196:	

printLongDoubleExpo$59:	; parameter plus, offset 14
197:		mov a1269, [bp + 14]
198:		mov [bp + 40], a1269
200:	

printLongDoubleExpo$60:	; parameter space, offset 16
201:		mov a1270, [bp + 16]
202:		mov [bp + 42], a1270
204:	

printLongDoubleExpo$61:	; parameter grid, offset 18
205:		mov a1271, [bp + 18]
206:		mov [bp + 44], a1271
208:	

printLongDoubleExpo$62:	; parameter precision, offset 20
209:		mov a1272, [bp + 20]
210:		mov [bp + 46], a1272
212:	

printLongDoubleExpo$63:	; call function noellipse-noellipse printLongDoublePlain
213:		mov word [bp + 26], printLongDoubleExpo$64
214:		mov [bp + 28], bp
215:		add bp, 26
216:		jmp printLongDoublePlain
218:	

printLongDoubleExpo$64:	; post call
220:	

printLongDoubleExpo$65:	; call header integral zero 0 stack zero 0
222:	

printLongDoubleExpo$66:	; if capital == 0 goto 69
223:		cmp word [bp + 22], 0
224:		je printLongDoubleExpo$69
226:	

printLongDoubleExpo$67:	; £temporary1931 = 69
227:		mov t1273, 69
229:	

printLongDoubleExpo$68:	; goto 70
230:		jmp printLongDoubleExpo$70
232:	

printLongDoubleExpo$69:	; £temporary1931 = 101
233:		mov t1274, 101
235:	

printLongDoubleExpo$70:	; parameter £temporary1931, offset 6
236:		mov [bp + 32], t1274
238:	

printLongDoubleExpo$71:	; call function noellipse-noellipse printChar
239:		mov word [bp + 26], printLongDoubleExpo$72
240:		mov [bp + 28], bp
241:		add bp, 26
242:		jmp printChar
244:	

printLongDoubleExpo$72:	; post call
246:	

printLongDoubleExpo$73:	; call header integral zero 0 stack zero 0
248:	

printLongDoubleExpo$74:	; £temporary1933 = int_to_int expo (Signed_Int -> Signed_Long_Int)
249:		mov a1275, [bp + 24]
251:		and a1275, 65535
253:		cmp a1275, 0
254:		jge printLongDoubleExpo$75
255:		neg a1275
257:		neg a1275
259:	

printLongDoubleExpo$75:	; parameter £temporary1933, offset 6
260:		mov [bp + 32], a1275
262:	

printLongDoubleExpo$76:	; parameter 1, offset 10
263:		mov word [bp + 36], 1
265:	

printLongDoubleExpo$77:	; parameter 0, offset 12
266:		mov word [bp + 38], 0
268:	

printLongDoubleExpo$78:	; call function noellipse-noellipse printLongInt
269:		mov word [bp + 26], printLongDoubleExpo$79
270:		mov [bp + 28], bp
271:		add bp, 26
272:		jmp printLongInt
274:	

printLongDoubleExpo$79:	; post call
276:	

printLongDoubleExpo$80:	; return
277:		mov t1276, [bp]
278:		mov di, [bp + 4]
279:		mov bp, [bp + 2]
280:		jmp t1276
282:	

printLongDoubleExpo$81:	; function end printLongDoubleExpo
1:	

checkWidthAndPrecision:	; if widthPtr == 0 goto 9
2:		cmp word [bp + 8], 0
3:		je checkWidthAndPrecision$9
5:	

checkWidthAndPrecision$1:	; £temporary1955 -> widthPtr = *widthPtr
6:		mov a1277, [bp + 8]
8:	

checkWidthAndPrecision$2:	; if £temporary1955 -> widthPtr != -1 goto 9
9:		cmp word [a1277], -1
10:		jne checkWidthAndPrecision$9
12:	

checkWidthAndPrecision$3:	; £temporary1958 -> widthPtr = *widthPtr
13:		mov a1278, [bp + 8]
15:	

checkWidthAndPrecision$4:	; arg_list = arg_list + 2
16:		add word [bp + 6], 2
18:	

checkWidthAndPrecision$5:	; £temporary1960 = arg_list - 2
19:		mov a1279, [bp + 6]
20:		sub a1279, 2
22:	

checkWidthAndPrecision$6:	; £temporary1961 = int_to_int £temporary1960 (Signed_Int -> Pointer)
25:	

checkWidthAndPrecision$7:	; £temporary1962 -> £temporary1961 = *£temporary1961
27:	

checkWidthAndPrecision$8:	; £temporary1958 -> widthPtr = £temporary1962 -> £temporary1961
28:		mov t1280, [a1279]
29:		mov [a1278], t1280
31:	

checkWidthAndPrecision$9:	; if precisionPtr == 0 goto 18
32:		cmp word [bp + 10], 0
33:		je checkWidthAndPrecision$18
35:	

checkWidthAndPrecision$10:	; £temporary1964 -> precisionPtr = *precisionPtr
36:		mov a1281, [bp + 10]
38:	

checkWidthAndPrecision$11:	; if £temporary1964 -> precisionPtr != -1 goto 18
39:		cmp word [a1281], -1
40:		jne checkWidthAndPrecision$18
42:	

checkWidthAndPrecision$12:	; £temporary1967 -> precisionPtr = *precisionPtr
43:		mov a1282, [bp + 10]
45:	

checkWidthAndPrecision$13:	; arg_list = arg_list + 2
46:		add word [bp + 6], 2
48:	

checkWidthAndPrecision$14:	; £temporary1969 = arg_list - 2
49:		mov a1283, [bp + 6]
50:		sub a1283, 2
52:	

checkWidthAndPrecision$15:	; £temporary1970 = int_to_int £temporary1969 (Signed_Int -> Pointer)
55:	

checkWidthAndPrecision$16:	; £temporary1971 -> £temporary1970 = *£temporary1970
57:	

checkWidthAndPrecision$17:	; £temporary1967 -> precisionPtr = £temporary1971 -> £temporary1970
58:		mov t1284, [a1283]
59:		mov [a1282], t1284
61:	

checkWidthAndPrecision$18:	; return_value = arg_list
62:		mov a1285, [bp + 6]
64:	

checkWidthAndPrecision$19:	; return
65:		mov t1286, [bp]
66:		mov di, [bp + 4]
67:		mov bp, [bp + 2]
68:		jmp t1286
70:	

checkWidthAndPrecision$20:	; function end checkWidthAndPrecision
1:	

testY:	; empty
3:	

testY$1:	; return
4:		mov t1287, [bp]
5:		mov di, [bp + 4]
6:		mov bp, [bp + 2]
7:		jmp t1287
9:	

testY$2:	; function end testY
1:	

testX:	; if j != 1 goto 3
2:		cmp word [bp + 8], 1
3:		jne testX$3
5:	

testX$1:	; i = 1
6:		mov word [bp + 6], 1
8:	

testX$2:	; goto 4
9:		jmp testX$4
11:	

testX$3:	; i = 2
12:		mov word [bp + 6], 2
14:	

testX$4:	; j = i
15:		mov a1288, [bp + 6]
16:		mov [bp + 8], a1288
18:	

testX$5:	; return
19:		mov t1289, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp t1289
24:	

testX$6:	; function end testX
1:	

printArgument:	; £temporary1973 -> format = *format
2:		mov a1290, [bp + 6]
4:	

printArgument$1:	; c = £temporary1973 -> format
5:		mov t1291, [a1290]
6:		mov [bp + 30], t1291
8:	

printArgument$2:	; case c == 100 goto 21
9:		mov a1292, [bp + 30]
10:		cmp a1292, 100
11:		je printArgument$21
13:	

printArgument$3:	; case c == 105 goto 21
14:		cmp a1292, 105
15:		je printArgument$21
17:	

printArgument$4:	; case c == 99 goto 73
18:		cmp a1292, 99
19:		je printArgument$73
21:	

printArgument$5:	; case c == 115 goto 93
22:		cmp a1292, 115
23:		je printArgument$93
25:	

printArgument$6:	; case c == 88 goto 113
26:		cmp a1292, 88
27:		je printArgument$113
29:	

printArgument$7:	; case c == 120 goto 113
30:		cmp a1292, 120
31:		je printArgument$113
33:	

printArgument$8:	; case c == 98 goto 113
34:		cmp a1292, 98
35:		je printArgument$113
37:	

printArgument$9:	; case c == 111 goto 113
38:		cmp a1292, 111
39:		je printArgument$113
41:	

printArgument$10:	; case c == 117 goto 113
42:		cmp a1292, 117
43:		je printArgument$113
45:	

printArgument$11:	; case c == 71 goto 173
46:		cmp a1292, 71
47:		je printArgument$173
49:	

printArgument$12:	; case c == 103 goto 173
50:		cmp a1292, 103
51:		je printArgument$173
53:	

printArgument$13:	; case c == 69 goto 173
54:		cmp a1292, 69
55:		je printArgument$173
57:	

printArgument$14:	; case c == 101 goto 173
58:		cmp a1292, 101
59:		je printArgument$173
61:	

printArgument$15:	; case c == 102 goto 173
62:		cmp a1292, 102
63:		je printArgument$173
65:	

printArgument$16:	; case c == 112 goto 299
66:		cmp a1292, 112
67:		je printArgument$299
69:	

printArgument$17:	; case c == 110 goto 324
70:		cmp a1292, 110
71:		je printArgument$324
73:	

printArgument$18:	; case c == 37 goto 346
74:		cmp a1292, 37
75:		je printArgument$346
77:	

printArgument$19:	; case end c
79:	

printArgument$20:	; goto 359
80:		jmp printArgument$359
82:	

printArgument$21:	; if shortInt == 0 goto 30
83:		cmp word [bp + 20], 0
84:		je printArgument$30
86:	

printArgument$22:	; arg_list = arg_list + 2
87:		add word [bp + 8], 2
89:	

printArgument$23:	; £temporary1975 = arg_list - 2
90:		mov a1293, [bp + 8]
91:		sub a1293, 2
93:	

printArgument$24:	; £temporary1976 = int_to_int £temporary1975 (Signed_Int -> Pointer)
96:	

printArgument$25:	; £temporary1977 -> £temporary1976 = *£temporary1976
98:	

printArgument$26:	; £temporary1978 = int_to_int £temporary1977 -> £temporary1976 (Signed_Int -> Signed_Short_Int)
99:		mov t1294, [a1293]
102:		cmp t1294, 0
103:		jge printArgument$27
104:		neg t1294
106:		neg t1294
108:	

printArgument$27:	; £temporary1979 = int_to_int £temporary1978 (Signed_Short_Int -> Signed_Long_Int)
110:		and t1294, 255
112:		cmp t1294, 0
113:		jge printArgument$28
114:		neg t1294
116:		neg t1294
118:	

printArgument$28:	; longValue = £temporary1979
119:		mov [bp + 44], t1294
121:	

printArgument$29:	; goto 43
122:		jmp printArgument$43
124:	

printArgument$30:	; if longInt == 0 goto 37
125:		cmp word [bp + 22], 0
126:		je printArgument$37
128:	

printArgument$31:	; arg_list = arg_list + 4
129:		add word [bp + 8], 4
131:	

printArgument$32:	; £temporary1981 = arg_list - 4
132:		mov a1295, [bp + 8]
133:		sub a1295, 4
135:	

printArgument$33:	; £temporary1982 = int_to_int £temporary1981 (Signed_Int -> Pointer)
138:	

printArgument$34:	; £temporary1983 -> £temporary1982 = *£temporary1982
140:	

printArgument$35:	; longValue = £temporary1983 -> £temporary1982
141:		mov t1296, [a1295]
142:		mov [bp + 44], t1296
144:	

printArgument$36:	; goto 43
145:		jmp printArgument$43
147:	

printArgument$37:	; arg_list = arg_list + 2
148:		add word [bp + 8], 2
150:	

printArgument$38:	; £temporary1985 = arg_list - 2
151:		mov a1297, [bp + 8]
152:		sub a1297, 2
154:	

printArgument$39:	; £temporary1986 = int_to_int £temporary1985 (Signed_Int -> Pointer)
157:	

printArgument$40:	; £temporary1987 -> £temporary1986 = *£temporary1986
159:	

printArgument$41:	; £temporary1988 = int_to_int £temporary1987 -> £temporary1986 (Signed_Int -> Signed_Long_Int)
160:		mov t1298, [a1297]
162:		and t1298, 65535
164:		cmp t1298, 0
165:		jge printArgument$42
166:		neg t1298
168:		neg t1298
170:	

printArgument$42:	; longValue = £temporary1988
171:		mov [bp + 44], t1298
173:	

printArgument$43:	; if negativePtr == 0 goto 50
174:		cmp word [bp + 28], 0
175:		je printArgument$50
177:	

printArgument$44:	; £temporary1992 -> negativePtr = *negativePtr
178:		mov a1299, [bp + 28]
180:	

printArgument$45:	; if longValue >= 0 goto 48
181:		cmp dword [bp + 44], 0
182:		jge printArgument$48
184:	

printArgument$46:	; £temporary1994 = 1
185:		mov t1300, 1
187:	

printArgument$47:	; goto 49
188:		jmp printArgument$49
190:	

printArgument$48:	; £temporary1994 = 0
191:		mov t1301, 0
193:	

printArgument$49:	; £temporary1992 -> negativePtr = £temporary1994
194:		mov [a1299], t1301
196:	

printArgument$50:	; if sign != 0 goto 57
197:		cmp word [bp + 26], 0
198:		jne printArgument$57
200:	

printArgument$51:	; call header integral zero 0 stack zero 0
202:	

printArgument$52:	; parameter longValue, offset 6
203:		mov a1302, [bp + 44]
204:		mov [bp + 54], a1302
206:	

printArgument$53:	; call function noellipse-noellipse labs
207:		mov word [bp + 48], printArgument$54
208:		mov [bp + 50], bp
209:		add bp, 48
210:		jmp labs
212:	

printArgument$54:	; post call
214:	

printArgument$55:	; £temporary1997 = return_value
219:	

printArgument$56:	; longValue = £temporary1997
220:		mov [bp + 44], t1304
222:	

printArgument$57:	; call header integral zero 0 stack zero 0
224:	

printArgument$58:	; parameter arg_list, offset 6
225:		mov a1305, [bp + 8]
226:		mov [bp + 54], a1305
228:	

printArgument$59:	; parameter widthPtr, offset 8
229:		mov a1306, [bp + 16]
230:		mov [bp + 56], a1306
232:	

printArgument$60:	; £temporary1998 = &precision
233:		mov t1307, bp
234:		add t1307, 18
236:	

printArgument$61:	; parameter £temporary1998, offset 10
237:		mov [bp + 58], t1307
239:	

printArgument$62:	; call function noellipse-noellipse checkWidthAndPrecision
240:		mov word [bp + 48], printArgument$63
241:		mov [bp + 50], bp
242:		add bp, 48
243:		jmp checkWidthAndPrecision
245:	

printArgument$63:	; post call
247:	

printArgument$64:	; £temporary1999 = return_value
252:	

printArgument$65:	; arg_list = £temporary1999
253:		mov [bp + 8], t1309
255:	

printArgument$66:	; call header integral zero 0 stack zero 0
257:	

printArgument$67:	; parameter longValue, offset 6
258:		mov a1310, [bp + 44]
259:		mov [bp + 54], a1310
261:	

printArgument$68:	; parameter plus, offset 10
262:		mov a1311, [bp + 10]
263:		mov [bp + 58], a1311
265:	

printArgument$69:	; parameter space, offset 12
266:		mov a1312, [bp + 12]
267:		mov [bp + 60], a1312
269:	

printArgument$70:	; call function noellipse-noellipse printLongInt
270:		mov word [bp + 48], printArgument$71
271:		mov [bp + 50], bp
272:		add bp, 48
273:		jmp printLongInt
275:	

printArgument$71:	; post call
277:	

printArgument$72:	; goto 359
278:		jmp printArgument$359
280:	

printArgument$73:	; arg_list = arg_list + 2
281:		add word [bp + 8], 2
283:	

printArgument$74:	; £temporary2002 = arg_list - 2
284:		mov a1313, [bp + 8]
285:		sub a1313, 2
287:	

printArgument$75:	; £temporary2003 = int_to_int £temporary2002 (Signed_Int -> Pointer)
290:	

printArgument$76:	; £temporary2004 -> £temporary2003 = *£temporary2003
292:	

printArgument$77:	; £temporary2005 = int_to_int £temporary2004 -> £temporary2003 (Signed_Int -> Signed_Char)
293:		mov t1314, [a1313]
296:		cmp t1314, 0
297:		jge printArgument$78
298:		neg t1314
300:		neg t1314
302:	

printArgument$78:	; charValue = £temporary2005
303:		mov [bp + 31], t1314
305:	

printArgument$79:	; call header integral zero 0 stack zero 0
307:	

printArgument$80:	; parameter arg_list, offset 6
308:		mov a1315, [bp + 8]
309:		mov [bp + 50], a1315
311:	

printArgument$81:	; parameter widthPtr, offset 8
312:		mov a1316, [bp + 16]
313:		mov [bp + 52], a1316
315:	

printArgument$82:	; £temporary2006 = &precision
316:		mov t1317, bp
317:		add t1317, 18
319:	

printArgument$83:	; parameter £temporary2006, offset 10
320:		mov [bp + 54], t1317
322:	

printArgument$84:	; call function noellipse-noellipse checkWidthAndPrecision
323:		mov word [bp + 44], printArgument$85
324:		mov [bp + 46], bp
325:		add bp, 44
326:		jmp checkWidthAndPrecision
328:	

printArgument$85:	; post call
330:	

printArgument$86:	; £temporary2007 = return_value
335:	

printArgument$87:	; arg_list = £temporary2007
336:		mov [bp + 8], t1319
338:	

printArgument$88:	; call header integral zero 0 stack zero 0
340:	

printArgument$89:	; parameter charValue, offset 6
341:		mov a1320, [bp + 31]
342:		mov [bp + 50], a1320
344:	

printArgument$90:	; call function noellipse-noellipse printChar
345:		mov word [bp + 44], printArgument$91
346:		mov [bp + 46], bp
347:		add bp, 44
348:		jmp printChar
350:	

printArgument$91:	; post call
352:	

printArgument$92:	; goto 359
353:		jmp printArgument$359
355:	

printArgument$93:	; arg_list = arg_list + 2
356:		add word [bp + 8], 2
358:	

printArgument$94:	; £temporary2010 = arg_list - 2
359:		mov a1321, [bp + 8]
360:		sub a1321, 2
362:	

printArgument$95:	; £temporary2011 = int_to_int £temporary2010 (Signed_Int -> Pointer)
365:	

printArgument$96:	; £temporary2012 -> £temporary2011 = *£temporary2011
367:	

printArgument$97:	; stringValue = £temporary2012 -> £temporary2011
368:		mov t1322, [a1321]
369:		mov [bp + 44], t1322
371:	

printArgument$98:	; call header integral zero 0 stack zero 0
373:	

printArgument$99:	; parameter arg_list, offset 6
374:		mov a1323, [bp + 8]
375:		mov [bp + 52], a1323
377:	

printArgument$100:	; parameter widthPtr, offset 8
378:		mov a1324, [bp + 16]
379:		mov [bp + 54], a1324
381:	

printArgument$101:	; £temporary2013 = &precision
382:		mov t1325, bp
383:		add t1325, 18
385:	

printArgument$102:	; parameter £temporary2013, offset 10
386:		mov [bp + 56], t1325
388:	

printArgument$103:	; call function noellipse-noellipse checkWidthAndPrecision
389:		mov word [bp + 46], printArgument$104
390:		mov [bp + 48], bp
391:		add bp, 46
392:		jmp checkWidthAndPrecision
394:	

printArgument$104:	; post call
396:	

printArgument$105:	; £temporary2014 = return_value
401:	

printArgument$106:	; arg_list = £temporary2014
402:		mov [bp + 8], t1327
404:	

printArgument$107:	; call header integral zero 0 stack zero 0
406:	

printArgument$108:	; parameter stringValue, offset 6
407:		mov a1328, [bp + 44]
408:		mov [bp + 52], a1328
410:	

printArgument$109:	; parameter precision, offset 8
411:		mov a1329, [bp + 18]
412:		mov [bp + 54], a1329
414:	

printArgument$110:	; call function noellipse-noellipse printString
415:		mov word [bp + 46], printArgument$111
416:		mov [bp + 48], bp
417:		add bp, 46
418:		jmp printString
420:	

printArgument$111:	; post call
422:	

printArgument$112:	; goto 359
423:		jmp printArgument$359
425:	

printArgument$113:	; if c != 117 goto 116
426:		cmp byte [bp + 30], 117
427:		jne printArgument$116
429:	

printArgument$114:	; £temporary2030 = 10
430:		mov t1330, 10
432:	

printArgument$115:	; goto 125
433:		jmp printArgument$125
435:	

printArgument$116:	; if c != 111 goto 119
436:		cmp byte [bp + 30], 111
437:		jne printArgument$119
439:	

printArgument$117:	; £temporary2026 = 8
440:		mov t1331, 8
442:	

printArgument$118:	; goto 124
443:		jmp printArgument$124
445:	

printArgument$119:	; if c != 98 goto 122
446:		cmp byte [bp + 30], 98
447:		jne printArgument$122
449:	

printArgument$120:	; £temporary2022 = 2
450:		mov t1332, 2
452:	

printArgument$121:	; goto 123
453:		jmp printArgument$123
455:	

printArgument$122:	; £temporary2022 = 16
456:		mov t1333, 16
458:	

printArgument$123:	; £temporary2026 = £temporary2022
460:	

printArgument$124:	; £temporary2030 = £temporary2026
462:	

printArgument$125:	; base = £temporary2030
463:		mov [bp + 44], t1333
465:	

printArgument$126:	; if shortInt == 0 goto 135
466:		cmp word [bp + 20], 0
467:		je printArgument$135
469:	

printArgument$127:	; arg_list = arg_list + 2
470:		add word [bp + 8], 2
472:	

printArgument$128:	; £temporary2032 = arg_list - 2
473:		mov a1336, [bp + 8]
474:		sub a1336, 2
476:	

printArgument$129:	; £temporary2033 = int_to_int £temporary2032 (Signed_Int -> Pointer)
479:	

printArgument$130:	; £temporary2034 -> £temporary2033 = *£temporary2033
481:	

printArgument$131:	; £temporary2035 = int_to_int £temporary2034 -> £temporary2033 (Unsigned_Int -> Unsigned_Short_Int)
482:		mov t1337, [a1336]
485:	

printArgument$132:	; £temporary2036 = int_to_int £temporary2035 (Unsigned_Short_Int -> Unsigned_Long_Int)
487:		and t1337, 255
489:	

printArgument$133:	; value = £temporary2036
490:		mov [bp + 48], t1337
492:	

printArgument$134:	; goto 148
493:		jmp printArgument$148
495:	

printArgument$135:	; if longInt == 0 goto 142
496:		cmp word [bp + 22], 0
497:		je printArgument$142
499:	

printArgument$136:	; arg_list = arg_list + 4
500:		add word [bp + 8], 4
502:	

printArgument$137:	; £temporary2038 = arg_list - 4
503:		mov a1338, [bp + 8]
504:		sub a1338, 4
506:	

printArgument$138:	; £temporary2039 = int_to_int £temporary2038 (Signed_Int -> Pointer)
509:	

printArgument$139:	; £temporary2040 -> £temporary2039 = *£temporary2039
511:	

printArgument$140:	; value = £temporary2040 -> £temporary2039
512:		mov t1339, [a1338]
513:		mov [bp + 48], t1339
515:	

printArgument$141:	; goto 148
516:		jmp printArgument$148
518:	

printArgument$142:	; arg_list = arg_list + 2
519:		add word [bp + 8], 2
521:	

printArgument$143:	; £temporary2042 = arg_list - 2
522:		mov a1340, [bp + 8]
523:		sub a1340, 2
525:	

printArgument$144:	; £temporary2043 = int_to_int £temporary2042 (Signed_Int -> Pointer)
528:	

printArgument$145:	; £temporary2044 -> £temporary2043 = *£temporary2043
530:	

printArgument$146:	; £temporary2045 = int_to_int £temporary2044 -> £temporary2043 (Unsigned_Int -> Unsigned_Long_Int)
531:		mov t1341, [a1340]
533:		and t1341, 65535
535:	

printArgument$147:	; value = £temporary2045
536:		mov [bp + 48], t1341
538:	

printArgument$148:	; call header integral zero 0 stack zero 0
540:	

printArgument$149:	; parameter arg_list, offset 6
541:		mov a1342, [bp + 8]
542:		mov [bp + 58], a1342
544:	

printArgument$150:	; parameter widthPtr, offset 8
545:		mov a1343, [bp + 16]
546:		mov [bp + 60], a1343
548:	

printArgument$151:	; £temporary2048 = &precision
549:		mov t1344, bp
550:		add t1344, 18
552:	

printArgument$152:	; parameter £temporary2048, offset 10
553:		mov [bp + 62], t1344
555:	

printArgument$153:	; call function noellipse-noellipse checkWidthAndPrecision
556:		mov word [bp + 52], printArgument$154
557:		mov [bp + 54], bp
558:		add bp, 52
559:		jmp checkWidthAndPrecision
561:	

printArgument$154:	; post call
563:	

printArgument$155:	; £temporary2049 = return_value
568:	

printArgument$156:	; arg_list = £temporary2049
569:		mov [bp + 8], t1346
571:	

printArgument$157:	; call header integral zero 0 stack zero 0
573:	

printArgument$158:	; parameter value, offset 6
574:		mov a1347, [bp + 48]
575:		mov [bp + 58], a1347
577:	

printArgument$159:	; parameter plus, offset 10
578:		mov a1348, [bp + 10]
579:		mov [bp + 62], a1348
581:	

printArgument$160:	; parameter space, offset 12
582:		mov a1349, [bp + 12]
583:		mov [bp + 64], a1349
585:	

printArgument$161:	; parameter grid, offset 14
586:		mov a1350, [bp + 14]
587:		mov [bp + 66], a1350
589:	

printArgument$162:	; parameter base, offset 16
590:		mov a1351, [bp + 44]
591:		mov [bp + 68], a1351
593:	

printArgument$163:	; call header integral zero 0 stack zero 0
595:	

printArgument$164:	; £temporary2050 = int_to_int c (Signed_Char -> Signed_Int)
596:		mov a1352, [bp + 30]
598:		and a1352, 255
600:		cmp a1352, 0
601:		jge printArgument$165
602:		neg a1352
604:		neg a1352
606:	

printArgument$165:	; parameter £temporary2050, offset 26
607:		mov [bp + 78], a1352
609:	

printArgument$166:	; call function noellipse-noellipse isupper
610:		mov word [bp + 72], printArgument$167
611:		mov [bp + 74], bp
612:		add bp, 72
613:		jmp isupper
615:	

printArgument$167:	; post call
617:	

printArgument$168:	; £temporary2051 = return_value
622:	

printArgument$169:	; parameter £temporary2051, offset 20
623:		mov [bp + 72], t1354
625:	

printArgument$170:	; call function noellipse-noellipse printUnsignedLong
626:		mov word [bp + 52], printArgument$171
627:		mov [bp + 54], bp
628:		add bp, 52
629:		jmp printUnsignedLong
631:	

printArgument$171:	; post call
633:	

printArgument$172:	; goto 359
634:		jmp printArgument$359
636:	

printArgument$173:	; if longDouble == 0 goto 190
637:		cmp word [bp + 24], 0
638:		je printArgument$190
640:	

printArgument$174:	; arg_list = arg_list + 8
641:		add word [bp + 8], 8
643:	

printArgument$175:	; £temporary2054 = arg_list - 8
644:		mov a1355, [bp + 8]
645:		sub a1355, 8
647:	

printArgument$176:	; £temporary2055 = int_to_int £temporary2054 (Signed_Int -> Pointer)
650:	

printArgument$177:	; £temporary2056 -> £temporary2055 = *£temporary2055
652:	

printArgument$178:	; push float £temporary2056 -> £temporary2055
653:		fld qword [a1355]
655:	

printArgument$179:	; pop float longDoubleValue
656:		fstp qword [bp + 34]
658:	

printArgument$180:	; call header integral zero 0 stack zero 0
660:	

printArgument$181:	; push float longDoubleValue
661:		fld qword [bp + 34]
663:	

printArgument$182:	; parameter longDoubleValue, offset 6
664:		fstp qword [bp + 50]
666:	

printArgument$183:	; parameter 0, offset 14
667:		mov word [bp + 58], 0
669:	

printArgument$184:	; parameter 0, offset 16
670:		mov word [bp + 60], 0
672:	

printArgument$185:	; parameter 0, offset 18
673:		mov word [bp + 62], 0
675:	

printArgument$186:	; parameter 3, offset 20
676:		mov word [bp + 64], 3
678:	

printArgument$187:	; call function noellipse-noellipse printLongDoublePlain
679:		mov word [bp + 44], printArgument$188
680:		mov [bp + 46], bp
681:		add bp, 44
682:		jmp printLongDoublePlain
684:	

printArgument$188:	; post call
686:	

printArgument$189:	; goto 196
687:		jmp printArgument$196
689:	

printArgument$190:	; arg_list = arg_list + 8
690:		add word [bp + 8], 8
692:	

printArgument$191:	; £temporary2059 = arg_list - 8
693:		mov a1356, [bp + 8]
694:		sub a1356, 8
696:	

printArgument$192:	; £temporary2060 = int_to_int £temporary2059 (Signed_Int -> Pointer)
699:	

printArgument$193:	; £temporary2061 -> £temporary2060 = *£temporary2060
701:	

printArgument$194:	; push float £temporary2061 -> £temporary2060
702:		fld qword [a1356]
704:	

printArgument$195:	; pop float longDoubleValue
705:		fstp qword [bp + 34]
707:	

printArgument$196:	; if negativePtr == 0 goto 205
708:		cmp word [bp + 28], 0
709:		je printArgument$205
711:	

printArgument$197:	; £temporary2065 -> negativePtr = *negativePtr
712:		mov a1357, [bp + 28]
714:	

printArgument$198:	; push float longDoubleValue
715:		fld qword [bp + 34]
717:	

printArgument$199:	; push 0
718:		fldz
720:	

printArgument$200:	; if longDoubleValue >= 0 goto 203
721:		fcompp
722:		fstsw ax
723:		sahf
724:		jbe printArgument$203
726:	

printArgument$201:	; £temporary2067 = 1
727:		mov t1358, 1
729:	

printArgument$202:	; goto 204
730:		jmp printArgument$204
732:	

printArgument$203:	; £temporary2067 = 0
733:		mov t1359, 0
735:	

printArgument$204:	; £temporary2065 -> negativePtr = £temporary2067
736:		mov [a1357], t1359
738:	

printArgument$205:	; if sign != 0 goto 213
739:		cmp word [bp + 26], 0
740:		jne printArgument$213
742:	

printArgument$206:	; call header integral zero 0 stack zero 0
744:	

printArgument$207:	; push float longDoubleValue
745:		fld qword [bp + 34]
747:	

printArgument$208:	; parameter longDoubleValue, offset 6
748:		fstp qword [bp + 50]
750:	

printArgument$209:	; call function noellipse-noellipse fabs
751:		mov word [bp + 44], printArgument$210
752:		mov [bp + 46], bp
753:		add bp, 44
754:		jmp fabs
756:	

printArgument$210:	; post call
758:	

printArgument$211:	; £temporary2070 = return_value
760:	

printArgument$212:	; pop float longDoubleValue
761:		fstp qword [bp + 34]
763:	

printArgument$213:	; call header integral zero 0 stack zero 0
765:	

printArgument$214:	; parameter arg_list, offset 6
766:		mov a1360, [bp + 8]
767:		mov [bp + 50], a1360
769:	

printArgument$215:	; parameter widthPtr, offset 8
770:		mov a1361, [bp + 16]
771:		mov [bp + 52], a1361
773:	

printArgument$216:	; £temporary2071 = &precision
774:		mov t1362, bp
775:		add t1362, 18
777:	

printArgument$217:	; parameter £temporary2071, offset 10
778:		mov [bp + 54], t1362
780:	

printArgument$218:	; call function noellipse-noellipse checkWidthAndPrecision
781:		mov word [bp + 44], printArgument$219
782:		mov [bp + 46], bp
783:		add bp, 44
784:		jmp checkWidthAndPrecision
786:	

printArgument$219:	; post call
788:	

printArgument$220:	; £temporary2072 = return_value
793:	

printArgument$221:	; arg_list = £temporary2072
794:		mov [bp + 8], t1364
796:	

printArgument$222:	; if c != 102 goto 233
797:		cmp byte [bp + 30], 102
798:		jne printArgument$233
800:	

printArgument$223:	; call header integral zero 0 stack zero 0
802:	

printArgument$224:	; push float longDoubleValue
803:		fld qword [bp + 34]
805:	

printArgument$225:	; parameter longDoubleValue, offset 6
806:		fstp qword [bp + 50]
808:	

printArgument$226:	; parameter plus, offset 14
809:		mov a1365, [bp + 10]
810:		mov [bp + 58], a1365
812:	

printArgument$227:	; parameter space, offset 16
813:		mov a1366, [bp + 12]
814:		mov [bp + 60], a1366
816:	

printArgument$228:	; parameter grid, offset 18
817:		mov a1367, [bp + 14]
818:		mov [bp + 62], a1367
820:	

printArgument$229:	; parameter precision, offset 20
821:		mov a1368, [bp + 18]
822:		mov [bp + 64], a1368
824:	

printArgument$230:	; call function noellipse-noellipse printLongDoublePlain
825:		mov word [bp + 44], printArgument$231
826:		mov [bp + 46], bp
827:		add bp, 44
828:		jmp printLongDoublePlain
830:	

printArgument$231:	; post call
832:	

printArgument$232:	; goto 359
833:		jmp printArgument$359
835:	

printArgument$233:	; call header integral zero 0 stack zero 0
837:	

printArgument$234:	; £temporary2075 = int_to_int c (Signed_Char -> Signed_Int)
838:		mov a1369, [bp + 30]
840:		and a1369, 255
842:		cmp a1369, 0
843:		jge printArgument$235
844:		neg a1369
846:		neg a1369
848:	

printArgument$235:	; parameter £temporary2075, offset 6
849:		mov [bp + 50], a1369
851:	

printArgument$236:	; call function noellipse-noellipse tolower
852:		mov word [bp + 44], printArgument$237
853:		mov [bp + 46], bp
854:		add bp, 44
855:		jmp tolower
857:	

printArgument$237:	; post call
859:	

printArgument$238:	; £temporary2076 = return_value
864:	

printArgument$239:	; if £temporary2076 != 101 goto 257
865:		cmp t1371, 101
866:		jne printArgument$257
868:	

printArgument$240:	; call header integral zero 0 stack zero 0
870:	

printArgument$241:	; push float longDoubleValue
871:		fld qword [bp + 34]
873:	

printArgument$242:	; parameter longDoubleValue, offset 6
874:		fstp qword [bp + 50]
876:	

printArgument$243:	; parameter plus, offset 14
877:		mov a1372, [bp + 10]
878:		mov [bp + 58], a1372
880:	

printArgument$244:	; parameter space, offset 16
881:		mov a1373, [bp + 12]
882:		mov [bp + 60], a1373
884:	

printArgument$245:	; parameter grid, offset 18
885:		mov a1374, [bp + 14]
886:		mov [bp + 62], a1374
888:	

printArgument$246:	; parameter precision, offset 20
889:		mov a1375, [bp + 18]
890:		mov [bp + 64], a1375
892:	

printArgument$247:	; call header integral zero 0 stack zero 0
894:	

printArgument$248:	; £temporary2078 = int_to_int c (Signed_Char -> Signed_Int)
895:		mov a1376, [bp + 30]
897:		and a1376, 255
899:		cmp a1376, 0
900:		jge printArgument$249
901:		neg a1376
903:		neg a1376
905:	

printArgument$249:	; parameter £temporary2078, offset 28
906:		mov [bp + 72], a1376
908:	

printArgument$250:	; call function noellipse-noellipse isupper
909:		mov word [bp + 66], printArgument$251
910:		mov [bp + 68], bp
911:		add bp, 66
912:		jmp isupper
914:	

printArgument$251:	; post call
916:	

printArgument$252:	; £temporary2079 = return_value
921:	

printArgument$253:	; parameter £temporary2079, offset 22
922:		mov [bp + 66], t1378
924:	

printArgument$254:	; call function noellipse-noellipse printLongDoubleExpo
925:		mov word [bp + 44], printArgument$255
926:		mov [bp + 46], bp
927:		add bp, 44
928:		jmp printLongDoubleExpo
930:	

printArgument$255:	; post call
932:	

printArgument$256:	; goto 359
933:		jmp printArgument$359
935:	

printArgument$257:	; call header integral zero 0 stack zero 0
937:	

printArgument$258:	; call header integral zero 0 stack zero 0
939:	

printArgument$259:	; push float longDoubleValue
940:		fld qword [bp + 34]
942:	

printArgument$260:	; parameter longDoubleValue, offset 6
943:		fstp qword [bp + 50]
945:	

printArgument$261:	; call function noellipse-noellipse fabs
946:		mov word [bp + 44], printArgument$262
947:		mov [bp + 46], bp
948:		add bp, 44
949:		jmp fabs
951:	

printArgument$262:	; post call
953:	

printArgument$263:	; £temporary2081 = return_value
955:	

printArgument$264:	; parameter £temporary2081, offset 6
956:		fstp qword [bp + 50]
958:	

printArgument$265:	; call function noellipse-noellipse log10
959:		mov word [bp + 44], printArgument$266
960:		mov [bp + 46], bp
961:		add bp, 44
962:		jmp log10
964:	

printArgument$266:	; post call
966:	

printArgument$267:	; £temporary2082 = return_value
968:	

printArgument$268:	; £temporary2083 = float_to_int £temporary2082 (Double -> Signed_Int)
969:		fistp word [container2bytes#]
970:		mov t1379, [container2bytes#]
972:	

printArgument$269:	; expo = £temporary2083
973:		mov [bp + 44], t1379
975:	

printArgument$270:	; if expo < -3 goto 282
976:		cmp word [bp + 44], -3
977:		jl printArgument$282
979:	

printArgument$271:	; if expo > 2 goto 282
980:		cmp word [bp + 44], 2
981:		jg printArgument$282
983:	

printArgument$272:	; call header integral zero 0 stack zero 0
985:	

printArgument$273:	; push float longDoubleValue
986:		fld qword [bp + 34]
988:	

printArgument$274:	; parameter longDoubleValue, offset 6
989:		fstp qword [bp + 52]
991:	

printArgument$275:	; parameter plus, offset 14
992:		mov a1380, [bp + 10]
993:		mov [bp + 60], a1380
995:	

printArgument$276:	; parameter space, offset 16
996:		mov a1381, [bp + 12]
997:		mov [bp + 62], a1381
999:	

printArgument$277:	; parameter grid, offset 18
1000:		mov a1382, [bp + 14]
1001:		mov [bp + 64], a1382
1003:	

printArgument$278:	; parameter precision, offset 20
1004:		mov a1383, [bp + 18]
1005:		mov [bp + 66], a1383
1007:	

printArgument$279:	; call function noellipse-noellipse printLongDoublePlain
1008:		mov word [bp + 46], printArgument$280
1009:		mov [bp + 48], bp
1010:		add bp, 46
1011:		jmp printLongDoublePlain
1013:	

printArgument$280:	; post call
1015:	

printArgument$281:	; goto 359
1016:		jmp printArgument$359
1018:	

printArgument$282:	; call header integral zero 0 stack zero 0
1020:	

printArgument$283:	; push float longDoubleValue
1021:		fld qword [bp + 34]
1023:	

printArgument$284:	; parameter longDoubleValue, offset 6
1024:		fstp qword [bp + 52]
1026:	

printArgument$285:	; parameter plus, offset 14
1027:		mov a1384, [bp + 10]
1028:		mov [bp + 60], a1384
1030:	

printArgument$286:	; parameter space, offset 16
1031:		mov a1385, [bp + 12]
1032:		mov [bp + 62], a1385
1034:	

printArgument$287:	; parameter grid, offset 18
1035:		mov a1386, [bp + 14]
1036:		mov [bp + 64], a1386
1038:	

printArgument$288:	; parameter precision, offset 20
1039:		mov a1387, [bp + 18]
1040:		mov [bp + 66], a1387
1042:	

printArgument$289:	; call header integral zero 0 stack zero 0
1044:	

printArgument$290:	; £temporary2088 = int_to_int c (Signed_Char -> Signed_Int)
1045:		mov a1388, [bp + 30]
1047:		and a1388, 255
1049:		cmp a1388, 0
1050:		jge printArgument$291
1051:		neg a1388
1053:		neg a1388
1055:	

printArgument$291:	; parameter £temporary2088, offset 28
1056:		mov [bp + 74], a1388
1058:	

printArgument$292:	; call function noellipse-noellipse isupper
1059:		mov word [bp + 68], printArgument$293
1060:		mov [bp + 70], bp
1061:		add bp, 68
1062:		jmp isupper
1064:	

printArgument$293:	; post call
1066:	

printArgument$294:	; £temporary2089 = return_value
1071:	

printArgument$295:	; parameter £temporary2089, offset 22
1072:		mov [bp + 68], t1390
1074:	

printArgument$296:	; call function noellipse-noellipse printLongDoubleExpo
1075:		mov word [bp + 46], printArgument$297
1076:		mov [bp + 48], bp
1077:		add bp, 46
1078:		jmp printLongDoubleExpo
1080:	

printArgument$297:	; post call
1082:	

printArgument$298:	; goto 359
1083:		jmp printArgument$359
1085:	

printArgument$299:	; arg_list = arg_list + 2
1086:		add word [bp + 8], 2
1088:	

printArgument$300:	; £temporary2092 = arg_list - 2
1089:		mov a1391, [bp + 8]
1090:		sub a1391, 2
1092:	

printArgument$301:	; £temporary2093 = int_to_int £temporary2092 (Signed_Int -> Pointer)
1095:	

printArgument$302:	; £temporary2094 -> £temporary2093 = *£temporary2093
1097:	

printArgument$303:	; ptrValue = £temporary2094 -> £temporary2093
1098:		mov t1392, [a1391]
1099:		mov [bp + 42], t1392
1101:	

printArgument$304:	; call header integral zero 0 stack zero 0
1103:	

printArgument$305:	; parameter arg_list, offset 6
1104:		mov a1393, [bp + 8]
1105:		mov [bp + 50], a1393
1107:	

printArgument$306:	; parameter widthPtr, offset 8
1108:		mov a1394, [bp + 16]
1109:		mov [bp + 52], a1394
1111:	

printArgument$307:	; £temporary2095 = &precision
1112:		mov t1395, bp
1113:		add t1395, 18
1115:	

printArgument$308:	; parameter £temporary2095, offset 10
1116:		mov [bp + 54], t1395
1118:	

printArgument$309:	; call function noellipse-noellipse checkWidthAndPrecision
1119:		mov word [bp + 44], printArgument$310
1120:		mov [bp + 46], bp
1121:		add bp, 44
1122:		jmp checkWidthAndPrecision
1124:	

printArgument$310:	; post call
1126:	

printArgument$311:	; £temporary2096 = return_value
1131:	

printArgument$312:	; arg_list = £temporary2096
1132:		mov [bp + 8], t1397
1134:	

printArgument$313:	; call header integral zero 0 stack zero 0
1136:	

printArgument$314:	; £temporary2097 = int_to_int ptrValue (Pointer -> Unsigned_Long_Int)
1137:		mov a1398, [bp + 42]
1139:		and a1398, 65535
1141:	

printArgument$315:	; parameter £temporary2097, offset 6
1142:		mov [bp + 50], a1398
1144:	

printArgument$316:	; parameter 0, offset 10
1145:		mov word [bp + 54], 0
1147:	

printArgument$317:	; parameter 0, offset 12
1148:		mov word [bp + 56], 0
1150:	

printArgument$318:	; parameter 0, offset 14
1151:		mov word [bp + 58], 0
1153:	

printArgument$319:	; parameter 10, offset 16
1154:		mov dword [bp + 60], 10
1156:	

printArgument$320:	; parameter 0, offset 20
1157:		mov word [bp + 64], 0
1159:	

printArgument$321:	; call function noellipse-noellipse printUnsignedLong
1160:		mov word [bp + 44], printArgument$322
1161:		mov [bp + 46], bp
1162:		add bp, 44
1163:		jmp printUnsignedLong
1165:	

printArgument$322:	; post call
1167:	

printArgument$323:	; goto 359
1168:		jmp printArgument$359
1170:	

printArgument$324:	; arg_list = arg_list + 2
1171:		add word [bp + 8], 2
1173:	

printArgument$325:	; £temporary2100 = arg_list - 2
1174:		mov a1399, [bp + 8]
1175:		sub a1399, 2
1177:	

printArgument$326:	; £temporary2101 = int_to_int £temporary2100 (Signed_Int -> Pointer)
1180:	

printArgument$327:	; £temporary2102 -> £temporary2101 = *£temporary2101
1182:	

printArgument$328:	; ptrValue = £temporary2102 -> £temporary2101
1183:		mov t1400, [a1399]
1184:		mov [bp + 42], t1400
1186:	

printArgument$329:	; arg_list = arg_list + 2
1187:		add word [bp + 8], 2
1189:	

printArgument$330:	; £temporary2104 = arg_list - 2
1190:		mov a1401, [bp + 8]
1191:		sub a1401, 2
1193:	

printArgument$331:	; £temporary2105 = int_to_int £temporary2104 (Signed_Int -> Pointer)
1196:	

printArgument$332:	; £temporary2106 -> £temporary2105 = *£temporary2105
1198:	

printArgument$333:	; intPtr = £temporary2106 -> £temporary2105
1199:		mov t1402, [a1401]
1200:		mov [bp + 32], t1402
1202:	

printArgument$334:	; call header integral zero 0 stack zero 0
1204:	

printArgument$335:	; parameter arg_list, offset 6
1205:		mov a1403, [bp + 8]
1206:		mov [bp + 50], a1403
1208:	

printArgument$336:	; parameter widthPtr, offset 8
1209:		mov a1404, [bp + 16]
1210:		mov [bp + 52], a1404
1212:	

printArgument$337:	; £temporary2107 = &precision
1213:		mov t1405, bp
1214:		add t1405, 18
1216:	

printArgument$338:	; parameter £temporary2107, offset 10
1217:		mov [bp + 54], t1405
1219:	

printArgument$339:	; call function noellipse-noellipse checkWidthAndPrecision
1220:		mov word [bp + 44], printArgument$340
1221:		mov [bp + 46], bp
1222:		add bp, 44
1223:		jmp checkWidthAndPrecision
1225:	

printArgument$340:	; post call
1227:	

printArgument$341:	; £temporary2108 = return_value
1232:	

printArgument$342:	; arg_list = £temporary2108
1233:		mov [bp + 8], t1407
1235:	

printArgument$343:	; £temporary2109 -> intPtr = *intPtr
1236:		mov a1408, [bp + 32]
1238:	

printArgument$344:	; £temporary2109 -> intPtr = g_outChars
1239:		mov a1409, [g_outChars]
1240:		mov [a1408], a1409
1242:	

printArgument$345:	; goto 359
1243:		jmp printArgument$359
1245:	

printArgument$346:	; call header integral zero 0 stack zero 0
1247:	

printArgument$347:	; parameter arg_list, offset 6
1248:		mov a1410, [bp + 8]
1249:		mov [bp + 50], a1410
1251:	

printArgument$348:	; parameter widthPtr, offset 8
1252:		mov a1411, [bp + 16]
1253:		mov [bp + 52], a1411
1255:	

printArgument$349:	; £temporary2110 = &precision
1256:		mov t1412, bp
1257:		add t1412, 18
1259:	

printArgument$350:	; parameter £temporary2110, offset 10
1260:		mov [bp + 54], t1412
1262:	

printArgument$351:	; call function noellipse-noellipse checkWidthAndPrecision
1263:		mov word [bp + 44], printArgument$352
1264:		mov [bp + 46], bp
1265:		add bp, 44
1266:		jmp checkWidthAndPrecision
1268:	

printArgument$352:	; post call
1270:	

printArgument$353:	; £temporary2111 = return_value
1275:	

printArgument$354:	; arg_list = £temporary2111
1276:		mov [bp + 8], t1414
1278:	

printArgument$355:	; call header integral zero 0 stack zero 0
1280:	

printArgument$356:	; parameter 37, offset 6
1281:		mov byte [bp + 50], 37
1283:	

printArgument$357:	; call function noellipse-noellipse printChar
1284:		mov word [bp + 44], printArgument$358
1285:		mov [bp + 46], bp
1286:		add bp, 44
1287:		jmp printChar
1289:	

printArgument$358:	; post call
1291:	

printArgument$359:	; return_value = arg_list
1292:		mov a1415, [bp + 8]
1294:	

printArgument$360:	; return
1295:		mov t1416, [bp]
1296:		mov di, [bp + 4]
1297:		mov bp, [bp + 2]
1298:		jmp t1416
1300:	

printArgument$361:	; function end printArgument
1:	

printFormat:	; width = 0
2:		mov word [bp + 12], 0
4:	

printFormat$1:	; precision = 0
5:		mov word [bp + 14], 0
7:	

printFormat$2:	; percent = 0
8:		mov word [bp + 16], 0
10:	

printFormat$3:	; plus = 0
11:		mov word [bp + 18], 0
13:	

printFormat$4:	; minus = 0
14:		mov word [bp + 20], 0
16:	

printFormat$5:	; space = 0
17:		mov word [bp + 22], 0
19:	

printFormat$6:	; zero = 0
20:		mov word [bp + 24], 0
22:	

printFormat$7:	; grid = 0
23:		mov word [bp + 26], 0
25:	

printFormat$8:	; widthStar = 0
26:		mov word [bp + 28], 0
28:	

printFormat$9:	; period = 0
29:		mov word [bp + 30], 0
31:	

printFormat$10:	; precisionStar = 0
32:		mov word [bp + 32], 0
34:	

printFormat$11:	; shortInt = 0
35:		mov word [bp + 34], 0
37:	

printFormat$12:	; longInt = 0
38:		mov word [bp + 36], 0
40:	

printFormat$13:	; longDouble = 0
41:		mov word [bp + 38], 0
43:	

printFormat$14:	; g_outChars = 0
44:		mov word [g_outChars], 0
46:	

printFormat$15:	; index = 0
47:		mov word [bp + 10], 0
49:	

printFormat$16:	; £temporary2200 = format + index
50:		mov a1417, [bp + 6]
51:		add a1417, [bp + 10]
53:	

printFormat$17:	; £temporary2199 -> £temporary2200 = *£temporary2200
55:	

printFormat$18:	; if £temporary2199 -> £temporary2200 == 0 goto 282
56:		cmp byte [a1417], 0
57:		je printFormat$282
59:	

printFormat$19:	; £temporary2204 = format + index
60:		mov a1418, [bp + 6]
61:		add a1418, [bp + 10]
63:	

printFormat$20:	; £temporary2203 -> £temporary2204 = *£temporary2204
65:	

printFormat$21:	; c = £temporary2203 -> £temporary2204
66:		mov t1419, [a1418]
67:		mov [bp + 40], t1419
69:	

printFormat$22:	; if percent == 0 goto 260
70:		cmp word [bp + 16], 0
71:		je printFormat$260
73:	

printFormat$23:	; case c == 43 goto 52
74:		mov a1420, [bp + 40]
75:		cmp a1420, 43
76:		je printFormat$52
78:	

printFormat$24:	; case c == 45 goto 54
79:		cmp a1420, 45
80:		je printFormat$54
82:	

printFormat$25:	; case c == 32 goto 56
83:		cmp a1420, 32
84:		je printFormat$56
86:	

printFormat$26:	; case c == 48 goto 58
87:		cmp a1420, 48
88:		je printFormat$58
90:	

printFormat$27:	; case c == 35 goto 60
91:		cmp a1420, 35
92:		je printFormat$60
94:	

printFormat$28:	; case c == 46 goto 62
95:		cmp a1420, 46
96:		je printFormat$62
98:	

printFormat$29:	; case c == 42 goto 64
99:		cmp a1420, 42
100:		je printFormat$64
102:	

printFormat$30:	; case c == 104 goto 69
103:		cmp a1420, 104
104:		je printFormat$69
106:	

printFormat$31:	; case c == 108 goto 71
107:		cmp a1420, 108
108:		je printFormat$71
110:	

printFormat$32:	; case c == 76 goto 73
111:		cmp a1420, 76
112:		je printFormat$73
114:	

printFormat$33:	; case c == 37 goto 75
115:		cmp a1420, 37
116:		je printFormat$75
118:	

printFormat$34:	; case c == 110 goto 75
119:		cmp a1420, 110
120:		je printFormat$75
122:	

printFormat$35:	; case c == 112 goto 75
123:		cmp a1420, 112
124:		je printFormat$75
126:	

printFormat$36:	; case c == 71 goto 75
127:		cmp a1420, 71
128:		je printFormat$75
130:	

printFormat$37:	; case c == 103 goto 75
131:		cmp a1420, 103
132:		je printFormat$75
134:	

printFormat$38:	; case c == 69 goto 75
135:		cmp a1420, 69
136:		je printFormat$75
138:	

printFormat$39:	; case c == 101 goto 75
139:		cmp a1420, 101
140:		je printFormat$75
142:	

printFormat$40:	; case c == 102 goto 75
143:		cmp a1420, 102
144:		je printFormat$75
146:	

printFormat$41:	; case c == 115 goto 75
147:		cmp a1420, 115
148:		je printFormat$75
150:	

printFormat$42:	; case c == 99 goto 75
151:		cmp a1420, 99
152:		je printFormat$75
154:	

printFormat$43:	; case c == 88 goto 75
155:		cmp a1420, 88
156:		je printFormat$75
158:	

printFormat$44:	; case c == 120 goto 75
159:		cmp a1420, 120
160:		je printFormat$75
162:	

printFormat$45:	; case c == 111 goto 75
163:		cmp a1420, 111
164:		je printFormat$75
166:	

printFormat$46:	; case c == 98 goto 75
167:		cmp a1420, 98
168:		je printFormat$75
170:	

printFormat$47:	; case c == 117 goto 75
171:		cmp a1420, 117
172:		je printFormat$75
174:	

printFormat$48:	; case c == 100 goto 75
175:		cmp a1420, 100
176:		je printFormat$75
178:	

printFormat$49:	; case c == 105 goto 75
179:		cmp a1420, 105
180:		je printFormat$75
182:	

printFormat$50:	; case end c
184:	

printFormat$51:	; goto 237
185:		jmp printFormat$237
187:	

printFormat$52:	; plus = 1
188:		mov word [bp + 18], 1
190:	

printFormat$53:	; goto 280
191:		jmp printFormat$280
193:	

printFormat$54:	; minus = 1
194:		mov word [bp + 20], 1
196:	

printFormat$55:	; goto 280
197:		jmp printFormat$280
199:	

printFormat$56:	; space = 1
200:		mov word [bp + 22], 1
202:	

printFormat$57:	; goto 280
203:		jmp printFormat$280
205:	

printFormat$58:	; zero = 1
206:		mov word [bp + 24], 1
208:	

printFormat$59:	; goto 280
209:		jmp printFormat$280
211:	

printFormat$60:	; grid = 1
212:		mov word [bp + 26], 1
214:	

printFormat$61:	; goto 280
215:		jmp printFormat$280
217:	

printFormat$62:	; period = 1
218:		mov word [bp + 30], 1
220:	

printFormat$63:	; goto 280
221:		jmp printFormat$280
223:	

printFormat$64:	; if period != 0 goto 67
224:		cmp word [bp + 30], 0
225:		jne printFormat$67
227:	

printFormat$65:	; width = -1
228:		mov word [bp + 12], -1
230:	

printFormat$66:	; goto 280
231:		jmp printFormat$280
233:	

printFormat$67:	; precision = -1
234:		mov word [bp + 14], -1
236:	

printFormat$68:	; goto 280
237:		jmp printFormat$280
239:	

printFormat$69:	; shortInt = 1
240:		mov word [bp + 34], 1
242:	

printFormat$70:	; goto 280
243:		jmp printFormat$280
245:	

printFormat$71:	; longInt = 1
246:		mov word [bp + 36], 1
248:	

printFormat$72:	; goto 280
249:		jmp printFormat$280
251:	

printFormat$73:	; longDouble = 1
252:		mov word [bp + 38], 1
254:	

printFormat$74:	; goto 280
255:		jmp printFormat$280
257:	

printFormat$75:	; if minus == 0 goto 106
258:		cmp word [bp + 20], 0
259:		je printFormat$106
261:	

printFormat$76:	; startChars = g_outChars
262:		mov a1421, [g_outChars]
263:		mov [bp + 41], a1421
265:	

printFormat$77:	; call header integral zero 0 stack zero 0
267:	

printFormat$78:	; £temporary2208 = format + index
268:		mov a1422, [bp + 6]
269:		add a1422, [bp + 10]
271:	

printFormat$79:	; £temporary2207 -> £temporary2208 = *£temporary2208
273:	

printFormat$80:	; £temporary2209 = &£temporary2207 -> £temporary2208
275:	

printFormat$81:	; parameter £temporary2209, offset 6
276:		mov [bp + 49], a1422
278:	

printFormat$82:	; parameter arg_list, offset 8
279:		mov a1423, [bp + 8]
280:		mov [bp + 51], a1423
282:	

printFormat$83:	; parameter plus, offset 10
283:		mov a1424, [bp + 18]
284:		mov [bp + 53], a1424
286:	

printFormat$84:	; parameter space, offset 12
287:		mov a1425, [bp + 22]
288:		mov [bp + 55], a1425
290:	

printFormat$85:	; parameter grid, offset 14
291:		mov a1426, [bp + 26]
292:		mov [bp + 57], a1426
294:	

printFormat$86:	; £temporary2210 = &width
295:		mov t1427, bp
296:		add t1427, 12
298:	

printFormat$87:	; parameter £temporary2210, offset 16
299:		mov [bp + 59], t1427
301:	

printFormat$88:	; parameter precision, offset 18
302:		mov a1428, [bp + 14]
303:		mov [bp + 61], a1428
305:	

printFormat$89:	; parameter shortInt, offset 20
306:		mov a1429, [bp + 34]
307:		mov [bp + 63], a1429
309:	

printFormat$90:	; parameter longInt, offset 22
310:		mov a1430, [bp + 36]
311:		mov [bp + 65], a1430
313:	

printFormat$91:	; parameter longDouble, offset 24
314:		mov a1431, [bp + 38]
315:		mov [bp + 67], a1431
317:	

printFormat$92:	; parameter 1, offset 26
318:		mov word [bp + 69], 1
320:	

printFormat$93:	; parameter 0, offset 28
321:		mov word [bp + 71], 0
323:	

printFormat$94:	; call function noellipse-noellipse printArgument
324:		mov word [bp + 43], printFormat$95
325:		mov [bp + 45], bp
326:		add bp, 43
327:		jmp printArgument
329:	

printFormat$95:	; post call
331:	

printFormat$96:	; £temporary2211 = return_value
336:	

printFormat$97:	; arg_list = £temporary2211
337:		mov [bp + 8], t1433
339:	

printFormat$98:	; £temporary2213 = g_outChars - startChars
340:		mov a1434, [g_outChars]
341:		sub a1434, [bp + 41]
343:	

printFormat$99:	; ++field
344:		inc word [bp + 43]
346:	

printFormat$100:	; if £temporary2213 >= width goto 235
347:		cmp a1434, [bp + 12]
348:		jge printFormat$235
350:	

printFormat$101:	; call header integral zero 0 stack zero 0
352:	

printFormat$102:	; parameter 32, offset 6
353:		mov byte [bp + 51], 32
355:	

printFormat$103:	; call function noellipse-noellipse printChar
356:		mov word [bp + 45], printFormat$104
357:		mov [bp + 47], bp
358:		add bp, 45
359:		jmp printChar
361:	

printFormat$104:	; post call
363:	

printFormat$105:	; goto 99
364:		jmp printFormat$99
366:	

printFormat$106:	; if zero == 0 goto 182
367:		cmp word [bp + 24], 0
368:		je printFormat$182
370:	

printFormat$107:	; startChars = g_outChars
371:		mov a1435, [g_outChars]
372:		mov [bp + 41], a1435
374:	

printFormat$108:	; oldOutStatus = g_outStatus
375:		mov a1436, [g_outStatus]
376:		mov [bp + 43], a1436
378:	

printFormat$109:	; negative = 0
379:		mov word [bp + 45], 0
381:	

printFormat$110:	; g_outStatus = 2
382:		mov word [g_outStatus], 2
384:	

printFormat$111:	; call header integral zero 0 stack zero 0
386:	

printFormat$112:	; £temporary2217 = format + index
387:		mov a1437, [bp + 6]
388:		add a1437, [bp + 10]
390:	

printFormat$113:	; £temporary2216 -> £temporary2217 = *£temporary2217
392:	

printFormat$114:	; £temporary2218 = &£temporary2216 -> £temporary2217
394:	

printFormat$115:	; parameter £temporary2218, offset 6
395:		mov [bp + 53], a1437
397:	

printFormat$116:	; parameter arg_list, offset 8
398:		mov a1438, [bp + 8]
399:		mov [bp + 55], a1438
401:	

printFormat$117:	; parameter 0, offset 10
402:		mov word [bp + 57], 0
404:	

printFormat$118:	; parameter 0, offset 12
405:		mov word [bp + 59], 0
407:	

printFormat$119:	; parameter grid, offset 14
408:		mov a1439, [bp + 26]
409:		mov [bp + 61], a1439
411:	

printFormat$120:	; £temporary2219 = &width
412:		mov t1440, bp
413:		add t1440, 12
415:	

printFormat$121:	; parameter £temporary2219, offset 16
416:		mov [bp + 63], t1440
418:	

printFormat$122:	; parameter precision, offset 18
419:		mov a1441, [bp + 14]
420:		mov [bp + 65], a1441
422:	

printFormat$123:	; parameter shortInt, offset 20
423:		mov a1442, [bp + 34]
424:		mov [bp + 67], a1442
426:	

printFormat$124:	; parameter longInt, offset 22
427:		mov a1443, [bp + 36]
428:		mov [bp + 69], a1443
430:	

printFormat$125:	; parameter longDouble, offset 24
431:		mov a1444, [bp + 38]
432:		mov [bp + 71], a1444
434:	

printFormat$126:	; parameter 0, offset 26
435:		mov word [bp + 73], 0
437:	

printFormat$127:	; £temporary2220 = &negative
438:		mov t1445, bp
439:		add t1445, 45
441:	

printFormat$128:	; parameter £temporary2220, offset 28
442:		mov [bp + 75], t1445
444:	

printFormat$129:	; call function noellipse-noellipse printArgument
445:		mov word [bp + 47], printFormat$130
446:		mov [bp + 49], bp
447:		add bp, 47
448:		jmp printArgument
450:	

printFormat$130:	; post call
452:	

printFormat$131:	; g_outStatus = oldOutStatus
453:		mov a1446, [bp + 43]
454:		mov [g_outStatus], a1446
456:	

printFormat$132:	; field = g_outChars - startChars
457:		mov a1447, [g_outChars]
458:		sub a1447, [bp + 41]
459:		mov [bp + 47], a1447
461:	

printFormat$133:	; g_outChars = startChars
462:		mov a1448, [bp + 41]
463:		mov [g_outChars], a1448
465:	

printFormat$134:	; if negative == 0 goto 141
466:		cmp word [bp + 45], 0
467:		je printFormat$141
469:	

printFormat$135:	; call header integral zero 0 stack zero 0
471:	

printFormat$136:	; parameter 45, offset 6
472:		mov byte [bp + 55], 45
474:	

printFormat$137:	; call function noellipse-noellipse printChar
475:		mov word [bp + 49], printFormat$138
476:		mov [bp + 51], bp
477:		add bp, 49
478:		jmp printChar
480:	

printFormat$138:	; post call
482:	

printFormat$139:	; ++field
483:		inc word [bp + 47]
485:	

printFormat$140:	; goto 154
486:		jmp printFormat$154
488:	

printFormat$141:	; if plus == 0 goto 148
489:		cmp word [bp + 18], 0
490:		je printFormat$148
492:	

printFormat$142:	; call header integral zero 0 stack zero 0
494:	

printFormat$143:	; parameter 43, offset 6
495:		mov byte [bp + 55], 43
497:	

printFormat$144:	; call function noellipse-noellipse printChar
498:		mov word [bp + 49], printFormat$145
499:		mov [bp + 51], bp
500:		add bp, 49
501:		jmp printChar
503:	

printFormat$145:	; post call
505:	

printFormat$146:	; ++field
506:		inc word [bp + 47]
508:	

printFormat$147:	; goto 154
509:		jmp printFormat$154
511:	

printFormat$148:	; if space == 0 goto 154
512:		cmp word [bp + 22], 0
513:		je printFormat$154
515:	

printFormat$149:	; call header integral zero 0 stack zero 0
517:	

printFormat$150:	; parameter 32, offset 6
518:		mov byte [bp + 55], 32
520:	

printFormat$151:	; call function noellipse-noellipse printChar
521:		mov word [bp + 49], printFormat$152
522:		mov [bp + 51], bp
523:		add bp, 49
524:		jmp printChar
526:	

printFormat$152:	; post call
528:	

printFormat$153:	; £temporary2232 = field + 1
529:		mov a1449, [bp + 47]
530:		add a1449, 1
532:	

printFormat$154:	; ++field
533:		inc word [bp + 47]
535:	

printFormat$155:	; if £temporary2232 >= width goto 161
536:		cmp a1449, [bp + 12]
537:		jge printFormat$161
539:	

printFormat$156:	; call header integral zero 0 stack zero 0
541:	

printFormat$157:	; parameter 48, offset 6
542:		mov byte [bp + 55], 48
544:	

printFormat$158:	; call function noellipse-noellipse printChar
545:		mov word [bp + 49], printFormat$159
546:		mov [bp + 51], bp
547:		add bp, 49
548:		jmp printChar
550:	

printFormat$159:	; post call
552:	

printFormat$160:	; goto 154
553:		jmp printFormat$154
555:	

printFormat$161:	; call header integral zero 0 stack zero 0
557:	

printFormat$162:	; £temporary2236 = format + index
558:		mov a1450, [bp + 6]
559:		add a1450, [bp + 10]
561:	

printFormat$163:	; £temporary2235 -> £temporary2236 = *£temporary2236
563:	

printFormat$164:	; £temporary2237 = &£temporary2235 -> £temporary2236
565:	

printFormat$165:	; parameter £temporary2237, offset 6
566:		mov [bp + 55], a1450
568:	

printFormat$166:	; parameter arg_list, offset 8
569:		mov a1451, [bp + 8]
570:		mov [bp + 57], a1451
572:	

printFormat$167:	; parameter 0, offset 10
573:		mov word [bp + 59], 0
575:	

printFormat$168:	; parameter 0, offset 12
576:		mov word [bp + 61], 0
578:	

printFormat$169:	; parameter grid, offset 14
579:		mov a1452, [bp + 26]
580:		mov [bp + 63], a1452
582:	

printFormat$170:	; parameter 0, offset 16
583:		mov word [bp + 65], 0
585:	

printFormat$171:	; parameter precision, offset 18
586:		mov a1453, [bp + 14]
587:		mov [bp + 67], a1453
589:	

printFormat$172:	; parameter shortInt, offset 20
590:		mov a1454, [bp + 34]
591:		mov [bp + 69], a1454
593:	

printFormat$173:	; parameter longInt, offset 22
594:		mov a1455, [bp + 36]
595:		mov [bp + 71], a1455
597:	

printFormat$174:	; parameter longDouble, offset 24
598:		mov a1456, [bp + 38]
599:		mov [bp + 73], a1456
601:	

printFormat$175:	; parameter 0, offset 26
602:		mov word [bp + 75], 0
604:	

printFormat$176:	; parameter 0, offset 28
605:		mov word [bp + 77], 0
607:	

printFormat$177:	; call function noellipse-noellipse printArgument
608:		mov word [bp + 49], printFormat$178
609:		mov [bp + 51], bp
610:		add bp, 49
611:		jmp printArgument
613:	

printFormat$178:	; post call
615:	

printFormat$179:	; £temporary2238 = return_value
620:	

printFormat$180:	; arg_list = £temporary2238
621:		mov [bp + 8], t1458
623:	

printFormat$181:	; goto 235
624:		jmp printFormat$235
626:	

printFormat$182:	; startChars = g_outChars
627:		mov a1459, [g_outChars]
628:		mov [bp + 41], a1459
630:	

printFormat$183:	; oldOutStatus = g_outStatus
631:		mov a1460, [g_outStatus]
632:		mov [bp + 43], a1460
634:	

printFormat$184:	; g_outStatus = 2
635:		mov word [g_outStatus], 2
637:	

printFormat$185:	; call header integral zero 0 stack zero 0
639:	

printFormat$186:	; £temporary2240 = format + index
640:		mov a1461, [bp + 6]
641:		add a1461, [bp + 10]
643:	

printFormat$187:	; £temporary2239 -> £temporary2240 = *£temporary2240
645:	

printFormat$188:	; £temporary2241 = &£temporary2239 -> £temporary2240
647:	

printFormat$189:	; parameter £temporary2241, offset 6
648:		mov [bp + 51], a1461
650:	

printFormat$190:	; parameter arg_list, offset 8
651:		mov a1462, [bp + 8]
652:		mov [bp + 53], a1462
654:	

printFormat$191:	; parameter plus, offset 10
655:		mov a1463, [bp + 18]
656:		mov [bp + 55], a1463
658:	

printFormat$192:	; parameter space, offset 12
659:		mov a1464, [bp + 22]
660:		mov [bp + 57], a1464
662:	

printFormat$193:	; parameter grid, offset 14
663:		mov a1465, [bp + 26]
664:		mov [bp + 59], a1465
666:	

printFormat$194:	; £temporary2242 = &width
667:		mov t1466, bp
668:		add t1466, 12
670:	

printFormat$195:	; parameter £temporary2242, offset 16
671:		mov [bp + 61], t1466
673:	

printFormat$196:	; parameter precision, offset 18
674:		mov a1467, [bp + 14]
675:		mov [bp + 63], a1467
677:	

printFormat$197:	; parameter shortInt, offset 20
678:		mov a1468, [bp + 34]
679:		mov [bp + 65], a1468
681:	

printFormat$198:	; parameter longInt, offset 22
682:		mov a1469, [bp + 36]
683:		mov [bp + 67], a1469
685:	

printFormat$199:	; parameter longDouble, offset 24
686:		mov a1470, [bp + 38]
687:		mov [bp + 69], a1470
689:	

printFormat$200:	; parameter 1, offset 26
690:		mov word [bp + 71], 1
692:	

printFormat$201:	; parameter 0, offset 28
693:		mov word [bp + 73], 0
695:	

printFormat$202:	; call function noellipse-noellipse printArgument
696:		mov word [bp + 45], printFormat$203
697:		mov [bp + 47], bp
698:		add bp, 45
699:		jmp printArgument
701:	

printFormat$203:	; post call
703:	

printFormat$204:	; g_outStatus = oldOutStatus
704:		mov a1471, [bp + 43]
705:		mov [g_outStatus], a1471
707:	

printFormat$205:	; field = g_outChars - startChars
708:		mov a1472, [g_outChars]
709:		sub a1472, [bp + 41]
710:		mov [bp + 45], a1472
712:	

printFormat$206:	; g_outChars = startChars
713:		mov a1473, [bp + 41]
714:		mov [g_outChars], a1473
716:	

printFormat$207:	; £temporary2245 = field
717:		mov t1474, [bp + 45]
719:	

printFormat$208:	; ++field
720:		inc word [bp + 45]
722:	

printFormat$209:	; if £temporary2245 >= width goto 215
723:		cmp t1474, [bp + 12]
724:		jge printFormat$215
726:	

printFormat$210:	; call header integral zero 0 stack zero 0
728:	

printFormat$211:	; parameter 32, offset 6
729:		mov byte [bp + 53], 32
731:	

printFormat$212:	; call function noellipse-noellipse printChar
732:		mov word [bp + 47], printFormat$213
733:		mov [bp + 49], bp
734:		add bp, 47
735:		jmp printChar
737:	

printFormat$213:	; post call
739:	

printFormat$214:	; goto 207
740:		jmp printFormat$207
742:	

printFormat$215:	; call header integral zero 0 stack zero 0
744:	

printFormat$216:	; £temporary2249 = format + index
745:		mov a1475, [bp + 6]
746:		add a1475, [bp + 10]
748:	

printFormat$217:	; £temporary2248 -> £temporary2249 = *£temporary2249
750:	

printFormat$218:	; £temporary2250 = &£temporary2248 -> £temporary2249
752:	

printFormat$219:	; parameter £temporary2250, offset 6
753:		mov [bp + 53], a1475
755:	

printFormat$220:	; parameter arg_list, offset 8
756:		mov a1476, [bp + 8]
757:		mov [bp + 55], a1476
759:	

printFormat$221:	; parameter plus, offset 10
760:		mov a1477, [bp + 18]
761:		mov [bp + 57], a1477
763:	

printFormat$222:	; parameter space, offset 12
764:		mov a1478, [bp + 22]
765:		mov [bp + 59], a1478
767:	

printFormat$223:	; parameter grid, offset 14
768:		mov a1479, [bp + 26]
769:		mov [bp + 61], a1479
771:	

printFormat$224:	; parameter 0, offset 16
772:		mov word [bp + 63], 0
774:	

printFormat$225:	; parameter precision, offset 18
775:		mov a1480, [bp + 14]
776:		mov [bp + 65], a1480
778:	

printFormat$226:	; parameter shortInt, offset 20
779:		mov a1481, [bp + 34]
780:		mov [bp + 67], a1481
782:	

printFormat$227:	; parameter longInt, offset 22
783:		mov a1482, [bp + 36]
784:		mov [bp + 69], a1482
786:	

printFormat$228:	; parameter longDouble, offset 24
787:		mov a1483, [bp + 38]
788:		mov [bp + 71], a1483
790:	

printFormat$229:	; parameter 1, offset 26
791:		mov word [bp + 73], 1
793:	

printFormat$230:	; parameter 0, offset 28
794:		mov word [bp + 75], 0
796:	

printFormat$231:	; call function noellipse-noellipse printArgument
797:		mov word [bp + 47], printFormat$232
798:		mov [bp + 49], bp
799:		add bp, 47
800:		jmp printArgument
802:	

printFormat$232:	; post call
804:	

printFormat$233:	; £temporary2251 = return_value
809:	

printFormat$234:	; arg_list = £temporary2251
810:		mov [bp + 8], t1485
812:	

printFormat$235:	; percent = 0
813:		mov word [bp + 16], 0
815:	

printFormat$236:	; goto 280
816:		jmp printFormat$280
818:	

printFormat$237:	; value = 0
819:		mov word [bp + 41], 0
821:	

printFormat$238:	; call header integral zero 0 stack zero 0
823:	

printFormat$239:	; £temporary2254 = int_to_int c (Signed_Char -> Signed_Int)
824:		mov a1486, [bp + 40]
826:		and a1486, 255
828:		cmp a1486, 0
829:		jge printFormat$240
830:		neg a1486
832:		neg a1486
834:	

printFormat$240:	; parameter £temporary2254, offset 6
835:		mov [bp + 49], a1486
837:	

printFormat$241:	; call function noellipse-noellipse isdigit
838:		mov word [bp + 43], printFormat$242
839:		mov [bp + 45], bp
840:		add bp, 43
841:		jmp isdigit
843:	

printFormat$242:	; post call
845:	

printFormat$243:	; £temporary2255 = return_value
850:	

printFormat$244:	; if £temporary2255 == 0 goto 254
851:		cmp t1488, 0
852:		je printFormat$254
854:	

printFormat$245:	; £temporary2256 = value * 10
855:		mov a1489, [bp + 41]
857:		xor dx, dx
858:		imul word [int2$10#]
864:	

printFormat$246:	; £temporary2257 = c - 48
865:		mov a1493, [bp + 40]
866:		sub a1493, 48
868:	

printFormat$247:	; £temporary2258 = int_to_int £temporary2257 (Signed_Char -> Signed_Int)
870:		and a1493, 255
872:		cmp a1493, 0
873:		jge printFormat$248
874:		neg a1493
876:		neg a1493
878:	

printFormat$248:	; value = £temporary2256 + £temporary2258
879:		add t1492, a1493
880:		mov [bp + 41], t1492
882:	

printFormat$249:	; £temporary2260 = index + 1
883:		mov a1494, [bp + 10]
884:		add a1494, 1
886:	

printFormat$250:	; £temporary2262 = format + £temporary2260
887:		mov a1495, [bp + 6]
888:		add a1495, a1494
890:	

printFormat$251:	; £temporary2261 -> £temporary2262 = *£temporary2262
892:	

printFormat$252:	; c = £temporary2261 -> £temporary2262
893:		mov t1496, [a1495]
894:		mov [bp + 40], t1496
896:	

printFormat$253:	; goto 238
897:		jmp printFormat$238
899:	

printFormat$254:	; --index
900:		dec word [bp + 10]
902:	

printFormat$255:	; if period != 0 goto 258
903:		cmp word [bp + 30], 0
904:		jne printFormat$258
906:	

printFormat$256:	; width = value
907:		mov a1497, [bp + 41]
908:		mov [bp + 12], a1497
910:	

printFormat$257:	; goto 280
911:		jmp printFormat$280
913:	

printFormat$258:	; precision = value
914:		mov a1498, [bp + 41]
915:		mov [bp + 14], a1498
917:	

printFormat$259:	; goto 280
918:		jmp printFormat$280
920:	

printFormat$260:	; if c != 37 goto 276
921:		cmp byte [bp + 40], 37
922:		jne printFormat$276
924:	

printFormat$261:	; percent = 1
925:		mov word [bp + 16], 1
927:	

printFormat$262:	; plus = 0
928:		mov word [bp + 18], 0
930:	

printFormat$263:	; minus = 0
931:		mov word [bp + 20], 0
933:	

printFormat$264:	; space = 0
934:		mov word [bp + 22], 0
936:	

printFormat$265:	; zero = 0
937:		mov word [bp + 24], 0
939:	

printFormat$266:	; grid = 0
940:		mov word [bp + 26], 0
942:	

printFormat$267:	; widthStar = 0
943:		mov word [bp + 28], 0
945:	

printFormat$268:	; period = 0
946:		mov word [bp + 30], 0
948:	

printFormat$269:	; precisionStar = 0
949:		mov word [bp + 32], 0
951:	

printFormat$270:	; shortInt = 0
952:		mov word [bp + 34], 0
954:	

printFormat$271:	; longInt = 0
955:		mov word [bp + 36], 0
957:	

printFormat$272:	; longDouble = 0
958:		mov word [bp + 38], 0
960:	

printFormat$273:	; width = 0
961:		mov word [bp + 12], 0
963:	

printFormat$274:	; precision = 0
964:		mov word [bp + 14], 0
966:	

printFormat$275:	; goto 280
967:		jmp printFormat$280
969:	

printFormat$276:	; call header integral zero 0 stack zero 0
971:	

printFormat$277:	; parameter c, offset 6
972:		mov a1499, [bp + 40]
973:		mov [bp + 47], a1499
975:	

printFormat$278:	; call function noellipse-noellipse printChar
976:		mov word [bp + 41], printFormat$279
977:		mov [bp + 43], bp
978:		add bp, 41
979:		jmp printChar
981:	

printFormat$279:	; post call
983:	

printFormat$280:	; ++index
984:		inc word [bp + 10]
986:	

printFormat$281:	; goto 16
987:		jmp printFormat$16
989:	

printFormat$282:	; if g_outStatus != 1 goto 288
990:		cmp word [g_outStatus], 1
991:		jne printFormat$288
993:	

printFormat$283:	; £temporary2271 = int_to_int g_outDevice (Pointer -> Pointer)
994:		mov a1500, [g_outDevice]
997:	

printFormat$284:	; outString = £temporary2271
998:		mov [bp + 40], a1500
1000:	

printFormat$285:	; £temporary2273 = outString + g_outChars
1001:		mov a1501, [bp + 40]
1002:		add a1501, [g_outChars]
1004:	

printFormat$286:	; £temporary2272 -> £temporary2273 = *£temporary2273
1006:	

printFormat$287:	; £temporary2272 -> £temporary2273 = 0
1007:		mov byte [a1501], 0
1009:	

printFormat$288:	; return_value = g_outChars
1010:		mov a1502, [g_outChars]
1012:	

printFormat$289:	; return
1013:		mov t1503, [bp]
1014:		mov di, [bp + 4]
1015:		mov bp, [bp + 2]
1016:		jmp t1503
1018:	

printFormat$290:	; function end printFormat
1:	

printf:	; £temporary2346 = &format
2:		mov t1504, bp
3:		add t1504, 6
5:	

printf$1:	; £temporary2347 = int_to_int £temporary2346 (Pointer -> Pointer)
8:	

printf$2:	; arg_list = £temporary2347 + 2
9:		add t1504, 2
10:		mov [di + 8], t1504
12:	

printf$3:	; call header integral zero 0 stack zero 0
14:	

printf$4:	; parameter format, offset 6
15:		mov a1505, [bp + 6]
16:		mov [di + 16], a1505
18:	

printf$5:	; parameter arg_list, offset 8
19:		mov a1506, [di + 8]
20:		mov [di + 18], a1506
22:	

printf$6:	; call function ellipse-noellipse vprintf
23:		mov word [di + 10], printf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vprintf
30:	

printf$7:	; post call
32:	

printf$8:	; £temporary2349 = return_value
37:	

printf$9:	; return_value = £temporary2349
39:	

printf$10:	; return
40:		mov t1509, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t1509
45:	

printf$11:	; function end printf
1:	

vprintf:	; call header integral zero 0 stack zero 0
3:	

vprintf$1:	; parameter stdout, offset 6
4:		mov a1510, [stdout]
5:		mov [bp + 16], a1510
7:	

vprintf$2:	; parameter format, offset 8
8:		mov a1511, [bp + 6]
9:		mov [bp + 18], a1511
11:	

vprintf$3:	; parameter arg_list, offset 10
12:		mov a1512, [bp + 8]
13:		mov [bp + 20], a1512
15:	

vprintf$4:	; call function noellipse-noellipse vfprintf
16:		mov word [bp + 10], vprintf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfprintf
21:	

vprintf$5:	; post call
23:	

vprintf$6:	; £temporary2353 = return_value
28:	

vprintf$7:	; return_value = £temporary2353
30:	

vprintf$8:	; return
31:		mov t1515, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp t1515
36:	

vprintf$9:	; function end vprintf
1:	

fprintf:	; £temporary2357 = &format
2:		mov t1516, bp
3:		add t1516, 8
5:	

fprintf$1:	; £temporary2358 = int_to_int £temporary2357 (Pointer -> Pointer)
8:	

fprintf$2:	; arg_list = £temporary2358 + 2
9:		add t1516, 2
10:		mov [di + 10], t1516
12:	

fprintf$3:	; call header integral zero 0 stack zero 0
14:	

fprintf$4:	; parameter outStream, offset 6
15:		mov a1517, [bp + 6]
16:		mov [di + 18], a1517
18:	

fprintf$5:	; parameter format, offset 8
19:		mov a1518, [bp + 8]
20:		mov [di + 20], a1518
22:	

fprintf$6:	; parameter arg_list, offset 10
23:		mov a1519, [di + 10]
24:		mov [di + 22], a1519
26:	

fprintf$7:	; call function ellipse-noellipse vfprintf
27:		mov word [di + 12], fprintf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfprintf
34:	

fprintf$8:	; post call
36:	

fprintf$9:	; £temporary2360 = return_value
41:	

fprintf$10:	; return_value = £temporary2360
43:	

fprintf$11:	; return
44:		mov t1522, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1522
49:	

fprintf$12:	; function end fprintf
1:	

vfprintf:	; g_outStatus = 0
2:		mov word [g_outStatus], 0
4:	

vfprintf$1:	; £temporary2365 = int_to_int outStream (Pointer -> Pointer)
5:		mov a1523, [bp + 6]
8:	

vfprintf$2:	; g_outDevice = £temporary2365
9:		mov [g_outDevice], a1523
11:	

vfprintf$3:	; call header integral zero 0 stack zero 0
13:	

vfprintf$4:	; parameter format, offset 6
14:		mov a1524, [bp + 8]
15:		mov [bp + 18], a1524
17:	

vfprintf$5:	; parameter arg_list, offset 8
18:		mov a1525, [bp + 10]
19:		mov [bp + 20], a1525
21:	

vfprintf$6:	; call function noellipse-noellipse printFormat
22:		mov word [bp + 12], vfprintf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp printFormat
27:	

vfprintf$7:	; post call
29:	

vfprintf$8:	; £temporary2366 = return_value
34:	

vfprintf$9:	; return_value = £temporary2366
36:	

vfprintf$10:	; return
37:		mov t1528, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1528
42:	

vfprintf$11:	; function end vfprintf
1:	

sprintf:	; £temporary2369 = &format
2:		mov t1529, bp
3:		add t1529, 8
5:	

sprintf$1:	; £temporary2370 = int_to_int £temporary2369 (Pointer -> Pointer)
8:	

sprintf$2:	; arg_list = £temporary2370 + 2
9:		add t1529, 2
10:		mov [di + 10], t1529
12:	

sprintf$3:	; call header integral zero 0 stack zero 0
14:	

sprintf$4:	; parameter outString, offset 6
15:		mov a1530, [bp + 6]
16:		mov [di + 18], a1530
18:	

sprintf$5:	; parameter format, offset 8
19:		mov a1531, [bp + 8]
20:		mov [di + 20], a1531
22:	

sprintf$6:	; parameter arg_list, offset 10
23:		mov a1532, [di + 10]
24:		mov [di + 22], a1532
26:	

sprintf$7:	; call function ellipse-noellipse vsprintf
27:		mov word [di + 12], sprintf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsprintf
34:	

sprintf$8:	; post call
36:	

sprintf$9:	; £temporary2372 = return_value
41:	

sprintf$10:	; return_value = £temporary2372
43:	

sprintf$11:	; return
44:		mov t1535, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp t1535
49:	

sprintf$12:	; function end sprintf
1:	

vsprintf:	; g_outStatus = 1
2:		mov word [g_outStatus], 1
4:	

vsprintf$1:	; £temporary2377 = int_to_int outString (Pointer -> Pointer)
5:		mov a1536, [bp + 6]
8:	

vsprintf$2:	; g_outDevice = £temporary2377
9:		mov [g_outDevice], a1536
11:	

vsprintf$3:	; call header integral zero 0 stack zero 0
13:	

vsprintf$4:	; parameter format, offset 6
14:		mov a1537, [bp + 8]
15:		mov [bp + 18], a1537
17:	

vsprintf$5:	; parameter arg_list, offset 8
18:		mov a1538, [bp + 10]
19:		mov [bp + 20], a1538
21:	

vsprintf$6:	; call function noellipse-noellipse printFormat
22:		mov word [bp + 12], vsprintf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp printFormat
27:	

vsprintf$7:	; post call
29:	

vsprintf$8:	; £temporary2378 = return_value
34:	

vsprintf$9:	; return_value = £temporary2378
36:	

vsprintf$10:	; return
37:		mov t1541, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t1541
42:	

vsprintf$11:	; function end vsprintf
