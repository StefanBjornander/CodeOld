1:	

islower:	; call header integral zero 0 stack zero 0
3:	

islower$1:	; call function noellipse-noellipse localeconv
4:		mov word [bp + 8], islower$2
5:		mov [bp + 10], bp
6:		add bp, 8
7:		jmp localeconv
9:	

islower$2:	; post call
11:	

islower$3:	; £temporary352 = return_value
16:	

islower$4:	; localeConvPtr = £temporary352
17:		mov [bp + 8], t199
19:	

islower$5:	; if localeConvPtr == 0 goto 19
20:		cmp word [bp + 8], 0
21:		je islower$19
23:	

islower$6:	; call header integral zero 0 stack zero 0
25:	

islower$7:	; £temporary354 -> localeConvPtr = *localeConvPtr, offset 12
26:		mov a200, [bp + 8]
28:	

islower$8:	; parameter £temporary354 -> localeConvPtr, offset 6
29:		mov t201, [a200 + 12]
30:		mov [bp + 16], t201
32:	

islower$9:	; parameter c, offset 8
33:		mov a202, [bp + 6]
34:		mov [bp + 18], a202
36:	

islower$10:	; call function noellipse-noellipse strchr
37:		mov word [bp + 10], islower$11
38:		mov [bp + 12], bp
39:		add bp, 10
40:		jmp strchr
42:	

islower$11:	; post call
44:	

islower$12:	; £temporary355 = return_value
49:	

islower$13:	; if £temporary355 == 0 goto 16
50:		cmp t204, 0
51:		je islower$16
53:	

islower$14:	; £temporary357 = 1
54:		mov t205, 1
56:	

islower$15:	; goto 17
57:		jmp islower$17
59:	

islower$16:	; £temporary357 = 0
60:		mov t206, 0
62:	

islower$17:	; return_value = £temporary357
64:	

islower$18:	; return
65:		mov t207, [bp]
66:		mov di, [bp + 4]
67:		mov bp, [bp + 2]
68:		jmp t207
70:	

islower$19:	; if c < 97 goto 23
71:		cmp word [bp + 6], 97
72:		jl islower$23
74:	

islower$20:	; if c > 122 goto 23
75:		cmp word [bp + 6], 122
76:		jg islower$23
78:	

islower$21:	; £temporary361 = 1
79:		mov t208, 1
81:	

islower$22:	; goto 24
82:		jmp islower$24
84:	

islower$23:	; £temporary361 = 0
85:		mov t209, 0
87:	

islower$24:	; return_value = £temporary361
89:	

islower$25:	; return
90:		mov t210, [bp]
91:		mov di, [bp + 4]
92:		mov bp, [bp + 2]
93:		jmp t210
95:	

islower$26:	; function end islower
1:	

islowerX:	; if c < 97 goto 4
2:		cmp word [bp + 6], 97
3:		jl islowerX$4
5:	

islowerX$1:	; if c > 122 goto 4
6:		cmp word [bp + 6], 122
7:		jg islowerX$4
9:	

islowerX$2:	; £temporary367 = 1
10:		mov t211, 1
12:	

islowerX$3:	; goto 5
13:		jmp islowerX$5
15:	

islowerX$4:	; £temporary367 = 0
16:		mov t212, 0
18:	

islowerX$5:	; return_value = £temporary367
20:	

islowerX$6:	; return
21:		mov t213, [bp]
22:		mov di, [bp + 4]
23:		mov bp, [bp + 2]
24:		jmp t213
26:	

islowerX$7:	; function end islowerX
1:	

isupperX:	; if c < 65 goto 4
2:		cmp word [bp + 6], 65
3:		jl isupperX$4
5:	

isupperX$1:	; if c > 90 goto 4
6:		cmp word [bp + 6], 90
7:		jg isupperX$4
9:	

isupperX$2:	; £temporary371 = 1
10:		mov t214, 1
12:	

isupperX$3:	; goto 5
13:		jmp isupperX$5
15:	

isupperX$4:	; £temporary371 = 0
16:		mov t215, 0
18:	

isupperX$5:	; return_value = £temporary371
20:	

isupperX$6:	; return
21:		mov t216, [bp]
22:		mov di, [bp + 4]
23:		mov bp, [bp + 2]
24:		jmp t216
26:	

isupperX$7:	; function end isupperX
1:	

isupper:	; call header integral zero 0 stack zero 0
3:	

isupper$1:	; call function noellipse-noellipse localeconv
4:		mov word [bp + 8], isupper$2
5:		mov [bp + 10], bp
6:		add bp, 8
7:		jmp localeconv
9:	

isupper$2:	; post call
11:	

isupper$3:	; £temporary372 = return_value
16:	

isupper$4:	; localeConvPtr = £temporary372
17:		mov [bp + 8], t218
19:	

isupper$5:	; if localeConvPtr == 0 goto 19
20:		cmp word [bp + 8], 0
21:		je isupper$19
23:	

isupper$6:	; call header integral zero 0 stack zero 0
25:	

isupper$7:	; £temporary374 -> localeConvPtr = *localeConvPtr, offset 14
26:		mov a219, [bp + 8]
28:	

isupper$8:	; parameter £temporary374 -> localeConvPtr, offset 6
29:		mov t220, [a219 + 14]
30:		mov [bp + 16], t220
32:	

isupper$9:	; parameter c, offset 8
33:		mov a221, [bp + 6]
34:		mov [bp + 18], a221
36:	

isupper$10:	; call function noellipse-noellipse strchr
37:		mov word [bp + 10], isupper$11
38:		mov [bp + 12], bp
39:		add bp, 10
40:		jmp strchr
42:	

isupper$11:	; post call
44:	

isupper$12:	; £temporary375 = return_value
49:	

isupper$13:	; if £temporary375 == 0 goto 16
50:		cmp t223, 0
51:		je isupper$16
53:	

isupper$14:	; £temporary377 = 1
54:		mov t224, 1
56:	

isupper$15:	; goto 17
57:		jmp isupper$17
59:	

isupper$16:	; £temporary377 = 0
60:		mov t225, 0
62:	

isupper$17:	; return_value = £temporary377
64:	

isupper$18:	; return
65:		mov t226, [bp]
66:		mov di, [bp + 4]
67:		mov bp, [bp + 2]
68:		jmp t226
70:	

isupper$19:	; if c < 65 goto 23
71:		cmp word [bp + 6], 65
72:		jl isupper$23
74:	

isupper$20:	; if c > 90 goto 23
75:		cmp word [bp + 6], 90
76:		jg isupper$23
78:	

isupper$21:	; £temporary381 = 1
79:		mov t227, 1
81:	

isupper$22:	; goto 24
82:		jmp isupper$24
84:	

isupper$23:	; £temporary381 = 0
85:		mov t228, 0
87:	

isupper$24:	; return_value = £temporary381
89:	

isupper$25:	; return
90:		mov t229, [bp]
91:		mov di, [bp + 4]
92:		mov bp, [bp + 2]
93:		jmp t229
95:	

isupper$26:	; function end isupper
1:	

isalpha:	; call header integral zero 0 stack zero 0
3:	

isalpha$1:	; parameter c, offset 6
4:		mov a230, [bp + 6]
5:		mov [bp + 14], a230
7:	

isalpha$2:	; call function noellipse-noellipse islower
8:		mov word [bp + 8], isalpha$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp islower
13:	

isalpha$3:	; post call
15:	

isalpha$4:	; £temporary384 = return_value
20:	

isalpha$5:	; if £temporary384 != 0 goto 12
21:		cmp t232, 0
22:		jne isalpha$12
24:	

isalpha$6:	; call header integral zero 0 stack zero 0
26:	

isalpha$7:	; parameter c, offset 6
27:		mov a233, [bp + 6]
28:		mov [bp + 14], a233
30:	

isalpha$8:	; call function noellipse-noellipse isupper
31:		mov word [bp + 8], isalpha$9
32:		mov [bp + 10], bp
33:		add bp, 8
34:		jmp isupper
36:	

isalpha$9:	; post call
38:	

isalpha$10:	; £temporary385 = return_value
43:	

isalpha$11:	; if £temporary385 == 0 goto 14
44:		cmp t235, 0
45:		je isalpha$14
47:	

isalpha$12:	; £temporary389 = 1
48:		mov t236, 1
50:	

isalpha$13:	; goto 15
51:		jmp isalpha$15
53:	

isalpha$14:	; £temporary389 = 0
54:		mov t237, 0
56:	

isalpha$15:	; return_value = £temporary389
58:	

isalpha$16:	; return
59:		mov t238, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp t238
64:	

isalpha$17:	; function end isalpha
1:	

isdigit:	; if c < 48 goto 4
2:		cmp word [bp + 6], 48
3:		jl isdigit$4
5:	

isdigit$1:	; if c > 57 goto 4
6:		cmp word [bp + 6], 57
7:		jg isdigit$4
9:	

isdigit$2:	; £temporary395 = 1
10:		mov t239, 1
12:	

isdigit$3:	; goto 5
13:		jmp isdigit$5
15:	

isdigit$4:	; £temporary395 = 0
16:		mov t240, 0
18:	

isdigit$5:	; return_value = £temporary395
20:	

isdigit$6:	; return
21:		mov t241, [bp]
22:		mov di, [bp + 4]
23:		mov bp, [bp + 2]
24:		jmp t241
26:	

isdigit$7:	; function end isdigit
1:	

isalnum:	; call header integral zero 0 stack zero 0
3:	

isalnum$1:	; parameter c, offset 6
4:		mov a242, [bp + 6]
5:		mov [bp + 14], a242
7:	

isalnum$2:	; call function noellipse-noellipse isalpha
8:		mov word [bp + 8], isalnum$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isalpha
13:	

isalnum$3:	; post call
15:	

isalnum$4:	; £temporary396 = return_value
20:	

isalnum$5:	; if £temporary396 != 0 goto 12
21:		cmp t244, 0
22:		jne isalnum$12
24:	

isalnum$6:	; call header integral zero 0 stack zero 0
26:	

isalnum$7:	; parameter c, offset 6
27:		mov a245, [bp + 6]
28:		mov [bp + 14], a245
30:	

isalnum$8:	; call function noellipse-noellipse isdigit
31:		mov word [bp + 8], isalnum$9
32:		mov [bp + 10], bp
33:		add bp, 8
34:		jmp isdigit
36:	

isalnum$9:	; post call
38:	

isalnum$10:	; £temporary397 = return_value
43:	

isalnum$11:	; if £temporary397 == 0 goto 14
44:		cmp t247, 0
45:		je isalnum$14
47:	

isalnum$12:	; £temporary401 = 1
48:		mov t248, 1
50:	

isalnum$13:	; goto 15
51:		jmp isalnum$15
53:	

isalnum$14:	; £temporary401 = 0
54:		mov t249, 0
56:	

isalnum$15:	; return_value = £temporary401
58:	

isalnum$16:	; return
59:		mov t250, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp t250
64:	

isalnum$17:	; function end isalnum
1:	

isxdigit:	; call header integral zero 0 stack zero 0
3:	

isxdigit$1:	; parameter c, offset 6
4:		mov a251, [bp + 6]
5:		mov [bp + 14], a251
7:	

isxdigit$2:	; call function noellipse-noellipse isdigit
8:		mov word [bp + 8], isxdigit$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isdigit
13:	

isxdigit$3:	; post call
15:	

isxdigit$4:	; £temporary404 = return_value
20:	

isxdigit$5:	; if £temporary404 != 0 goto 10
21:		cmp t253, 0
22:		jne isxdigit$10
24:	

isxdigit$6:	; if c < 97 goto 8
25:		cmp word [bp + 6], 97
26:		jl isxdigit$8
28:	

isxdigit$7:	; if c <= 102 goto 10
29:		cmp word [bp + 6], 102
30:		jle isxdigit$10
32:	

isxdigit$8:	; if c < 65 goto 12
33:		cmp word [bp + 6], 65
34:		jl isxdigit$12
36:	

isxdigit$9:	; if c > 70 goto 12
37:		cmp word [bp + 6], 70
38:		jg isxdigit$12
40:	

isxdigit$10:	; £temporary414 = 1
41:		mov t254, 1
43:	

isxdigit$11:	; goto 13
44:		jmp isxdigit$13
46:	

isxdigit$12:	; £temporary414 = 0
47:		mov t255, 0
49:	

isxdigit$13:	; return_value = £temporary414
51:	

isxdigit$14:	; return
52:		mov t256, [bp]
53:		mov di, [bp + 4]
54:		mov bp, [bp + 2]
55:		jmp t256
57:	

isxdigit$15:	; function end isxdigit
1:	

isgraph:	; if c < 32 goto 4
2:		cmp word [bp + 6], 32
3:		jl isgraph$4
5:	

isgraph$1:	; if c > 126 goto 4
6:		cmp word [bp + 6], 126
7:		jg isgraph$4
9:	

isgraph$2:	; £temporary419 = 1
10:		mov t257, 1
12:	

isgraph$3:	; goto 5
13:		jmp isgraph$5
15:	

isgraph$4:	; £temporary419 = 0
16:		mov t258, 0
18:	

isgraph$5:	; return_value = £temporary419
20:	

isgraph$6:	; return
21:		mov t259, [bp]
22:		mov di, [bp + 4]
23:		mov bp, [bp + 2]
24:		jmp t259
26:	

isgraph$7:	; function end isgraph
1:	

isprint:	; call header integral zero 0 stack zero 0
3:	

isprint$1:	; parameter c, offset 6
4:		mov a260, [bp + 6]
5:		mov [bp + 14], a260
7:	

isprint$2:	; call function noellipse-noellipse isgraph
8:		mov word [bp + 8], isprint$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isgraph
13:	

isprint$3:	; post call
15:	

isprint$4:	; £temporary420 = return_value
20:	

isprint$5:	; if £temporary420 == 0 goto 9
21:		cmp t262, 0
22:		je isprint$9
24:	

isprint$6:	; if c == 32 goto 9
25:		cmp word [bp + 6], 32
26:		je isprint$9
28:	

isprint$7:	; £temporary424 = 1
29:		mov t263, 1
31:	

isprint$8:	; goto 10
32:		jmp isprint$10
34:	

isprint$9:	; £temporary424 = 0
35:		mov t264, 0
37:	

isprint$10:	; return_value = £temporary424
39:	

isprint$11:	; return
40:		mov t265, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t265
45:	

isprint$12:	; function end isprint
1:	

ispunct:	; call header integral zero 0 stack zero 0
3:	

ispunct$1:	; parameter c, offset 6
4:		mov a266, [bp + 6]
5:		mov [bp + 14], a266
7:	

ispunct$2:	; call function noellipse-noellipse isgraph
8:		mov word [bp + 8], ispunct$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isgraph
13:	

ispunct$3:	; post call
15:	

ispunct$4:	; £temporary426 = return_value
20:	

ispunct$5:	; if £temporary426 == 0 goto 14
21:		cmp t268, 0
22:		je ispunct$14
24:	

ispunct$6:	; call header integral zero 0 stack zero 0
26:	

ispunct$7:	; parameter c, offset 6
27:		mov a269, [bp + 6]
28:		mov [bp + 14], a269
30:	

ispunct$8:	; call function noellipse-noellipse isalnum
31:		mov word [bp + 8], ispunct$9
32:		mov [bp + 10], bp
33:		add bp, 8
34:		jmp isalnum
36:	

ispunct$9:	; post call
38:	

ispunct$10:	; £temporary428 = return_value
43:	

ispunct$11:	; if £temporary428 != 0 goto 14
44:		cmp t271, 0
45:		jne ispunct$14
47:	

ispunct$12:	; £temporary432 = 1
48:		mov t272, 1
50:	

ispunct$13:	; goto 15
51:		jmp ispunct$15
53:	

ispunct$14:	; £temporary432 = 0
54:		mov t273, 0
56:	

ispunct$15:	; return_value = £temporary432
58:	

ispunct$16:	; return
59:		mov t274, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp t274
64:	

ispunct$17:	; function end ispunct
1:	

iscntrl:	; call header integral zero 0 stack zero 0
3:	

iscntrl$1:	; parameter c, offset 6
4:		mov a275, [bp + 6]
5:		mov [bp + 14], a275
7:	

iscntrl$2:	; call function noellipse-noellipse isprint
8:		mov word [bp + 8], iscntrl$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isprint
13:	

iscntrl$3:	; post call
15:	

iscntrl$4:	; £temporary435 = return_value
20:	

iscntrl$5:	; if £temporary435 != 0 goto 8
21:		cmp t277, 0
22:		jne iscntrl$8
24:	

iscntrl$6:	; £temporary438 = 1
25:		mov t278, 1
27:	

iscntrl$7:	; goto 9
28:		jmp iscntrl$9
30:	

iscntrl$8:	; £temporary438 = 0
31:		mov t279, 0
33:	

iscntrl$9:	; return_value = £temporary438
35:	

iscntrl$10:	; return
36:		mov t280, [bp]
37:		mov di, [bp + 4]
38:		mov bp, [bp + 2]
39:		jmp t280
41:	

iscntrl$11:	; function end iscntrl
1:	

isspace:	; if c == 32 goto 6
2:		cmp word [bp + 6], 32
3:		je isspace$6
5:	

isspace$1:	; if c == 12 goto 6
6:		cmp word [bp + 6], 12
7:		je isspace$6
9:	

isspace$2:	; if c == 10 goto 6
10:		cmp word [bp + 6], 10
11:		je isspace$6
13:	

isspace$3:	; if c == 13 goto 6
14:		cmp word [bp + 6], 13
15:		je isspace$6
17:	

isspace$4:	; if c == 9 goto 6
18:		cmp word [bp + 6], 9
19:		je isspace$6
21:	

isspace$5:	; if c != 11 goto 8
22:		cmp word [bp + 6], 11
23:		jne isspace$8
25:	

isspace$6:	; £temporary451 = 1
26:		mov t281, 1
28:	

isspace$7:	; goto 9
29:		jmp isspace$9
31:	

isspace$8:	; £temporary451 = 0
32:		mov t282, 0
34:	

isspace$9:	; return_value = £temporary451
36:	

isspace$10:	; return
37:		mov t283, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t283
42:	

isspace$11:	; function end isspace
1:	

tolowerX:	; call header integral zero 0 stack zero 0
3:	

tolowerX$1:	; parameter c, offset 6
4:		mov a284, [bp + 6]
5:		mov [bp + 14], a284
7:	

tolowerX$2:	; call function noellipse-noellipse isupper
8:		mov word [bp + 8], tolowerX$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isupper
13:	

tolowerX$3:	; post call
15:	

tolowerX$4:	; £temporary452 = return_value
20:	

tolowerX$5:	; if £temporary452 == 0 goto 8
21:		cmp t286, 0
22:		je tolowerX$8
24:	

tolowerX$6:	; £temporary458 = c + 32
25:		mov a287, [bp + 6]
26:		add a287, 32
28:	

tolowerX$7:	; goto 9
29:		jmp tolowerX$9
31:	

tolowerX$8:	; £temporary458 = c
32:		mov t288, [bp + 6]
34:	

tolowerX$9:	; return_value = £temporary458
36:	

tolowerX$10:	; return
37:		mov t289, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t289
42:	

tolowerX$11:	; function end tolowerX
1:	

tolower:	; call header integral zero 0 stack zero 0
3:	

tolower$1:	; parameter c, offset 6
4:		mov a290, [bp + 6]
5:		mov [bp + 14], a290
7:	

tolower$2:	; call function noellipse-noellipse isupper
8:		mov word [bp + 8], tolower$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp isupper
13:	

tolower$3:	; post call
15:	

tolower$4:	; £temporary460 = return_value
20:	

tolower$5:	; if £temporary460 == 0 goto 31
21:		cmp t292, 0
22:		je tolower$31
24:	

tolower$6:	; call header integral zero 0 stack zero 0
26:	

tolower$7:	; call function noellipse-noellipse localeconv
27:		mov word [bp + 8], tolower$8
28:		mov [bp + 10], bp
29:		add bp, 8
30:		jmp localeconv
32:	

tolower$8:	; post call
34:	

tolower$9:	; £temporary461 = return_value
39:	

tolower$10:	; localeConvPtr = £temporary461
40:		mov [bp + 8], t294
42:	

tolower$11:	; if localeConvPtr == 0 goto 28
43:		cmp word [bp + 8], 0
44:		je tolower$28
46:	

tolower$12:	; £temporary463 -> localeConvPtr = *localeConvPtr, offset 12
47:		mov a295, [bp + 8]
49:	

tolower$13:	; lowerCase = £temporary463 -> localeConvPtr
50:		mov t296, [a295 + 12]
51:		mov [bp + 10], t296
53:	

tolower$14:	; £temporary464 -> localeConvPtr = *localeConvPtr, offset 14
54:		mov a297, [bp + 8]
56:	

tolower$15:	; upperCase = £temporary464 -> localeConvPtr
57:		mov t298, [a297 + 14]
58:		mov [bp + 12], t298
60:	

tolower$16:	; call header integral zero 0 stack zero 0
62:	

tolower$17:	; parameter upperCase, offset 6
63:		mov a299, [bp + 12]
64:		mov [bp + 20], a299
66:	

tolower$18:	; parameter c, offset 8
67:		mov a300, [bp + 6]
68:		mov [bp + 22], a300
70:	

tolower$19:	; call function noellipse-noellipse strchr
71:		mov word [bp + 14], tolower$20
72:		mov [bp + 16], bp
73:		add bp, 14
74:		jmp strchr
76:	

tolower$20:	; post call
78:	

tolower$21:	; £temporary465 = return_value
83:	

tolower$22:	; index = £temporary465 - upperCase
84:		sub t302, [bp + 12]
85:		mov [bp + 14], t302
87:	

tolower$23:	; £temporary468 = lowerCase + index
88:		mov a303, [bp + 10]
89:		add a303, [bp + 14]
91:	

tolower$24:	; £temporary467 -> £temporary468 = *£temporary468
93:	

tolower$25:	; £temporary469 = int_to_int £temporary467 -> £temporary468 (Signed_Char -> Signed_Int)
94:		mov t304, [a303]
96:		and t304, 255
98:		cmp t304, 0
99:		jge tolower$26
100:		neg t304
102:		neg t304
104:	

tolower$26:	; return_value = £temporary469
106:	

tolower$27:	; return
107:		mov t305, [bp]
108:		mov di, [bp + 4]
109:		mov bp, [bp + 2]
110:		jmp t305
112:	

tolower$28:	; £temporary470 = c + 32
113:		mov a306, [bp + 6]
114:		add a306, 32
116:	

tolower$29:	; return_value = £temporary470
118:	

tolower$30:	; return
119:		mov t307, [bp]
120:		mov di, [bp + 4]
121:		mov bp, [bp + 2]
122:		jmp t307
124:	

tolower$31:	; return_value = c
125:		mov a308, [bp + 6]
127:	

tolower$32:	; return
128:		mov t309, [bp]
129:		mov di, [bp + 4]
130:		mov bp, [bp + 2]
131:		jmp t309
133:	

tolower$33:	; function end tolower
1:	

toupperX:	; call header integral zero 0 stack zero 0
3:	

toupperX$1:	; parameter c, offset 6
4:		mov a310, [bp + 6]
5:		mov [bp + 14], a310
7:	

toupperX$2:	; call function noellipse-noellipse islower
8:		mov word [bp + 8], toupperX$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp islower
13:	

toupperX$3:	; post call
15:	

toupperX$4:	; £temporary475 = return_value
20:	

toupperX$5:	; if £temporary475 == 0 goto 8
21:		cmp t312, 0
22:		je toupperX$8
24:	

toupperX$6:	; £temporary481 = c - 32
25:		mov a313, [bp + 6]
26:		sub a313, 32
28:	

toupperX$7:	; goto 9
29:		jmp toupperX$9
31:	

toupperX$8:	; £temporary481 = c
32:		mov t314, [bp + 6]
34:	

toupperX$9:	; return_value = £temporary481
36:	

toupperX$10:	; return
37:		mov t315, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp t315
42:	

toupperX$11:	; function end toupperX
1:	

toupper:	; call header integral zero 0 stack zero 0
3:	

toupper$1:	; parameter c, offset 6
4:		mov a316, [bp + 6]
5:		mov [bp + 14], a316
7:	

toupper$2:	; call function noellipse-noellipse islower
8:		mov word [bp + 8], toupper$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp islower
13:	

toupper$3:	; post call
15:	

toupper$4:	; £temporary483 = return_value
20:	

toupper$5:	; if £temporary483 == 0 goto 31
21:		cmp t318, 0
22:		je toupper$31
24:	

toupper$6:	; call header integral zero 0 stack zero 0
26:	

toupper$7:	; call function noellipse-noellipse localeconv
27:		mov word [bp + 8], toupper$8
28:		mov [bp + 10], bp
29:		add bp, 8
30:		jmp localeconv
32:	

toupper$8:	; post call
34:	

toupper$9:	; £temporary484 = return_value
39:	

toupper$10:	; localeConvPtr = £temporary484
40:		mov [bp + 8], t320
42:	

toupper$11:	; if localeConvPtr == 0 goto 28
43:		cmp word [bp + 8], 0
44:		je toupper$28
46:	

toupper$12:	; £temporary486 -> localeConvPtr = *localeConvPtr, offset 12
47:		mov a321, [bp + 8]
49:	

toupper$13:	; lowerCase = £temporary486 -> localeConvPtr
50:		mov t322, [a321 + 12]
51:		mov [bp + 10], t322
53:	

toupper$14:	; £temporary487 -> localeConvPtr = *localeConvPtr, offset 14
54:		mov a323, [bp + 8]
56:	

toupper$15:	; upperCase = £temporary487 -> localeConvPtr
57:		mov t324, [a323 + 14]
58:		mov [bp + 12], t324
60:	

toupper$16:	; call header integral zero 0 stack zero 0
62:	

toupper$17:	; parameter lowerCase, offset 6
63:		mov a325, [bp + 10]
64:		mov [bp + 20], a325
66:	

toupper$18:	; parameter c, offset 8
67:		mov a326, [bp + 6]
68:		mov [bp + 22], a326
70:	

toupper$19:	; call function noellipse-noellipse strchr
71:		mov word [bp + 14], toupper$20
72:		mov [bp + 16], bp
73:		add bp, 14
74:		jmp strchr
76:	

toupper$20:	; post call
78:	

toupper$21:	; £temporary488 = return_value
83:	

toupper$22:	; index = £temporary488 - lowerCase
84:		sub t328, [bp + 10]
85:		mov [bp + 14], t328
87:	

toupper$23:	; £temporary491 = upperCase + index
88:		mov a329, [bp + 12]
89:		add a329, [bp + 14]
91:	

toupper$24:	; £temporary490 -> £temporary491 = *£temporary491
93:	

toupper$25:	; £temporary492 = int_to_int £temporary490 -> £temporary491 (Signed_Char -> Signed_Int)
94:		mov t330, [a329]
96:		and t330, 255
98:		cmp t330, 0
99:		jge toupper$26
100:		neg t330
102:		neg t330
104:	

toupper$26:	; return_value = £temporary492
106:	

toupper$27:	; return
107:		mov t331, [bp]
108:		mov di, [bp + 4]
109:		mov bp, [bp + 2]
110:		jmp t331
112:	

toupper$28:	; £temporary493 = c - 32
113:		mov a332, [bp + 6]
114:		sub a332, 32
116:	

toupper$29:	; return_value = £temporary493
118:	

toupper$30:	; return
119:		mov t333, [bp]
120:		mov di, [bp + 4]
121:		mov bp, [bp + 2]
122:		jmp t333
124:	

toupper$31:	; return_value = c
125:		mov a334, [bp + 6]
127:	

toupper$32:	; return
128:		mov t335, [bp]
129:		mov di, [bp + 4]
130:		mov bp, [bp + 2]
131:		jmp t335
133:	

toupper$33:	; function end toupper
