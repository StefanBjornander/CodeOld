1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov ax, [g_inStatus]
6:		cmp ax, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp ax, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1326 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov ax, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1326
23:		mov [bp + 7], ax
25:	

scanChar$7:	; £temporary1327 -> stream = *stream, offset 2
26:		mov si, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1327 -> stream
29:		mov ax, [si + 2]
30:		mov [bp + 9], ax
32:	

scanChar$9:	; ah = 63
33:		mov ah, 63
35:	

scanChar$10:	; bx = handle
36:		mov bx, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov cx, 1
41:	

scanChar$12:	; £temporary1332 = &c
42:		mov dx, bp
43:		add dx, 6
45:	

scanChar$13:	; dx = £temporary1332
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov bl, [bp + 6]
56:	

scanChar$17:	; return
57:		mov ax, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp ax
62:	

scanChar$18:	; £temporary1334 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov ax, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1334
67:		mov [bp + 11], ax
69:	

scanChar$20:	; £temporary1335 = g_inChars
70:		mov ax, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1337 = inString + £temporary1335
76:		mov si, [bp + 11]
77:		add si, ax
79:	

scanChar$23:	; £temporary1336 -> £temporary1337 = *£temporary1337
81:	

scanChar$24:	; return_value = £temporary1336 -> £temporary1337
82:		mov bl, [si]
84:	

scanChar$25:	; return
85:		mov ax, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp ax
90:	

scanChar$26:	; return_value = 0
91:		mov bl, 0
93:	

scanChar$27:	; return
94:		mov ax, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp ax
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov ax, [g_inStatus]
3:		cmp ax, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp ax, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov ax, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp ax
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1341 = return_value
19:	

scanPattern$5:	; input = £temporary1341
20:		mov [bp + 14], bl
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1342 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov al, [bp + 14]
27:		and ax, 255
29:		cmp al, 0
30:		jge scanPattern$8
31:		neg al
33:		neg ax
35:	

scanPattern$8:	; parameter £temporary1342, offset 6
36:		mov [bp + 21], ax
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1343 = return_value
51:	

scanPattern$12:	; if £temporary1343 == 0 goto 19
52:		cmp bx, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1344 = return_value
70:	

scanPattern$17:	; input = £temporary1344
71:		mov [bp + 14], bl
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov ax, [bp + 8]
88:		mov [bp + 21], ax
90:	

scanPattern$23:	; £temporary1349 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov al, [bp + 14]
93:		and ax, 255
95:		cmp al, 0
96:		jge scanPattern$24
97:		neg al
99:		neg ax
101:	

scanPattern$24:	; parameter £temporary1349, offset 8
102:		mov [bp + 23], ax
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1350 = return_value
117:	

scanPattern$28:	; if £temporary1350 != 0 goto 38
118:		cmp bx, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov ax, [bp + 8]
129:		mov [bp + 21], ax
131:	

scanPattern$32:	; £temporary1353 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov al, [bp + 14]
134:		and ax, 255
136:		cmp al, 0
137:		jge scanPattern$33
138:		neg al
140:		neg ax
142:	

scanPattern$33:	; parameter £temporary1353, offset 8
143:		mov [bp + 23], ax
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1354 = return_value
158:	

scanPattern$37:	; if £temporary1354 != 0 goto 49
159:		cmp bx, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1360 = index
163:		mov ax, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1362 = string + £temporary1360
169:		mov si, [bp + 6]
170:		add si, ax
172:	

scanPattern$41:	; £temporary1361 -> £temporary1362 = *£temporary1362
174:	

scanPattern$42:	; £temporary1361 -> £temporary1362 = input
175:		mov al, [bp + 14]
176:		mov [si], al
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1363 = return_value
193:	

scanPattern$47:	; input = £temporary1363
194:		mov [bp + 14], bl
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1365 = string + index
200:		mov si, [bp + 6]
201:		add si, [bp + 12]
203:	

scanPattern$50:	; £temporary1364 -> £temporary1365 = *£temporary1365
205:	

scanPattern$51:	; £temporary1364 -> £temporary1365 = 0
206:		mov byte [si], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov ax, [bp + 8]
219:		mov [bp + 21], ax
221:	

scanPattern$56:	; £temporary1368 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov al, [bp + 14]
224:		and ax, 255
226:		cmp al, 0
227:		jge scanPattern$57
228:		neg al
230:		neg ax
232:	

scanPattern$57:	; parameter £temporary1368, offset 8
233:		mov [bp + 23], ax
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1369 = return_value
248:	

scanPattern$61:	; if £temporary1369 != 0 goto 71
249:		cmp bx, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov ax, [bp + 8]
260:		mov [bp + 21], ax
262:	

scanPattern$65:	; £temporary1372 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov al, [bp + 14]
265:		and ax, 255
267:		cmp al, 0
268:		jge scanPattern$66
269:		neg al
271:		neg ax
273:	

scanPattern$66:	; parameter £temporary1372, offset 8
274:		mov [bp + 23], ax
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1373 = return_value
289:	

scanPattern$70:	; if £temporary1373 != 0 goto 77
290:		cmp bx, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1379 = return_value
308:	

scanPattern$75:	; input = £temporary1379
309:		mov [bp + 14], bl
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov ax, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp ax
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1389 = return_value
19:	

scanString$5:	; input = £temporary1389
20:		mov [bp + 12], bl
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1390 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 12]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanString$9
34:		neg al
36:		neg ax
38:	

scanString$9:	; parameter £temporary1390, offset 6
39:		mov [bp + 21], ax
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1391 = return_value
54:	

scanString$13:	; if £temporary1391 == 0 goto 20
55:		cmp bx, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1392 = return_value
73:	

scanString$18:	; input = £temporary1392
74:		mov [bp + 12], bl
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1396 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov al, [bp + 12]
92:		and ax, 255
94:		cmp al, 0
95:		jge scanString$24
96:		neg al
98:		neg ax
100:	

scanString$24:	; parameter £temporary1396, offset 6
101:		mov [bp + 21], ax
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1397 = return_value
116:	

scanString$28:	; if £temporary1397 != 0 goto 45
117:		cmp bx, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1400 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov al, [bp + 12]
123:		and ax, 255
125:		cmp al, 0
126:		jge scanString$30
127:		neg al
129:		neg ax
131:	

scanString$30:	; if £temporary1400 == -1 goto 45
132:		cmp ax, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1405 = index
140:		mov ax, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1407 = string + £temporary1405
146:		mov si, [bp + 6]
147:		add si, ax
149:	

scanString$35:	; £temporary1406 -> £temporary1407 = *£temporary1407
151:	

scanString$36:	; £temporary1406 -> £temporary1407 = input
152:		mov al, [bp + 12]
153:		mov [si], al
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1408 = return_value
170:	

scanString$41:	; input = £temporary1408
171:		mov [bp + 12], bl
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1411 = string + index
183:		mov si, [bp + 6]
184:		add si, [bp + 10]
186:	

scanString$46:	; £temporary1410 -> £temporary1411 = *£temporary1411
188:	

scanString$47:	; £temporary1410 -> £temporary1411 = 0
189:		mov byte [si], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1413 = precision
198:		mov ax, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1413 <= 0 goto 76
204:		cmp ax, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1415 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov al, [bp + 12]
212:		and ax, 255
214:		cmp al, 0
215:		jge scanString$55
216:		neg al
218:		neg ax
220:	

scanString$55:	; parameter £temporary1415, offset 6
221:		mov [bp + 21], ax
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1416 = return_value
236:	

scanString$59:	; if £temporary1416 != 0 goto 76
237:		cmp bx, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1419 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov al, [bp + 12]
243:		and ax, 255
245:		cmp al, 0
246:		jge scanString$61
247:		neg al
249:		neg ax
251:	

scanString$61:	; if £temporary1419 == -1 goto 76
252:		cmp ax, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1425 = index
260:		mov ax, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1427 = string + £temporary1425
266:		mov si, [bp + 6]
267:		add si, ax
269:	

scanString$66:	; £temporary1426 -> £temporary1427 = *£temporary1427
271:	

scanString$67:	; £temporary1426 -> £temporary1427 = input
272:		mov al, [bp + 12]
273:		mov [si], al
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1428 = return_value
290:	

scanString$72:	; input = £temporary1428
291:		mov [bp + 12], bl
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1432 = string + index
307:		mov si, [bp + 6]
308:		add si, [bp + 10]
310:	

scanString$78:	; £temporary1431 -> £temporary1432 = *£temporary1432
312:	

scanString$79:	; £temporary1431 -> £temporary1432 = 0
313:		mov byte [si], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1435 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov al, [bp + 12]
330:		and ax, 255
332:		cmp al, 0
333:		jge scanString$85
334:		neg al
336:		neg ax
338:	

scanString$85:	; parameter £temporary1435, offset 6
339:		mov [bp + 21], ax
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1436 = return_value
354:	

scanString$89:	; if £temporary1436 != 0 goto 101
355:		cmp bx, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1439 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov al, [bp + 12]
361:		and ax, 255
363:		cmp al, 0
364:		jge scanString$91
365:		neg al
367:		neg ax
369:	

scanString$91:	; if £temporary1439 == -1 goto 101
370:		cmp ax, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1444 = return_value
392:	

scanString$97:	; input = £temporary1444
393:		mov [bp + 12], bl
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1447 = precision
411:		mov ax, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1447 <= 0 goto 124
417:		cmp ax, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1449 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov al, [bp + 12]
425:		and ax, 255
427:		cmp al, 0
428:		jge scanString$108
429:		neg al
431:		neg ax
433:	

scanString$108:	; parameter £temporary1449, offset 6
434:		mov [bp + 21], ax
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1450 = return_value
449:	

scanString$112:	; if £temporary1450 != 0 goto 124
450:		cmp bx, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1453 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov al, [bp + 12]
456:		and ax, 255
458:		cmp al, 0
459:		jge scanString$114
460:		neg al
462:		neg ax
464:	

scanString$114:	; if £temporary1453 == -1 goto 124
465:		cmp ax, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1459 = return_value
487:	

scanString$120:	; input = £temporary1459
488:		mov [bp + 12], bl
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov ax, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp ax
519:	

scanString$129:	; function end scanString
1:	

digitToValue:	; call header integral zero 0 stack zero 0
3:	

digitToValue$1:	; £temporary1470 = int_to_int input (Signed_Char -> Signed_Int)
4:		mov al, [bp + 6]
6:		and ax, 255
8:		cmp al, 0
9:		jge digitToValue$2
10:		neg al
12:		neg ax
14:	

digitToValue$2:	; parameter £temporary1470, offset 6
15:		mov [bp + 13], ax
17:	

digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

digitToValue$4:	; post call
25:	

digitToValue$5:	; £temporary1471 = return_value
30:	

digitToValue$6:	; if £temporary1471 == 0 goto 11
31:		cmp bx, 0
32:		je digitToValue$11
34:	

digitToValue$7:	; £temporary1472 = input - 48
35:		mov bl, [bp + 6]
36:		sub bl, 48
38:	

digitToValue$8:	; £temporary1473 = int_to_int £temporary1472 (Signed_Char -> Unsigned_Long_Int)
40:		and ebx, 255
42:	

digitToValue$9:	; return_value = £temporary1473
44:	

digitToValue$10:	; return
45:		mov ax, [bp]
46:		mov di, [bp + 4]
47:		mov bp, [bp + 2]
48:		jmp ax
50:	

digitToValue$11:	; call header integral zero 0 stack zero 0
52:	

digitToValue$12:	; £temporary1474 = int_to_int input (Signed_Char -> Signed_Int)
53:		mov al, [bp + 6]
55:		and ax, 255
57:		cmp al, 0
58:		jge digitToValue$13
59:		neg al
61:		neg ax
63:	

digitToValue$13:	; parameter £temporary1474, offset 6
64:		mov [bp + 13], ax
66:	

digitToValue$14:	; call function noellipse-noellipse islower
67:		mov word [bp + 7], digitToValue$15
68:		mov [bp + 9], bp
69:		add bp, 7
70:		jmp islower
72:	

digitToValue$15:	; post call
74:	

digitToValue$16:	; £temporary1475 = return_value
79:	

digitToValue$17:	; if £temporary1475 == 0 goto 23
80:		cmp bx, 0
81:		je digitToValue$23
83:	

digitToValue$18:	; £temporary1476 = input - 97
84:		mov bl, [bp + 6]
85:		sub bl, 97
87:	

digitToValue$19:	; £temporary1477 = int_to_int £temporary1476 (Signed_Char -> Unsigned_Long_Int)
89:		and ebx, 255
91:	

digitToValue$20:	; £temporary1478 = £temporary1477 + 10
92:		add ebx, 10
94:	

digitToValue$21:	; return_value = £temporary1478
96:	

digitToValue$22:	; return
97:		mov ax, [bp]
98:		mov di, [bp + 4]
99:		mov bp, [bp + 2]
100:		jmp ax
102:	

digitToValue$23:	; £temporary1479 = input - 65
103:		mov bl, [bp + 6]
104:		sub bl, 65
106:	

digitToValue$24:	; £temporary1480 = int_to_int £temporary1479 (Signed_Char -> Unsigned_Long_Int)
108:		and ebx, 255
110:	

digitToValue$25:	; £temporary1481 = £temporary1480 + 10
111:		add ebx, 10
113:	

digitToValue$26:	; return_value = £temporary1481
115:	

digitToValue$27:	; return
116:		mov ax, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp ax
121:	

digitToValue$28:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 6], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 10], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 12], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 14], scanLongInt$5
14:		mov [bp + 16], bp
15:		add bp, 14
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1486 = return_value
25:	

scanLongInt$7:	; input = £temporary1486
26:		mov [bp + 14], bl
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1487 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov al, [bp + 14]
33:		and ax, 255
35:		cmp al, 0
36:		jge scanLongInt$10
37:		neg al
39:		neg ax
41:	

scanLongInt$10:	; parameter £temporary1487, offset 6
42:		mov [bp + 21], ax
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 15], scanLongInt$12
46:		mov [bp + 17], bp
47:		add bp, 15
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1488 = return_value
57:	

scanLongInt$14:	; if £temporary1488 == 0 goto 21
58:		cmp bx, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 15], scanLongInt$17
65:		mov [bp + 17], bp
66:		add bp, 15
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1489 = return_value
76:	

scanLongInt$19:	; input = £temporary1489
77:		mov [bp + 14], bl
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 14], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 15], scanLongInt$24
90:		mov [bp + 17], bp
91:		add bp, 15
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1492 = return_value
101:	

scanLongInt$26:	; input = £temporary1492
102:		mov [bp + 14], bl
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 14], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 10], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 15], scanLongInt$32
118:		mov [bp + 17], bp
119:		add bp, 15
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1494 = return_value
129:	

scanLongInt$34:	; input = £temporary1494
130:		mov [bp + 14], bl
132:	

scanLongInt$35:	; call header integral zero 0 stack zero 0
134:	

scanLongInt$36:	; £temporary1495 = int_to_int input (Signed_Char -> Signed_Int)
135:		mov al, [bp + 14]
137:		and ax, 255
139:		cmp al, 0
140:		jge scanLongInt$37
141:		neg al
143:		neg ax
145:	

scanLongInt$37:	; parameter £temporary1495, offset 6
146:		mov [bp + 21], ax
148:	

scanLongInt$38:	; call function noellipse-noellipse isdigit
149:		mov word [bp + 15], scanLongInt$39
150:		mov [bp + 17], bp
151:		add bp, 15
152:		jmp isdigit
154:	

scanLongInt$39:	; post call
156:	

scanLongInt$40:	; £temporary1496 = return_value
161:	

scanLongInt$41:	; if £temporary1496 == 0 goto 54
162:		cmp bx, 0
163:		je scanLongInt$54
165:	

scanLongInt$42:	; £temporary1497 = longValue * 10
166:		mov eax, [bp + 6]
168:		xor edx, edx
169:		imul dword [int4$10#]
175:	

scanLongInt$43:	; £temporary1498 = input - 48
176:		mov bl, [bp + 14]
177:		sub bl, 48
179:	

scanLongInt$44:	; £temporary1499 = int_to_int £temporary1498 (Signed_Char -> Signed_Long_Int)
181:		and ebx, 255
183:		cmp bl, 0
184:		jge scanLongInt$45
185:		neg bl
187:		neg ebx
189:	

scanLongInt$45:	; £temporary1500 = £temporary1497 + £temporary1499
190:		add eax, ebx
192:	

scanLongInt$46:	; longValue = £temporary1500
193:		mov [bp + 6], eax
195:	

scanLongInt$47:	; call header integral zero 0 stack zero 0
197:	

scanLongInt$48:	; call function noellipse-noellipse scanChar
198:		mov word [bp + 15], scanLongInt$49
199:		mov [bp + 17], bp
200:		add bp, 15
201:		jmp scanChar
203:	

scanLongInt$49:	; post call
205:	

scanLongInt$50:	; £temporary1501 = return_value
210:	

scanLongInt$51:	; input = £temporary1501
211:		mov [bp + 14], bl
213:	

scanLongInt$52:	; found = 1
214:		mov word [bp + 12], 1
216:	

scanLongInt$53:	; goto 35
217:		jmp scanLongInt$35
219:	

scanLongInt$54:	; if minus == 0 goto 57
220:		cmp word [bp + 10], 0
221:		je scanLongInt$57
223:	

scanLongInt$55:	; £temporary1503 = -longValue
224:		mov eax, [bp + 6]
225:		neg eax
227:	

scanLongInt$56:	; longValue = £temporary1503
228:		mov [bp + 6], eax
230:	

scanLongInt$57:	; if found == 0 goto 59
231:		cmp word [bp + 12], 0
232:		je scanLongInt$59
234:	

scanLongInt$58:	; ++g_inCount
235:		inc word [g_inCount]
237:	

scanLongInt$59:	; call header integral zero 0 stack zero 0
239:	

scanLongInt$60:	; parameter input, offset 6
240:		mov al, [bp + 14]
241:		mov [bp + 21], al
243:	

scanLongInt$61:	; call function noellipse-noellipse unscanChar
244:		mov word [bp + 15], scanLongInt$62
245:		mov [bp + 17], bp
246:		add bp, 15
247:		jmp unscanChar
249:	

scanLongInt$62:	; post call
251:	

scanLongInt$63:	; return_value = longValue
252:		mov ebx, [bp + 6]
254:	

scanLongInt$64:	; return
255:		mov ax, [bp]
256:		mov di, [bp + 4]
257:		mov bp, [bp + 2]
258:		jmp ax
260:	

scanLongInt$65:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 10], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 18], scanUnsignedLongInt$3
8:		mov [bp + 20], bp
9:		add bp, 18
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1511 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1511
20:		mov [bp + 18], bl
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 19], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1512 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 18]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanUnsignedLongInt$9
34:		neg al
36:		neg ax
38:	

scanUnsignedLongInt$9:	; parameter £temporary1512, offset 6
39:		mov [bp + 27], ax
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 21], scanUnsignedLongInt$11
43:		mov [bp + 23], bp
44:		add bp, 21
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1513 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1513 == 0 goto 20
55:		cmp bx, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 21], scanUnsignedLongInt$16
62:		mov [bp + 23], bp
63:		add bp, 21
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1514 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1514
74:		mov [bp + 18], bl
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 48 goto 49
80:		cmp byte [bp + 18], 48
81:		jne scanUnsignedLongInt$49
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 21], scanUnsignedLongInt$23
87:		mov [bp + 23], bp
88:		add bp, 21
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1517 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1517
99:		mov [bp + 18], bl
101:	

scanUnsignedLongInt$26:	; call header integral zero 0 stack zero 0
103:	

scanUnsignedLongInt$27:	; £temporary1518 = int_to_int input (Signed_Char -> Signed_Int)
104:		mov al, [bp + 18]
106:		and ax, 255
108:		cmp al, 0
109:		jge scanUnsignedLongInt$28
110:		neg al
112:		neg ax
114:	

scanUnsignedLongInt$28:	; parameter £temporary1518, offset 6
115:		mov [bp + 27], ax
117:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse tolower
118:		mov word [bp + 21], scanUnsignedLongInt$30
119:		mov [bp + 23], bp
120:		add bp, 21
121:		jmp tolower
123:	

scanUnsignedLongInt$30:	; post call
125:	

scanUnsignedLongInt$31:	; £temporary1519 = return_value
130:	

scanUnsignedLongInt$32:	; if £temporary1519 != 120 goto 44
131:		cmp bx, 120
132:		jne scanUnsignedLongInt$44
134:	

scanUnsignedLongInt$33:	; if base != 0 goto 36
135:		cmp dword [bp + 6], 0
136:		jne scanUnsignedLongInt$36
138:	

scanUnsignedLongInt$34:	; £temporary1525 = 16
139:		mov eax, 16
141:	

scanUnsignedLongInt$35:	; goto 37
142:		jmp scanUnsignedLongInt$37
144:	

scanUnsignedLongInt$36:	; £temporary1525 = base
145:		mov eax, [bp + 6]
147:	

scanUnsignedLongInt$37:	; base = £temporary1525
148:		mov [bp + 6], eax
150:	

scanUnsignedLongInt$38:	; call header integral zero 0 stack zero 0
152:	

scanUnsignedLongInt$39:	; call function noellipse-noellipse scanChar
153:		mov word [bp + 21], scanUnsignedLongInt$40
154:		mov [bp + 23], bp
155:		add bp, 21
156:		jmp scanChar
158:	

scanUnsignedLongInt$40:	; post call
160:	

scanUnsignedLongInt$41:	; £temporary1526 = return_value
165:	

scanUnsignedLongInt$42:	; input = £temporary1526
166:		mov [bp + 18], bl
168:	

scanUnsignedLongInt$43:	; goto 49
169:		jmp scanUnsignedLongInt$49
171:	

scanUnsignedLongInt$44:	; if base != 0 goto 47
172:		cmp dword [bp + 6], 0
173:		jne scanUnsignedLongInt$47
175:	

scanUnsignedLongInt$45:	; £temporary1531 = 8
176:		mov eax, 8
178:	

scanUnsignedLongInt$46:	; goto 48
179:		jmp scanUnsignedLongInt$48
181:	

scanUnsignedLongInt$47:	; £temporary1531 = base
182:		mov eax, [bp + 6]
184:	

scanUnsignedLongInt$48:	; base = £temporary1531
185:		mov [bp + 6], eax
187:	

scanUnsignedLongInt$49:	; if base != 0 goto 51
188:		cmp dword [bp + 6], 0
189:		jne scanUnsignedLongInt$51
191:	

scanUnsignedLongInt$50:	; base = 10
192:		mov dword [bp + 6], 10
194:	

scanUnsignedLongInt$51:	; call header integral zero 0 stack zero 0
196:	

scanUnsignedLongInt$52:	; £temporary1533 = int_to_int input (Signed_Char -> Signed_Int)
197:		mov al, [bp + 18]
199:		and ax, 255
201:		cmp al, 0
202:		jge scanUnsignedLongInt$53
203:		neg al
205:		neg ax
207:	

scanUnsignedLongInt$53:	; parameter £temporary1533, offset 6
208:		mov [bp + 27], ax
210:	

scanUnsignedLongInt$54:	; call function noellipse-noellipse isxdigit
211:		mov word [bp + 21], scanUnsignedLongInt$55
212:		mov [bp + 23], bp
213:		add bp, 21
214:		jmp isxdigit
216:	

scanUnsignedLongInt$55:	; post call
218:	

scanUnsignedLongInt$56:	; £temporary1534 = return_value
223:	

scanUnsignedLongInt$57:	; if £temporary1534 == 0 goto 75
224:		cmp bx, 0
225:		je scanUnsignedLongInt$75
227:	

scanUnsignedLongInt$58:	; call header integral zero 0 stack zero 0
229:	

scanUnsignedLongInt$59:	; parameter input, offset 6
230:		mov al, [bp + 18]
231:		mov [bp + 27], al
233:	

scanUnsignedLongInt$60:	; call function noellipse-noellipse digitToValue
234:		mov word [bp + 21], scanUnsignedLongInt$61
235:		mov [bp + 23], bp
236:		add bp, 21
237:		jmp digitToValue
239:	

scanUnsignedLongInt$61:	; post call
241:	

scanUnsignedLongInt$62:	; £temporary1535 = return_value
246:	

scanUnsignedLongInt$63:	; digit = £temporary1535
247:		mov [bp + 14], ebx
249:	

scanUnsignedLongInt$64:	; if digit >= base goto 75
250:		mov eax, [bp + 14]
251:		cmp eax, [bp + 6]
252:		jae scanUnsignedLongInt$75
254:	

scanUnsignedLongInt$65:	; £temporary1537 = unsignedLongValue * base
255:		mov eax, [bp + 10]
257:		xor edx, edx
258:		mul dword [bp + 6]
264:	

scanUnsignedLongInt$66:	; £temporary1538 = £temporary1537 + digit
265:		add eax, [bp + 14]
267:	

scanUnsignedLongInt$67:	; unsignedLongValue = £temporary1538
268:		mov [bp + 10], eax
270:	

scanUnsignedLongInt$68:	; found = 1
271:		mov word [bp + 19], 1
273:	

scanUnsignedLongInt$69:	; call header integral zero 0 stack zero 0
275:	

scanUnsignedLongInt$70:	; call function noellipse-noellipse scanChar
276:		mov word [bp + 21], scanUnsignedLongInt$71
277:		mov [bp + 23], bp
278:		add bp, 21
279:		jmp scanChar
281:	

scanUnsignedLongInt$71:	; post call
283:	

scanUnsignedLongInt$72:	; £temporary1539 = return_value
288:	

scanUnsignedLongInt$73:	; input = £temporary1539
289:		mov [bp + 18], bl
291:	

scanUnsignedLongInt$74:	; goto 51
292:		jmp scanUnsignedLongInt$51
294:	

scanUnsignedLongInt$75:	; if found == 0 goto 77
295:		cmp word [bp + 19], 0
296:		je scanUnsignedLongInt$77
298:	

scanUnsignedLongInt$76:	; ++g_inCount
299:		inc word [g_inCount]
301:	

scanUnsignedLongInt$77:	; call header integral zero 0 stack zero 0
303:	

scanUnsignedLongInt$78:	; parameter input, offset 6
304:		mov al, [bp + 18]
305:		mov [bp + 27], al
307:	

scanUnsignedLongInt$79:	; call function noellipse-noellipse unscanChar
308:		mov word [bp + 21], scanUnsignedLongInt$80
309:		mov [bp + 23], bp
310:		add bp, 21
311:		jmp unscanChar
313:	

scanUnsignedLongInt$80:	; post call
315:	

scanUnsignedLongInt$81:	; return_value = unsignedLongValue
316:		mov ebx, [bp + 10]
318:	

scanUnsignedLongInt$82:	; return
319:		mov ax, [bp]
320:		mov di, [bp + 4]
321:		mov bp, [bp + 2]
322:		jmp ax
324:	

scanUnsignedLongInt$83:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1549 = return_value
34:	

scanLongDouble$10:	; input = £temporary1549
35:		mov [bp + 26], bl
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1550 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov al, [bp + 26]
42:		and ax, 255
44:		cmp al, 0
45:		jge scanLongDouble$13
46:		neg al
48:		neg ax
50:	

scanLongDouble$13:	; parameter £temporary1550, offset 6
51:		mov [bp + 33], ax
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1551 = return_value
66:	

scanLongDouble$17:	; if £temporary1551 == 0 goto 24
67:		cmp bx, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1552 = return_value
85:	

scanLongDouble$22:	; input = £temporary1552
86:		mov [bp + 26], bl
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1555 = return_value
110:	

scanLongDouble$29:	; input = £temporary1555
111:		mov [bp + 26], bl
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1557 = return_value
138:	

scanLongDouble$37:	; input = £temporary1557
139:		mov [bp + 26], bl
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1558 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov al, [bp + 26]
146:		and ax, 255
148:		cmp al, 0
149:		jge scanLongDouble$40
150:		neg al
152:		neg ax
154:	

scanLongDouble$40:	; parameter £temporary1558, offset 6
155:		mov [bp + 33], ax
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1559 = return_value
170:	

scanLongDouble$44:	; if £temporary1559 == 0 goto 60
171:		cmp bx, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1560 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1561 = input - 48
184:		mov al, [bp + 26]
185:		sub al, 48
187:	

scanLongDouble$49:	; £temporary1563 = int_to_int £temporary1561 (Signed_Char -> Signed_Int)
189:		and ax, 255
191:		cmp al, 0
192:		jge scanLongDouble$50
193:		neg al
195:		neg ax
197:	

scanLongDouble$50:	; £temporary1562 = int_to_float £temporary1563 (Signed_Int -> Long_Double)
198:		mov [$IntegralStorage#], ax
199:		fild word [$IntegralStorage#]
201:	

scanLongDouble$51:	; £temporary1564 = £temporary1560 + £temporary1562
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1565 = return_value
222:	

scanLongDouble$57:	; input = £temporary1565
223:		mov [bp + 26], bl
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1568 = return_value
250:	

scanLongDouble$65:	; input = £temporary1568
251:		mov [bp + 26], bl
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1569 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov al, [bp + 26]
258:		and ax, 255
260:		cmp al, 0
261:		jge scanLongDouble$68
262:		neg al
264:		neg ax
266:	

scanLongDouble$68:	; parameter £temporary1569, offset 6
267:		mov [bp + 33], ax
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1570 = return_value
282:	

scanLongDouble$72:	; if £temporary1570 == 0 goto 92
283:		cmp bx, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1571 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1572 = input - 48
305:		mov al, [bp + 26]
306:		sub al, 48
308:	

scanLongDouble$80:	; £temporary1574 = int_to_int £temporary1572 (Signed_Char -> Signed_Int)
310:		and ax, 255
312:		cmp al, 0
313:		jge scanLongDouble$81
314:		neg al
316:		neg ax
318:	

scanLongDouble$81:	; £temporary1573 = int_to_float £temporary1574 (Signed_Int -> Long_Double)
319:		mov [$IntegralStorage#], ax
320:		fild word [$IntegralStorage#]
322:	

scanLongDouble$82:	; £temporary1575 = factor * £temporary1573
323:		fmul
325:	

scanLongDouble$83:	; £temporary1576 = value + £temporary1575
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1577 = return_value
346:	

scanLongDouble$89:	; input = £temporary1577
347:		mov [bp + 26], bl
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; parameter input, offset 6
358:		mov al, [bp + 26]
359:		mov [bp + 33], al
361:	

scanLongDouble$94:	; call function noellipse-noellipse unscanChar
362:		mov word [bp + 27], scanLongDouble$95
363:		mov [bp + 29], bp
364:		add bp, 27
365:		jmp unscanChar
367:	

scanLongDouble$95:	; post call
369:	

scanLongDouble$96:	; call header integral zero 0 stack zero 0
371:	

scanLongDouble$97:	; £temporary1580 = int_to_int input (Signed_Char -> Signed_Int)
372:		mov al, [bp + 26]
374:		and ax, 255
376:		cmp al, 0
377:		jge scanLongDouble$98
378:		neg al
380:		neg ax
382:	

scanLongDouble$98:	; parameter £temporary1580, offset 6
383:		mov [bp + 33], ax
385:	

scanLongDouble$99:	; call function noellipse-noellipse tolower
386:		mov word [bp + 27], scanLongDouble$100
387:		mov [bp + 29], bp
388:		add bp, 27
389:		jmp tolower
391:	

scanLongDouble$100:	; post call
393:	

scanLongDouble$101:	; £temporary1581 = return_value
398:	

scanLongDouble$102:	; if £temporary1581 != 101 goto 121
399:		cmp bx, 101
400:		jne scanLongDouble$121
402:	

scanLongDouble$103:	; call header integral zero 0 stack zero 0
404:	

scanLongDouble$104:	; call function noellipse-noellipse scanLongInt
405:		mov word [bp + 27], scanLongDouble$105
406:		mov [bp + 29], bp
407:		add bp, 27
408:		jmp scanLongInt
410:	

scanLongDouble$105:	; post call
412:	

scanLongDouble$106:	; £temporary1583 = return_value
417:	

scanLongDouble$107:	; £temporary1584 = int_to_float £temporary1583 (Signed_Long_Int -> Double)
418:		mov [$IntegralStorage#], ebx
419:		fild dword [$IntegralStorage#]
421:	

scanLongDouble$108:	; pop float exponent
422:		fstp qword [bp + 27]
424:	

scanLongDouble$109:	; push float value
425:		fld qword [bp + 10]
427:	

scanLongDouble$110:	; call header integral zero 0 stack no zero 1
428:		fstp qword [bp + 35]
430:	

scanLongDouble$111:	; push float 10.0
431:		fld qword [float8$10.0#]
433:	

scanLongDouble$112:	; parameter 10.0, offset 6
434:		fstp qword [bp + 49]
436:	

scanLongDouble$113:	; push float exponent
437:		fld qword [bp + 27]
439:	

scanLongDouble$114:	; parameter exponent, offset 14
440:		fstp qword [bp + 57]
442:	

scanLongDouble$115:	; call function noellipse-noellipse pow
443:		mov word [bp + 43], scanLongDouble$116
444:		mov [bp + 45], bp
445:		add bp, 43
446:		jmp pow
448:	

scanLongDouble$116:	; post call
449:		fstp qword [bp + 43]
450:		fld qword [bp + 35]
451:		fld qword [bp + 43]
453:	

scanLongDouble$117:	; £temporary1585 = return_value
455:	

scanLongDouble$118:	; £temporary1586 = value * £temporary1585
456:		fmul
458:	

scanLongDouble$119:	; pop float value
459:		fstp qword [bp + 10]
461:	

scanLongDouble$120:	; goto 125
462:		jmp scanLongDouble$125
464:	

scanLongDouble$121:	; call header integral zero 0 stack zero 0
466:	

scanLongDouble$122:	; parameter input, offset 6
467:		mov al, [bp + 26]
468:		mov [bp + 33], al
470:	

scanLongDouble$123:	; call function noellipse-noellipse unscanChar
471:		mov word [bp + 27], scanLongDouble$124
472:		mov [bp + 29], bp
473:		add bp, 27
474:		jmp unscanChar
476:	

scanLongDouble$124:	; post call
478:	

scanLongDouble$125:	; if minus == 0 goto 129
479:		cmp word [bp + 6], 0
480:		je scanLongDouble$129
482:	

scanLongDouble$126:	; push float value
483:		fld qword [bp + 10]
485:	

scanLongDouble$127:	; £temporary1588 = -value
486:		fchs
488:	

scanLongDouble$128:	; pop float value
489:		fstp qword [bp + 10]
491:	

scanLongDouble$129:	; if found == 0 goto 131
492:		cmp word [bp + 8], 0
493:		je scanLongDouble$131
495:	

scanLongDouble$130:	; ++g_inCount
496:		inc word [g_inCount]
498:	

scanLongDouble$131:	; push float value
499:		fld qword [bp + 10]
501:	

scanLongDouble$132:	; return_value = value
503:	

scanLongDouble$133:	; return
504:		mov ax, [bp]
505:		mov di, [bp + 4]
506:		mov bp, [bp + 2]
507:		jmp ax
509:	

scanLongDouble$134:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1601 = format + index
26:		mov si, [bp + 6]
27:		add si, [bp + 31]
29:	

scanFormat$9:	; £temporary1600 -> £temporary1601 = *£temporary1601
31:	

scanFormat$10:	; if £temporary1600 -> £temporary1601 == 0 goto 346
32:		cmp byte [si], 0
33:		je scanFormat$346
35:	

scanFormat$11:	; £temporary1605 = format + index
36:		mov si, [bp + 6]
37:		add si, [bp + 31]
39:	

scanFormat$12:	; £temporary1604 -> £temporary1605 = *£temporary1605
41:	

scanFormat$13:	; c = £temporary1604 -> £temporary1605
42:		mov al, [si]
43:		mov [bp + 10], al
45:	

scanFormat$14:	; £temporary1606 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov al, [bp + 10]
48:		and ax, 255
50:		cmp al, 0
51:		jge scanFormat$15
52:		neg al
54:		neg ax
56:	

scanFormat$15:	; £temporary1607 = £temporary1606 + 1
57:		add ax, 1
59:	

scanFormat$16:	; d = £temporary1607
60:		mov [bp + 55], ax
62:	

scanFormat$17:	; if percent == 0 goto 338
63:		cmp word [bp + 13], 0
64:		je scanFormat$338
66:	

scanFormat$18:	; £temporary1608 = d - 1
67:		mov ax, [bp + 55]
68:		sub ax, 1
70:	

scanFormat$19:	; case £temporary1608 == 104 goto 37
71:		cmp ax, 104
72:		je scanFormat$37
74:	

scanFormat$20:	; case £temporary1608 == 108 goto 39
75:		cmp ax, 108
76:		je scanFormat$39
78:	

scanFormat$21:	; case £temporary1608 == 76 goto 41
79:		cmp ax, 76
80:		je scanFormat$41
82:	

scanFormat$22:	; case £temporary1608 == 42 goto 43
83:		cmp ax, 42
84:		je scanFormat$43
86:	

scanFormat$23:	; case £temporary1608 == 99 goto 45
87:		cmp ax, 99
88:		je scanFormat$45
90:	

scanFormat$24:	; case £temporary1608 == 115 goto 64
91:		cmp ax, 115
92:		je scanFormat$64
94:	

scanFormat$25:	; case £temporary1608 == 100 goto 84
95:		cmp ax, 100
96:		je scanFormat$84
98:	

scanFormat$26:	; case £temporary1608 == 105 goto 84
99:		cmp ax, 105
100:		je scanFormat$84
102:	

scanFormat$27:	; case £temporary1608 == 111 goto 122
103:		cmp ax, 111
104:		je scanFormat$122
106:	

scanFormat$28:	; case £temporary1608 == 120 goto 161
107:		cmp ax, 120
108:		je scanFormat$161
110:	

scanFormat$29:	; case £temporary1608 == 117 goto 200
111:		cmp ax, 117
112:		je scanFormat$200
114:	

scanFormat$30:	; case £temporary1608 == 103 goto 239
115:		cmp ax, 103
116:		je scanFormat$239
118:	

scanFormat$31:	; case £temporary1608 == 102 goto 239
119:		cmp ax, 102
120:		je scanFormat$239
122:	

scanFormat$32:	; case £temporary1608 == 101 goto 239
123:		cmp ax, 101
124:		je scanFormat$239
126:	

scanFormat$33:	; case £temporary1608 == 91 goto 278
127:		cmp ax, 91
128:		je scanFormat$278
130:	

scanFormat$34:	; case £temporary1608 == 110 goto 321
131:		cmp ax, 110
132:		je scanFormat$321
134:	

scanFormat$35:	; case end £temporary1608
136:	

scanFormat$36:	; goto 331
137:		jmp scanFormat$331
139:	

scanFormat$37:	; shortInt = 1
140:		mov word [bp + 15], 1
142:	

scanFormat$38:	; goto 344
143:		jmp scanFormat$344
145:	

scanFormat$39:	; longIntOrDouble = 1
146:		mov word [bp + 17], 1
148:	

scanFormat$40:	; goto 344
149:		jmp scanFormat$344
151:	

scanFormat$41:	; longDouble = 1
152:		mov word [bp + 19], 1
154:	

scanFormat$42:	; goto 344
155:		jmp scanFormat$344
157:	

scanFormat$43:	; star = 1
158:		mov word [bp + 21], 1
160:	

scanFormat$44:	; goto 344
161:		jmp scanFormat$344
163:	

scanFormat$45:	; call header integral zero 0 stack zero 0
165:	

scanFormat$46:	; call function noellipse-noellipse scanChar
166:		mov word [bp + 57], scanFormat$47
167:		mov [bp + 59], bp
168:		add bp, 57
169:		jmp scanChar
171:	

scanFormat$47:	; post call
173:	

scanFormat$48:	; £temporary1609 = return_value
178:	

scanFormat$49:	; charValue = £temporary1609
179:		mov [bp + 57], bl
181:	

scanFormat$50:	; if star != 0 goto 59
182:		cmp word [bp + 21], 0
183:		jne scanFormat$59
185:	

scanFormat$51:	; £temporary1612 = arg_list + 2
186:		mov ax, [bp + 8]
187:		add ax, 2
189:	

scanFormat$52:	; arg_list = £temporary1612
190:		mov [bp + 8], ax
192:	

scanFormat$53:	; £temporary1613 = arg_list - 2
193:		mov si, [bp + 8]
194:		sub si, 2
196:	

scanFormat$54:	; £temporary1614 = int_to_int £temporary1613 (Signed_Int -> Pointer)
199:	

scanFormat$55:	; £temporary1615 -> £temporary1614 = *£temporary1614
201:	

scanFormat$56:	; charPtr = £temporary1615 -> £temporary1614
202:		mov ax, [si]
203:		mov [bp + 11], ax
205:	

scanFormat$57:	; £temporary1616 -> charPtr = *charPtr
206:		mov si, [bp + 11]
208:	

scanFormat$58:	; £temporary1616 -> charPtr = charValue
209:		mov al, [bp + 57]
210:		mov [si], al
212:	

scanFormat$59:	; percent = 0
213:		mov word [bp + 13], 0
215:	

scanFormat$60:	; £temporary1617 = int_to_int charValue (Signed_Char -> Signed_Int)
216:		mov al, [bp + 57]
218:		and ax, 255
220:		cmp al, 0
221:		jge scanFormat$61
222:		neg al
224:		neg ax
226:	

scanFormat$61:	; if £temporary1617 == -1 goto 344
227:		cmp ax, -1
228:		je scanFormat$344
230:	

scanFormat$62:	; ++g_inCount
231:		inc word [g_inCount]
233:	

scanFormat$63:	; goto 344
234:		jmp scanFormat$344
236:	

scanFormat$64:	; if star != 0 goto 77
237:		cmp word [bp + 21], 0
238:		jne scanFormat$77
240:	

scanFormat$65:	; £temporary1622 = arg_list + 2
241:		mov ax, [bp + 8]
242:		add ax, 2
244:	

scanFormat$66:	; arg_list = £temporary1622
245:		mov [bp + 8], ax
247:	

scanFormat$67:	; £temporary1623 = arg_list - 2
248:		mov si, [bp + 8]
249:		sub si, 2
251:	

scanFormat$68:	; £temporary1624 = int_to_int £temporary1623 (Signed_Int -> Pointer)
254:	

scanFormat$69:	; £temporary1625 -> £temporary1624 = *£temporary1624
256:	

scanFormat$70:	; charPtr = £temporary1625 -> £temporary1624
257:		mov ax, [si]
258:		mov [bp + 11], ax
260:	

scanFormat$71:	; call header integral zero 0 stack zero 0
262:	

scanFormat$72:	; parameter charPtr, offset 6
263:		mov ax, [bp + 11]
264:		mov [bp + 63], ax
266:	

scanFormat$73:	; parameter 0, offset 8
267:		mov word [bp + 65], 0
269:	

scanFormat$74:	; call function noellipse-noellipse scanString
270:		mov word [bp + 57], scanFormat$75
271:		mov [bp + 59], bp
272:		add bp, 57
273:		jmp scanString
275:	

scanFormat$75:	; post call
277:	

scanFormat$76:	; goto 82
278:		jmp scanFormat$82
280:	

scanFormat$77:	; call header integral zero 0 stack zero 0
282:	

scanFormat$78:	; parameter 0, offset 6
283:		mov word [bp + 63], 0
285:	

scanFormat$79:	; parameter 0, offset 8
286:		mov word [bp + 65], 0
288:	

scanFormat$80:	; call function noellipse-noellipse scanString
289:		mov word [bp + 57], scanFormat$81
290:		mov [bp + 59], bp
291:		add bp, 57
292:		jmp scanString
294:	

scanFormat$81:	; post call
296:	

scanFormat$82:	; percent = 0
297:		mov word [bp + 13], 0
299:	

scanFormat$83:	; goto 344
300:		jmp scanFormat$344
302:	

scanFormat$84:	; call header integral zero 0 stack zero 0
304:	

scanFormat$85:	; call function noellipse-noellipse scanLongInt
305:		mov word [bp + 57], scanFormat$86
306:		mov [bp + 59], bp
307:		add bp, 57
308:		jmp scanLongInt
310:	

scanFormat$86:	; post call
312:	

scanFormat$87:	; £temporary1628 = return_value
317:	

scanFormat$88:	; longValue = £temporary1628
318:		mov [bp + 23], ebx
320:	

scanFormat$89:	; if star != 0 goto 120
321:		cmp word [bp + 21], 0
322:		jne scanFormat$120
324:	

scanFormat$90:	; if shortInt == 0 goto 101
325:		cmp word [bp + 15], 0
326:		je scanFormat$101
328:	

scanFormat$91:	; £temporary1631 = arg_list + 2
329:		mov ax, [bp + 8]
330:		add ax, 2
332:	

scanFormat$92:	; arg_list = £temporary1631
333:		mov [bp + 8], ax
335:	

scanFormat$93:	; £temporary1632 = arg_list - 2
336:		mov si, [bp + 8]
337:		sub si, 2
339:	

scanFormat$94:	; £temporary1633 = int_to_int £temporary1632 (Signed_Int -> Pointer)
342:	

scanFormat$95:	; £temporary1634 -> £temporary1633 = *£temporary1633
344:	

scanFormat$96:	; shortPtr = £temporary1634 -> £temporary1633
345:		mov ax, [si]
346:		mov [bp + 29], ax
348:	

scanFormat$97:	; £temporary1635 -> shortPtr = *shortPtr
349:		mov si, [bp + 29]
351:	

scanFormat$98:	; £temporary1636 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
352:		mov eax, [bp + 23]
355:		cmp eax, 0
356:		jge scanFormat$99
357:		neg eax
359:		neg al
361:	

scanFormat$99:	; £temporary1635 -> shortPtr = £temporary1636
362:		mov [si], al
364:	

scanFormat$100:	; goto 120
365:		jmp scanFormat$120
367:	

scanFormat$101:	; if longIntOrDouble != 0 goto 112
368:		cmp word [bp + 17], 0
369:		jne scanFormat$112
371:	

scanFormat$102:	; £temporary1639 = arg_list + 2
372:		mov ax, [bp + 8]
373:		add ax, 2
375:	

scanFormat$103:	; arg_list = £temporary1639
376:		mov [bp + 8], ax
378:	

scanFormat$104:	; £temporary1640 = arg_list - 2
379:		mov si, [bp + 8]
380:		sub si, 2
382:	

scanFormat$105:	; £temporary1641 = int_to_int £temporary1640 (Signed_Int -> Pointer)
385:	

scanFormat$106:	; £temporary1642 -> £temporary1641 = *£temporary1641
387:	

scanFormat$107:	; intPtr = £temporary1642 -> £temporary1641
388:		mov ax, [si]
389:		mov [bp + 33], ax
391:	

scanFormat$108:	; £temporary1643 -> intPtr = *intPtr
392:		mov si, [bp + 33]
394:	

scanFormat$109:	; £temporary1644 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
395:		mov eax, [bp + 23]
398:		cmp eax, 0
399:		jge scanFormat$110
400:		neg eax
402:		neg ax
404:	

scanFormat$110:	; £temporary1643 -> intPtr = £temporary1644
405:		mov [si], ax
407:	

scanFormat$111:	; goto 120
408:		jmp scanFormat$120
410:	

scanFormat$112:	; £temporary1645 = arg_list + 2
411:		mov ax, [bp + 8]
412:		add ax, 2
414:	

scanFormat$113:	; arg_list = £temporary1645
415:		mov [bp + 8], ax
417:	

scanFormat$114:	; £temporary1646 = arg_list - 2
418:		mov si, [bp + 8]
419:		sub si, 2
421:	

scanFormat$115:	; £temporary1647 = int_to_int £temporary1646 (Signed_Int -> Pointer)
424:	

scanFormat$116:	; £temporary1648 -> £temporary1647 = *£temporary1647
426:	

scanFormat$117:	; longPtr = £temporary1648 -> £temporary1647
427:		mov ax, [si]
428:		mov [bp + 27], ax
430:	

scanFormat$118:	; £temporary1649 -> longPtr = *longPtr
431:		mov si, [bp + 27]
433:	

scanFormat$119:	; £temporary1649 -> longPtr = longValue
434:		mov eax, [bp + 23]
435:		mov [si], eax
437:	

scanFormat$120:	; percent = 0
438:		mov word [bp + 13], 0
440:	

scanFormat$121:	; goto 344
441:		jmp scanFormat$344
443:	

scanFormat$122:	; call header integral zero 0 stack zero 0
445:	

scanFormat$123:	; parameter 8, offset 6
446:		mov dword [bp + 63], 8
448:	

scanFormat$124:	; call function noellipse-noellipse scanUnsignedLongInt
449:		mov word [bp + 57], scanFormat$125
450:		mov [bp + 59], bp
451:		add bp, 57
452:		jmp scanUnsignedLongInt
454:	

scanFormat$125:	; post call
456:	

scanFormat$126:	; £temporary1651 = return_value
461:	

scanFormat$127:	; unsignedLongValue = £temporary1651
462:		mov [bp + 37], ebx
464:	

scanFormat$128:	; if star != 0 goto 159
465:		cmp word [bp + 21], 0
466:		jne scanFormat$159
468:	

scanFormat$129:	; if shortInt == 0 goto 140
469:		cmp word [bp + 15], 0
470:		je scanFormat$140
472:	

scanFormat$130:	; £temporary1654 = arg_list + 2
473:		mov ax, [bp + 8]
474:		add ax, 2
476:	

scanFormat$131:	; arg_list = £temporary1654
477:		mov [bp + 8], ax
479:	

scanFormat$132:	; £temporary1655 = arg_list - 2
480:		mov si, [bp + 8]
481:		sub si, 2
483:	

scanFormat$133:	; £temporary1656 = int_to_int £temporary1655 (Signed_Int -> Pointer)
486:	

scanFormat$134:	; £temporary1657 -> £temporary1656 = *£temporary1656
488:	

scanFormat$135:	; unsignedShortPtr = £temporary1657 -> £temporary1656
489:		mov ax, [si]
490:		mov [bp + 43], ax
492:	

scanFormat$136:	; £temporary1658 -> unsignedShortPtr = *unsignedShortPtr
493:		mov si, [bp + 43]
495:	

scanFormat$137:	; £temporary1659 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
496:		mov eax, [bp + 37]
499:	

scanFormat$138:	; £temporary1658 -> unsignedShortPtr = £temporary1659
500:		mov [si], al
502:	

scanFormat$139:	; goto 159
503:		jmp scanFormat$159
505:	

scanFormat$140:	; if longIntOrDouble != 0 goto 151
506:		cmp word [bp + 17], 0
507:		jne scanFormat$151
509:	

scanFormat$141:	; £temporary1662 = arg_list + 2
510:		mov ax, [bp + 8]
511:		add ax, 2
513:	

scanFormat$142:	; arg_list = £temporary1662
514:		mov [bp + 8], ax
516:	

scanFormat$143:	; £temporary1663 = arg_list - 2
517:		mov si, [bp + 8]
518:		sub si, 2
520:	

scanFormat$144:	; £temporary1664 = int_to_int £temporary1663 (Signed_Int -> Pointer)
523:	

scanFormat$145:	; £temporary1665 -> £temporary1664 = *£temporary1664
525:	

scanFormat$146:	; unsignedIntPtr = £temporary1665 -> £temporary1664
526:		mov ax, [si]
527:		mov [bp + 45], ax
529:	

scanFormat$147:	; £temporary1666 -> unsignedIntPtr = *unsignedIntPtr
530:		mov si, [bp + 45]
532:	

scanFormat$148:	; £temporary1667 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
533:		mov eax, [bp + 37]
536:	

scanFormat$149:	; £temporary1666 -> unsignedIntPtr = £temporary1667
537:		mov [si], ax
539:	

scanFormat$150:	; goto 159
540:		jmp scanFormat$159
542:	

scanFormat$151:	; £temporary1668 = arg_list + 2
543:		mov ax, [bp + 8]
544:		add ax, 2
546:	

scanFormat$152:	; arg_list = £temporary1668
547:		mov [bp + 8], ax
549:	

scanFormat$153:	; £temporary1669 = arg_list - 2
550:		mov si, [bp + 8]
551:		sub si, 2
553:	

scanFormat$154:	; £temporary1670 = int_to_int £temporary1669 (Signed_Int -> Pointer)
556:	

scanFormat$155:	; £temporary1671 -> £temporary1670 = *£temporary1670
558:	

scanFormat$156:	; unsignedLongPtr = £temporary1671 -> £temporary1670
559:		mov ax, [si]
560:		mov [bp + 41], ax
562:	

scanFormat$157:	; £temporary1672 -> unsignedLongPtr = *unsignedLongPtr
563:		mov si, [bp + 41]
565:	

scanFormat$158:	; £temporary1672 -> unsignedLongPtr = unsignedLongValue
566:		mov eax, [bp + 37]
567:		mov [si], eax
569:	

scanFormat$159:	; percent = 0
570:		mov word [bp + 13], 0
572:	

scanFormat$160:	; goto 344
573:		jmp scanFormat$344
575:	

scanFormat$161:	; call header integral zero 0 stack zero 0
577:	

scanFormat$162:	; parameter 16, offset 6
578:		mov dword [bp + 63], 16
580:	

scanFormat$163:	; call function noellipse-noellipse scanUnsignedLongInt
581:		mov word [bp + 57], scanFormat$164
582:		mov [bp + 59], bp
583:		add bp, 57
584:		jmp scanUnsignedLongInt
586:	

scanFormat$164:	; post call
588:	

scanFormat$165:	; £temporary1674 = return_value
593:	

scanFormat$166:	; unsignedLongValue = £temporary1674
594:		mov [bp + 37], ebx
596:	

scanFormat$167:	; if star != 0 goto 198
597:		cmp word [bp + 21], 0
598:		jne scanFormat$198
600:	

scanFormat$168:	; if shortInt == 0 goto 179
601:		cmp word [bp + 15], 0
602:		je scanFormat$179
604:	

scanFormat$169:	; £temporary1677 = arg_list + 2
605:		mov ax, [bp + 8]
606:		add ax, 2
608:	

scanFormat$170:	; arg_list = £temporary1677
609:		mov [bp + 8], ax
611:	

scanFormat$171:	; £temporary1678 = arg_list - 2
612:		mov si, [bp + 8]
613:		sub si, 2
615:	

scanFormat$172:	; £temporary1679 = int_to_int £temporary1678 (Signed_Int -> Pointer)
618:	

scanFormat$173:	; £temporary1680 -> £temporary1679 = *£temporary1679
620:	

scanFormat$174:	; unsignedShortPtr = £temporary1680 -> £temporary1679
621:		mov ax, [si]
622:		mov [bp + 43], ax
624:	

scanFormat$175:	; £temporary1681 -> unsignedShortPtr = *unsignedShortPtr
625:		mov si, [bp + 43]
627:	

scanFormat$176:	; £temporary1682 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
628:		mov eax, [bp + 37]
631:	

scanFormat$177:	; £temporary1681 -> unsignedShortPtr = £temporary1682
632:		mov [si], al
634:	

scanFormat$178:	; goto 198
635:		jmp scanFormat$198
637:	

scanFormat$179:	; if longIntOrDouble != 0 goto 190
638:		cmp word [bp + 17], 0
639:		jne scanFormat$190
641:	

scanFormat$180:	; £temporary1685 = arg_list + 2
642:		mov ax, [bp + 8]
643:		add ax, 2
645:	

scanFormat$181:	; arg_list = £temporary1685
646:		mov [bp + 8], ax
648:	

scanFormat$182:	; £temporary1686 = arg_list - 2
649:		mov si, [bp + 8]
650:		sub si, 2
652:	

scanFormat$183:	; £temporary1687 = int_to_int £temporary1686 (Signed_Int -> Pointer)
655:	

scanFormat$184:	; £temporary1688 -> £temporary1687 = *£temporary1687
657:	

scanFormat$185:	; unsignedIntPtr = £temporary1688 -> £temporary1687
658:		mov ax, [si]
659:		mov [bp + 45], ax
661:	

scanFormat$186:	; £temporary1689 -> unsignedIntPtr = *unsignedIntPtr
662:		mov si, [bp + 45]
664:	

scanFormat$187:	; £temporary1690 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
665:		mov eax, [bp + 37]
668:	

scanFormat$188:	; £temporary1689 -> unsignedIntPtr = £temporary1690
669:		mov [si], ax
671:	

scanFormat$189:	; goto 198
672:		jmp scanFormat$198
674:	

scanFormat$190:	; £temporary1691 = arg_list + 2
675:		mov ax, [bp + 8]
676:		add ax, 2
678:	

scanFormat$191:	; arg_list = £temporary1691
679:		mov [bp + 8], ax
681:	

scanFormat$192:	; £temporary1692 = arg_list - 2
682:		mov si, [bp + 8]
683:		sub si, 2
685:	

scanFormat$193:	; £temporary1693 = int_to_int £temporary1692 (Signed_Int -> Pointer)
688:	

scanFormat$194:	; £temporary1694 -> £temporary1693 = *£temporary1693
690:	

scanFormat$195:	; unsignedLongPtr = £temporary1694 -> £temporary1693
691:		mov ax, [si]
692:		mov [bp + 41], ax
694:	

scanFormat$196:	; £temporary1695 -> unsignedLongPtr = *unsignedLongPtr
695:		mov si, [bp + 41]
697:	

scanFormat$197:	; £temporary1695 -> unsignedLongPtr = unsignedLongValue
698:		mov eax, [bp + 37]
699:		mov [si], eax
701:	

scanFormat$198:	; percent = 0
702:		mov word [bp + 13], 0
704:	

scanFormat$199:	; goto 344
705:		jmp scanFormat$344
707:	

scanFormat$200:	; call header integral zero 0 stack zero 0
709:	

scanFormat$201:	; parameter 0, offset 6
710:		mov dword [bp + 63], 0
712:	

scanFormat$202:	; call function noellipse-noellipse scanUnsignedLongInt
713:		mov word [bp + 57], scanFormat$203
714:		mov [bp + 59], bp
715:		add bp, 57
716:		jmp scanUnsignedLongInt
718:	

scanFormat$203:	; post call
720:	

scanFormat$204:	; £temporary1697 = return_value
725:	

scanFormat$205:	; unsignedLongValue = £temporary1697
726:		mov [bp + 37], ebx
728:	

scanFormat$206:	; if star != 0 goto 237
729:		cmp word [bp + 21], 0
730:		jne scanFormat$237
732:	

scanFormat$207:	; if shortInt == 0 goto 218
733:		cmp word [bp + 15], 0
734:		je scanFormat$218
736:	

scanFormat$208:	; £temporary1700 = arg_list + 2
737:		mov ax, [bp + 8]
738:		add ax, 2
740:	

scanFormat$209:	; arg_list = £temporary1700
741:		mov [bp + 8], ax
743:	

scanFormat$210:	; £temporary1701 = arg_list - 2
744:		mov si, [bp + 8]
745:		sub si, 2
747:	

scanFormat$211:	; £temporary1702 = int_to_int £temporary1701 (Signed_Int -> Pointer)
750:	

scanFormat$212:	; £temporary1703 -> £temporary1702 = *£temporary1702
752:	

scanFormat$213:	; unsignedShortPtr = £temporary1703 -> £temporary1702
753:		mov ax, [si]
754:		mov [bp + 43], ax
756:	

scanFormat$214:	; £temporary1704 -> unsignedShortPtr = *unsignedShortPtr
757:		mov si, [bp + 43]
759:	

scanFormat$215:	; £temporary1705 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
760:		mov eax, [bp + 37]
763:	

scanFormat$216:	; £temporary1704 -> unsignedShortPtr = £temporary1705
764:		mov [si], al
766:	

scanFormat$217:	; goto 237
767:		jmp scanFormat$237
769:	

scanFormat$218:	; if longIntOrDouble != 0 goto 229
770:		cmp word [bp + 17], 0
771:		jne scanFormat$229
773:	

scanFormat$219:	; £temporary1708 = arg_list + 2
774:		mov ax, [bp + 8]
775:		add ax, 2
777:	

scanFormat$220:	; arg_list = £temporary1708
778:		mov [bp + 8], ax
780:	

scanFormat$221:	; £temporary1709 = arg_list - 2
781:		mov si, [bp + 8]
782:		sub si, 2
784:	

scanFormat$222:	; £temporary1710 = int_to_int £temporary1709 (Signed_Int -> Pointer)
787:	

scanFormat$223:	; £temporary1711 -> £temporary1710 = *£temporary1710
789:	

scanFormat$224:	; unsignedIntPtr = £temporary1711 -> £temporary1710
790:		mov ax, [si]
791:		mov [bp + 45], ax
793:	

scanFormat$225:	; £temporary1712 -> unsignedIntPtr = *unsignedIntPtr
794:		mov si, [bp + 45]
796:	

scanFormat$226:	; £temporary1713 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
797:		mov eax, [bp + 37]
800:	

scanFormat$227:	; £temporary1712 -> unsignedIntPtr = £temporary1713
801:		mov [si], ax
803:	

scanFormat$228:	; goto 237
804:		jmp scanFormat$237
806:	

scanFormat$229:	; £temporary1714 = arg_list + 2
807:		mov ax, [bp + 8]
808:		add ax, 2
810:	

scanFormat$230:	; arg_list = £temporary1714
811:		mov [bp + 8], ax
813:	

scanFormat$231:	; £temporary1715 = arg_list - 2
814:		mov si, [bp + 8]
815:		sub si, 2
817:	

scanFormat$232:	; £temporary1716 = int_to_int £temporary1715 (Signed_Int -> Pointer)
820:	

scanFormat$233:	; £temporary1717 -> £temporary1716 = *£temporary1716
822:	

scanFormat$234:	; unsignedLongPtr = £temporary1717 -> £temporary1716
823:		mov ax, [si]
824:		mov [bp + 41], ax
826:	

scanFormat$235:	; £temporary1718 -> unsignedLongPtr = *unsignedLongPtr
827:		mov si, [bp + 41]
829:	

scanFormat$236:	; £temporary1718 -> unsignedLongPtr = unsignedLongValue
830:		mov eax, [bp + 37]
831:		mov [si], eax
833:	

scanFormat$237:	; percent = 0
834:		mov word [bp + 13], 0
836:	

scanFormat$238:	; goto 344
837:		jmp scanFormat$344
839:	

scanFormat$239:	; call header integral zero 0 stack zero 0
841:	

scanFormat$240:	; call function noellipse-noellipse scanLongDouble
842:		mov word [bp + 57], scanFormat$241
843:		mov [bp + 59], bp
844:		add bp, 57
845:		jmp scanLongDouble
847:	

scanFormat$241:	; post call
849:	

scanFormat$242:	; £temporary1720 = return_value
851:	

scanFormat$243:	; pop float longDoubleValue
852:		fstp qword [bp + 47]
854:	

scanFormat$244:	; if star != 0 goto 276
855:		cmp word [bp + 21], 0
856:		jne scanFormat$276
858:	

scanFormat$245:	; if longIntOrDouble == 0 goto 256
859:		cmp word [bp + 17], 0
860:		je scanFormat$256
862:	

scanFormat$246:	; £temporary1723 = arg_list + 2
863:		mov ax, [bp + 8]
864:		add ax, 2
866:	

scanFormat$247:	; arg_list = £temporary1723
867:		mov [bp + 8], ax
869:	

scanFormat$248:	; £temporary1724 = arg_list - 2
870:		mov si, [bp + 8]
871:		sub si, 2
873:	

scanFormat$249:	; £temporary1725 = int_to_int £temporary1724 (Signed_Int -> Pointer)
876:	

scanFormat$250:	; £temporary1726 -> £temporary1725 = *£temporary1725
878:	

scanFormat$251:	; doublePtr = £temporary1726 -> £temporary1725
879:		mov ax, [si]
880:		mov [bp + 57], ax
882:	

scanFormat$252:	; £temporary1727 -> doublePtr = *doublePtr
883:		mov si, [bp + 57]
885:	

scanFormat$253:	; push float longDoubleValue
886:		fld qword [bp + 47]
888:	

scanFormat$254:	; pop float £temporary1727 -> doublePtr
889:		fstp qword [si]
891:	

scanFormat$255:	; goto 276
892:		jmp scanFormat$276
894:	

scanFormat$256:	; if longDouble == 0 goto 267
895:		cmp word [bp + 19], 0
896:		je scanFormat$267
898:	

scanFormat$257:	; £temporary1729 = arg_list + 2
899:		mov ax, [bp + 8]
900:		add ax, 2
902:	

scanFormat$258:	; arg_list = £temporary1729
903:		mov [bp + 8], ax
905:	

scanFormat$259:	; £temporary1730 = arg_list - 2
906:		mov si, [bp + 8]
907:		sub si, 2
909:	

scanFormat$260:	; £temporary1731 = int_to_int £temporary1730 (Signed_Int -> Pointer)
912:	

scanFormat$261:	; £temporary1732 -> £temporary1731 = *£temporary1731
914:	

scanFormat$262:	; longDoublePtr = £temporary1732 -> £temporary1731
915:		mov ax, [si]
916:		mov [bp + 57], ax
918:	

scanFormat$263:	; £temporary1733 -> longDoublePtr = *longDoublePtr
919:		mov si, [bp + 57]
921:	

scanFormat$264:	; push float longDoubleValue
922:		fld qword [bp + 47]
924:	

scanFormat$265:	; pop float £temporary1733 -> longDoublePtr
925:		fstp qword [si]
927:	

scanFormat$266:	; goto 276
928:		jmp scanFormat$276
930:	

scanFormat$267:	; £temporary1734 = arg_list + 2
931:		mov ax, [bp + 8]
932:		add ax, 2
934:	

scanFormat$268:	; arg_list = £temporary1734
935:		mov [bp + 8], ax
937:	

scanFormat$269:	; £temporary1735 = arg_list - 2
938:		mov si, [bp + 8]
939:		sub si, 2
941:	

scanFormat$270:	; £temporary1736 = int_to_int £temporary1735 (Signed_Int -> Pointer)
944:	

scanFormat$271:	; £temporary1737 -> £temporary1736 = *£temporary1736
946:	

scanFormat$272:	; floatPtr = £temporary1737 -> £temporary1736
947:		mov ax, [si]
948:		mov [bp + 57], ax
950:	

scanFormat$273:	; £temporary1738 -> floatPtr = *floatPtr
951:		mov si, [bp + 57]
953:	

scanFormat$274:	; push float longDoubleValue
954:		fld qword [bp + 47]
956:	

scanFormat$275:	; pop float £temporary1738 -> floatPtr
957:		fstp dword [si]
959:	

scanFormat$276:	; percent = 0
960:		mov word [bp + 13], 0
962:	

scanFormat$277:	; goto 344
963:		jmp scanFormat$344
965:	

scanFormat$278:	; not = 0
966:		mov word [bp + 57], 0
968:	

scanFormat$279:	; ++index
969:		inc word [bp + 31]
971:	

scanFormat$280:	; £temporary1744 = format + index
972:		mov si, [bp + 6]
973:		add si, [bp + 31]
975:	

scanFormat$281:	; £temporary1743 -> £temporary1744 = *£temporary1744
977:	

scanFormat$282:	; if £temporary1743 -> £temporary1744 != 94 goto 285
978:		cmp byte [si], 94
979:		jne scanFormat$285
981:	

scanFormat$283:	; not = 1
982:		mov word [bp + 57], 1
984:	

scanFormat$284:	; ++index
985:		inc word [bp + 31]
987:	

scanFormat$285:	; startIndex = index
988:		mov ax, [bp + 31]
989:		mov [bp + 59], ax
991:	

scanFormat$286:	; £temporary1748 = format + index
992:		mov si, [bp + 6]
993:		add si, [bp + 31]
995:	

scanFormat$287:	; £temporary1747 -> £temporary1748 = *£temporary1748
997:	

scanFormat$288:	; if £temporary1747 -> £temporary1748 == 93 goto 291
998:		cmp byte [si], 93
999:		je scanFormat$291
1001:	

scanFormat$289:	; ++index
1002:		inc word [bp + 31]
1004:	

scanFormat$290:	; goto 286
1005:		jmp scanFormat$286
1007:	

scanFormat$291:	; £temporary1752 = format + index
1008:		mov si, [bp + 6]
1009:		add si, [bp + 31]
1011:	

scanFormat$292:	; £temporary1751 -> £temporary1752 = *£temporary1752
1013:	

scanFormat$293:	; £temporary1751 -> £temporary1752 = 0
1014:		mov byte [si], 0
1016:	

scanFormat$294:	; if star != 0 goto 311
1017:		cmp word [bp + 21], 0
1018:		jne scanFormat$311
1020:	

scanFormat$295:	; £temporary1755 = arg_list + 2
1021:		mov ax, [bp + 8]
1022:		add ax, 2
1024:	

scanFormat$296:	; arg_list = £temporary1755
1025:		mov [bp + 8], ax
1027:	

scanFormat$297:	; £temporary1756 = arg_list - 2
1028:		mov si, [bp + 8]
1029:		sub si, 2
1031:	

scanFormat$298:	; £temporary1757 = int_to_int £temporary1756 (Signed_Int -> Pointer)
1034:	

scanFormat$299:	; £temporary1758 -> £temporary1757 = *£temporary1757
1036:	

scanFormat$300:	; string = £temporary1758 -> £temporary1757
1037:		mov ax, [si]
1038:		mov [bp + 61], ax
1040:	

scanFormat$301:	; call header integral zero 0 stack zero 0
1042:	

scanFormat$302:	; parameter string, offset 6
1043:		mov ax, [bp + 61]
1044:		mov [bp + 69], ax
1046:	

scanFormat$303:	; £temporary1760 = format + startIndex
1047:		mov si, [bp + 6]
1048:		add si, [bp + 59]
1050:	

scanFormat$304:	; £temporary1759 -> £temporary1760 = *£temporary1760
1052:	

scanFormat$305:	; £temporary1761 = &£temporary1759 -> £temporary1760
1054:	

scanFormat$306:	; parameter £temporary1761, offset 8
1055:		mov [bp + 71], si
1057:	

scanFormat$307:	; parameter not, offset 10
1058:		mov ax, [bp + 57]
1059:		mov [bp + 73], ax
1061:	

scanFormat$308:	; call function noellipse-noellipse scanPattern
1062:		mov word [bp + 63], scanFormat$309
1063:		mov [bp + 65], bp
1064:		add bp, 63
1065:		jmp scanPattern
1067:	

scanFormat$309:	; post call
1069:	

scanFormat$310:	; goto 344
1070:		jmp scanFormat$344
1072:	

scanFormat$311:	; call header integral zero 0 stack zero 0
1074:	

scanFormat$312:	; parameter 0, offset 6
1075:		mov word [bp + 67], 0
1077:	

scanFormat$313:	; £temporary1764 = format + startIndex
1078:		mov si, [bp + 6]
1079:		add si, [bp + 59]
1081:	

scanFormat$314:	; £temporary1763 -> £temporary1764 = *£temporary1764
1083:	

scanFormat$315:	; £temporary1765 = &£temporary1763 -> £temporary1764
1085:	

scanFormat$316:	; parameter £temporary1765, offset 8
1086:		mov [bp + 69], si
1088:	

scanFormat$317:	; parameter not, offset 10
1089:		mov ax, [bp + 57]
1090:		mov [bp + 71], ax
1092:	

scanFormat$318:	; call function noellipse-noellipse scanPattern
1093:		mov word [bp + 61], scanFormat$319
1094:		mov [bp + 63], bp
1095:		add bp, 61
1096:		jmp scanPattern
1098:	

scanFormat$319:	; post call
1100:	

scanFormat$320:	; goto 344
1101:		jmp scanFormat$344
1103:	

scanFormat$321:	; £temporary1767 = arg_list + 2
1104:		mov ax, [bp + 8]
1105:		add ax, 2
1107:	

scanFormat$322:	; arg_list = £temporary1767
1108:		mov [bp + 8], ax
1110:	

scanFormat$323:	; £temporary1768 = arg_list - 2
1111:		mov si, [bp + 8]
1112:		sub si, 2
1114:	

scanFormat$324:	; £temporary1769 = int_to_int £temporary1768 (Signed_Int -> Pointer)
1117:	

scanFormat$325:	; £temporary1770 -> £temporary1769 = *£temporary1769
1119:	

scanFormat$326:	; charsPtr = £temporary1770 -> £temporary1769
1120:		mov ax, [si]
1121:		mov [bp + 35], ax
1123:	

scanFormat$327:	; £temporary1771 -> charsPtr = *charsPtr
1124:		mov si, [bp + 35]
1126:	

scanFormat$328:	; £temporary1771 -> charsPtr = g_inChars
1127:		mov ax, [g_inChars]
1128:		mov [si], ax
1130:	

scanFormat$329:	; percent = 0
1131:		mov word [bp + 13], 0
1133:	

scanFormat$330:	; goto 344
1134:		jmp scanFormat$344
1136:	

scanFormat$331:	; call header integral zero 0 stack zero 0
1138:	

scanFormat$332:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1139:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1141:	

scanFormat$333:	; £temporary1772 = int_to_int c (Signed_Char -> Signed_Int)
1142:		mov al, [bp + 10]
1144:		and ax, 255
1146:		cmp al, 0
1147:		jge scanFormat$334
1148:		neg al
1150:		neg ax
1152:	

scanFormat$334:	; parameter £temporary1772, offset 8
1153:		mov [bp + 65], ax
1155:	

scanFormat$335:	; call function noellipse-ellipse printf, extra 0
1156:		mov word [bp + 57], scanFormat$336
1157:		mov [bp + 59], bp
1158:		add bp, 57
1159:		mov di, bp
1160:		add di, 2
1161:		jmp printf
1163:	

scanFormat$336:	; post call
1165:	

scanFormat$337:	; goto 344
1166:		jmp scanFormat$344
1168:	

scanFormat$338:	; if c != 37 goto 344
1169:		cmp byte [bp + 10], 37
1170:		jne scanFormat$344
1172:	

scanFormat$339:	; percent = 1
1173:		mov word [bp + 13], 1
1175:	

scanFormat$340:	; shortInt = 0
1176:		mov word [bp + 15], 0
1178:	

scanFormat$341:	; longIntOrDouble = 0
1179:		mov word [bp + 17], 0
1181:	

scanFormat$342:	; longDouble = 0
1182:		mov word [bp + 19], 0
1184:	

scanFormat$343:	; star = 0
1185:		mov word [bp + 21], 0
1187:	

scanFormat$344:	; ++index
1188:		inc word [bp + 31]
1190:	

scanFormat$345:	; goto 8
1191:		jmp scanFormat$8
1193:	

scanFormat$346:	; return_value = g_inCount
1194:		mov bx, [g_inCount]
1196:	

scanFormat$347:	; return
1197:		mov ax, [bp]
1198:		mov di, [bp + 4]
1199:		mov bp, [bp + 2]
1200:		jmp ax
1202:	

scanFormat$348:	; function end scanFormat
1:	

scanf:	; £temporary1791 = &format
2:		mov si, bp
3:		add si, 6
5:	

scanf$1:	; £temporary1792 = int_to_int £temporary1791 (Pointer -> Pointer)
8:	

scanf$2:	; £temporary1793 = £temporary1792 + 2
9:		add si, 2
11:	

scanf$3:	; arg_list = £temporary1793
12:		mov [di + 8], si
14:	

scanf$4:	; call header integral zero 0 stack zero 0
16:	

scanf$5:	; parameter format, offset 6
17:		mov ax, [bp + 6]
18:		mov [di + 16], ax
20:	

scanf$6:	; parameter arg_list, offset 8
21:		mov ax, [di + 8]
22:		mov [di + 18], ax
24:	

scanf$7:	; call function ellipse-noellipse vscanf
25:		mov word [di + 10], scanf$8
26:		mov [di + 12], bp
27:		mov [di + 14], di
28:		mov bp, di
29:		add bp, 10
30:		jmp vscanf
32:	

scanf$8:	; post call
34:	

scanf$9:	; £temporary1794 = return_value
39:	

scanf$10:	; return_value = £temporary1794
41:	

scanf$11:	; return
42:		mov ax, [bp]
43:		mov di, [bp + 4]
44:		mov bp, [bp + 2]
45:		jmp ax
47:	

scanf$12:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov ax, [stdin]
5:		mov [bp + 16], ax
7:	

vscanf$2:	; parameter format, offset 8
8:		mov ax, [bp + 6]
9:		mov [bp + 18], ax
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov ax, [bp + 8]
13:		mov [bp + 20], ax
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1798 = return_value
28:	

vscanf$7:	; return_value = £temporary1798
30:	

vscanf$8:	; return
31:		mov ax, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp ax
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1802 = &format
2:		mov si, bp
3:		add si, 8
5:	

fscanf$1:	; £temporary1803 = int_to_int £temporary1802 (Pointer -> Pointer)
8:	

fscanf$2:	; £temporary1804 = £temporary1803 + 2
9:		add si, 2
11:	

fscanf$3:	; arg_list = £temporary1804
12:		mov [di + 10], si
14:	

fscanf$4:	; call header integral zero 0 stack zero 0
16:	

fscanf$5:	; parameter inStream, offset 6
17:		mov ax, [bp + 6]
18:		mov [di + 18], ax
20:	

fscanf$6:	; parameter format, offset 8
21:		mov ax, [bp + 8]
22:		mov [di + 20], ax
24:	

fscanf$7:	; parameter arg_list, offset 10
25:		mov ax, [di + 10]
26:		mov [di + 22], ax
28:	

fscanf$8:	; call function ellipse-noellipse vfscanf
29:		mov word [di + 12], fscanf$9
30:		mov [di + 14], bp
31:		mov [di + 16], di
32:		mov bp, di
33:		add bp, 12
34:		jmp vfscanf
36:	

fscanf$9:	; post call
38:	

fscanf$10:	; £temporary1805 = return_value
43:	

fscanf$11:	; return_value = £temporary1805
45:	

fscanf$12:	; return
46:		mov ax, [bp]
47:		mov di, [bp + 4]
48:		mov bp, [bp + 2]
49:		jmp ax
51:	

fscanf$13:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1810 = int_to_int inStream (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1810
9:		mov [g_inDevice], ax
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1811 = return_value
34:	

vfscanf$9:	; return_value = £temporary1811
36:	

vfscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1814 = &format
2:		mov si, bp
3:		add si, 8
5:	

sscanf$1:	; £temporary1815 = int_to_int £temporary1814 (Pointer -> Pointer)
8:	

sscanf$2:	; £temporary1816 = £temporary1815 + 2
9:		add si, 2
11:	

sscanf$3:	; arg_list = £temporary1816
12:		mov [di + 10], si
14:	

sscanf$4:	; call header integral zero 0 stack zero 0
16:	

sscanf$5:	; parameter inString, offset 6
17:		mov ax, [bp + 6]
18:		mov [di + 18], ax
20:	

sscanf$6:	; parameter format, offset 8
21:		mov ax, [bp + 8]
22:		mov [di + 20], ax
24:	

sscanf$7:	; parameter arg_list, offset 10
25:		mov ax, [di + 10]
26:		mov [di + 22], ax
28:	

sscanf$8:	; call function ellipse-noellipse vsscanf
29:		mov word [di + 12], sscanf$9
30:		mov [di + 14], bp
31:		mov [di + 16], di
32:		mov bp, di
33:		add bp, 12
34:		jmp vsscanf
36:	

sscanf$9:	; post call
38:	

sscanf$10:	; £temporary1817 = return_value
43:	

sscanf$11:	; return_value = £temporary1817
45:	

sscanf$12:	; return
46:		mov ax, [bp]
47:		mov di, [bp + 4]
48:		mov bp, [bp + 2]
49:		jmp ax
51:	

sscanf$13:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1822 = int_to_int inString (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1822
9:		mov [g_inDevice], ax
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1823 = return_value
34:	

vsscanf$9:	; return_value = £temporary1823
36:	

vsscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vsscanf$11:	; function end vsscanf
