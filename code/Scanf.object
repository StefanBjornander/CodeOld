1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov ax, [g_inStatus]
6:		cmp ax, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp ax, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1331 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov ax, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1331
23:		mov [bp + 7], ax
25:	

scanChar$7:	; £temporary1332 -> stream = *stream, offset 2
26:		mov si, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1332 -> stream
29:		mov ax, [si + 2]
30:		mov [bp + 9], ax
32:	

scanChar$9:	; ah = 63
33:		mov ah, 63
35:	

scanChar$10:	; bx = handle
36:		mov bx, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov cx, 1
41:	

scanChar$12:	; £temporary1337 = &c
42:		mov dx, bp
43:		add dx, 6
45:	

scanChar$13:	; dx = £temporary1337
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov bl, [bp + 6]
56:	

scanChar$17:	; return
57:		mov ax, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp ax
62:	

scanChar$18:	; £temporary1339 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov ax, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1339
67:		mov [bp + 11], ax
69:	

scanChar$20:	; £temporary1340 = g_inChars
70:		mov ax, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1342 = inString + £temporary1340
76:		mov si, [bp + 11]
77:		add si, ax
79:	

scanChar$23:	; £temporary1341 -> £temporary1342 = *£temporary1342
81:	

scanChar$24:	; return_value = £temporary1341 -> £temporary1342
82:		mov bl, [si]
84:	

scanChar$25:	; return
85:		mov ax, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp ax
90:	

scanChar$26:	; return_value = 0
91:		mov bl, 0
93:	

scanChar$27:	; return
94:		mov ax, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp ax
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov ax, [g_inStatus]
3:		cmp ax, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp ax, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov ax, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp ax
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1346 = return_value
19:	

scanPattern$5:	; input = £temporary1346
20:		mov [bp + 14], bl
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1347 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov al, [bp + 14]
27:		and ax, 255
29:		cmp al, 0
30:		jge scanPattern$8
31:		neg al
33:		neg ax
35:	

scanPattern$8:	; parameter £temporary1347, offset 6
36:		mov [bp + 21], ax
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1348 = return_value
51:	

scanPattern$12:	; if £temporary1348 == 0 goto 19
52:		cmp bx, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1349 = return_value
70:	

scanPattern$17:	; input = £temporary1349
71:		mov [bp + 14], bl
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov ax, [bp + 8]
88:		mov [bp + 21], ax
90:	

scanPattern$23:	; £temporary1354 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov al, [bp + 14]
93:		and ax, 255
95:		cmp al, 0
96:		jge scanPattern$24
97:		neg al
99:		neg ax
101:	

scanPattern$24:	; parameter £temporary1354, offset 8
102:		mov [bp + 23], ax
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1355 = return_value
117:	

scanPattern$28:	; if £temporary1355 != 0 goto 38
118:		cmp bx, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov ax, [bp + 8]
129:		mov [bp + 21], ax
131:	

scanPattern$32:	; £temporary1358 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov al, [bp + 14]
134:		and ax, 255
136:		cmp al, 0
137:		jge scanPattern$33
138:		neg al
140:		neg ax
142:	

scanPattern$33:	; parameter £temporary1358, offset 8
143:		mov [bp + 23], ax
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1359 = return_value
158:	

scanPattern$37:	; if £temporary1359 != 0 goto 49
159:		cmp bx, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1365 = index
163:		mov ax, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1367 = string + £temporary1365
169:		mov si, [bp + 6]
170:		add si, ax
172:	

scanPattern$41:	; £temporary1366 -> £temporary1367 = *£temporary1367
174:	

scanPattern$42:	; £temporary1366 -> £temporary1367 = input
175:		mov al, [bp + 14]
176:		mov [si], al
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1368 = return_value
193:	

scanPattern$47:	; input = £temporary1368
194:		mov [bp + 14], bl
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1370 = string + index
200:		mov si, [bp + 6]
201:		add si, [bp + 12]
203:	

scanPattern$50:	; £temporary1369 -> £temporary1370 = *£temporary1370
205:	

scanPattern$51:	; £temporary1369 -> £temporary1370 = 0
206:		mov byte [si], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov ax, [bp + 8]
219:		mov [bp + 21], ax
221:	

scanPattern$56:	; £temporary1373 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov al, [bp + 14]
224:		and ax, 255
226:		cmp al, 0
227:		jge scanPattern$57
228:		neg al
230:		neg ax
232:	

scanPattern$57:	; parameter £temporary1373, offset 8
233:		mov [bp + 23], ax
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1374 = return_value
248:	

scanPattern$61:	; if £temporary1374 != 0 goto 71
249:		cmp bx, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov ax, [bp + 8]
260:		mov [bp + 21], ax
262:	

scanPattern$65:	; £temporary1377 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov al, [bp + 14]
265:		and ax, 255
267:		cmp al, 0
268:		jge scanPattern$66
269:		neg al
271:		neg ax
273:	

scanPattern$66:	; parameter £temporary1377, offset 8
274:		mov [bp + 23], ax
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1378 = return_value
289:	

scanPattern$70:	; if £temporary1378 != 0 goto 77
290:		cmp bx, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1384 = return_value
308:	

scanPattern$75:	; input = £temporary1384
309:		mov [bp + 14], bl
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov ax, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp ax
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1394 = return_value
19:	

scanString$5:	; input = £temporary1394
20:		mov [bp + 12], bl
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1395 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 12]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanString$9
34:		neg al
36:		neg ax
38:	

scanString$9:	; parameter £temporary1395, offset 6
39:		mov [bp + 21], ax
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1396 = return_value
54:	

scanString$13:	; if £temporary1396 == 0 goto 20
55:		cmp bx, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1397 = return_value
73:	

scanString$18:	; input = £temporary1397
74:		mov [bp + 12], bl
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1401 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov al, [bp + 12]
92:		and ax, 255
94:		cmp al, 0
95:		jge scanString$24
96:		neg al
98:		neg ax
100:	

scanString$24:	; parameter £temporary1401, offset 6
101:		mov [bp + 21], ax
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1402 = return_value
116:	

scanString$28:	; if £temporary1402 != 0 goto 45
117:		cmp bx, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1405 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov al, [bp + 12]
123:		and ax, 255
125:		cmp al, 0
126:		jge scanString$30
127:		neg al
129:		neg ax
131:	

scanString$30:	; if £temporary1405 == -1 goto 45
132:		cmp ax, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1410 = index
140:		mov ax, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1412 = string + £temporary1410
146:		mov si, [bp + 6]
147:		add si, ax
149:	

scanString$35:	; £temporary1411 -> £temporary1412 = *£temporary1412
151:	

scanString$36:	; £temporary1411 -> £temporary1412 = input
152:		mov al, [bp + 12]
153:		mov [si], al
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1413 = return_value
170:	

scanString$41:	; input = £temporary1413
171:		mov [bp + 12], bl
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1416 = string + index
183:		mov si, [bp + 6]
184:		add si, [bp + 10]
186:	

scanString$46:	; £temporary1415 -> £temporary1416 = *£temporary1416
188:	

scanString$47:	; £temporary1415 -> £temporary1416 = 0
189:		mov byte [si], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1418 = precision
198:		mov ax, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1418 <= 0 goto 76
204:		cmp ax, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1420 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov al, [bp + 12]
212:		and ax, 255
214:		cmp al, 0
215:		jge scanString$55
216:		neg al
218:		neg ax
220:	

scanString$55:	; parameter £temporary1420, offset 6
221:		mov [bp + 21], ax
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1421 = return_value
236:	

scanString$59:	; if £temporary1421 != 0 goto 76
237:		cmp bx, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1424 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov al, [bp + 12]
243:		and ax, 255
245:		cmp al, 0
246:		jge scanString$61
247:		neg al
249:		neg ax
251:	

scanString$61:	; if £temporary1424 == -1 goto 76
252:		cmp ax, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1430 = index
260:		mov ax, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1432 = string + £temporary1430
266:		mov si, [bp + 6]
267:		add si, ax
269:	

scanString$66:	; £temporary1431 -> £temporary1432 = *£temporary1432
271:	

scanString$67:	; £temporary1431 -> £temporary1432 = input
272:		mov al, [bp + 12]
273:		mov [si], al
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1433 = return_value
290:	

scanString$72:	; input = £temporary1433
291:		mov [bp + 12], bl
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1437 = string + index
307:		mov si, [bp + 6]
308:		add si, [bp + 10]
310:	

scanString$78:	; £temporary1436 -> £temporary1437 = *£temporary1437
312:	

scanString$79:	; £temporary1436 -> £temporary1437 = 0
313:		mov byte [si], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1440 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov al, [bp + 12]
330:		and ax, 255
332:		cmp al, 0
333:		jge scanString$85
334:		neg al
336:		neg ax
338:	

scanString$85:	; parameter £temporary1440, offset 6
339:		mov [bp + 21], ax
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1441 = return_value
354:	

scanString$89:	; if £temporary1441 != 0 goto 101
355:		cmp bx, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1444 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov al, [bp + 12]
361:		and ax, 255
363:		cmp al, 0
364:		jge scanString$91
365:		neg al
367:		neg ax
369:	

scanString$91:	; if £temporary1444 == -1 goto 101
370:		cmp ax, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1449 = return_value
392:	

scanString$97:	; input = £temporary1449
393:		mov [bp + 12], bl
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1452 = precision
411:		mov ax, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1452 <= 0 goto 124
417:		cmp ax, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1454 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov al, [bp + 12]
425:		and ax, 255
427:		cmp al, 0
428:		jge scanString$108
429:		neg al
431:		neg ax
433:	

scanString$108:	; parameter £temporary1454, offset 6
434:		mov [bp + 21], ax
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1455 = return_value
449:	

scanString$112:	; if £temporary1455 != 0 goto 124
450:		cmp bx, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1458 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov al, [bp + 12]
456:		and ax, 255
458:		cmp al, 0
459:		jge scanString$114
460:		neg al
462:		neg ax
464:	

scanString$114:	; if £temporary1458 == -1 goto 124
465:		cmp ax, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1464 = return_value
487:	

scanString$120:	; input = £temporary1464
488:		mov [bp + 12], bl
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov ax, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp ax
519:	

scanString$129:	; function end scanString
1:	

digitToValue:	; call header integral zero 0 stack zero 0
3:	

digitToValue$1:	; £temporary1475 = int_to_int input (Signed_Char -> Signed_Int)
4:		mov al, [bp + 6]
6:		and ax, 255
8:		cmp al, 0
9:		jge digitToValue$2
10:		neg al
12:		neg ax
14:	

digitToValue$2:	; parameter £temporary1475, offset 6
15:		mov [bp + 13], ax
17:	

digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

digitToValue$4:	; post call
25:	

digitToValue$5:	; £temporary1476 = return_value
30:	

digitToValue$6:	; if £temporary1476 == 0 goto 11
31:		cmp bx, 0
32:		je digitToValue$11
34:	

digitToValue$7:	; £temporary1477 = input - 48
35:		mov bl, [bp + 6]
36:		sub bl, 48
38:	

digitToValue$8:	; £temporary1478 = int_to_int £temporary1477 (Signed_Char -> Unsigned_Long_Int)
40:		and ebx, 255
42:	

digitToValue$9:	; return_value = £temporary1478
44:	

digitToValue$10:	; return
45:		mov ax, [bp]
46:		mov di, [bp + 4]
47:		mov bp, [bp + 2]
48:		jmp ax
50:	

digitToValue$11:	; call header integral zero 0 stack zero 0
52:	

digitToValue$12:	; £temporary1479 = int_to_int input (Signed_Char -> Signed_Int)
53:		mov al, [bp + 6]
55:		and ax, 255
57:		cmp al, 0
58:		jge digitToValue$13
59:		neg al
61:		neg ax
63:	

digitToValue$13:	; parameter £temporary1479, offset 6
64:		mov [bp + 13], ax
66:	

digitToValue$14:	; call function noellipse-noellipse islower
67:		mov word [bp + 7], digitToValue$15
68:		mov [bp + 9], bp
69:		add bp, 7
70:		jmp islower
72:	

digitToValue$15:	; post call
74:	

digitToValue$16:	; £temporary1480 = return_value
79:	

digitToValue$17:	; if £temporary1480 == 0 goto 23
80:		cmp bx, 0
81:		je digitToValue$23
83:	

digitToValue$18:	; £temporary1481 = input - 97
84:		mov bl, [bp + 6]
85:		sub bl, 97
87:	

digitToValue$19:	; £temporary1482 = int_to_int £temporary1481 (Signed_Char -> Unsigned_Long_Int)
89:		and ebx, 255
91:	

digitToValue$20:	; £temporary1483 = £temporary1482 + 10
92:		add ebx, 10
94:	

digitToValue$21:	; return_value = £temporary1483
96:	

digitToValue$22:	; return
97:		mov ax, [bp]
98:		mov di, [bp + 4]
99:		mov bp, [bp + 2]
100:		jmp ax
102:	

digitToValue$23:	; £temporary1484 = input - 65
103:		mov bl, [bp + 6]
104:		sub bl, 65
106:	

digitToValue$24:	; £temporary1485 = int_to_int £temporary1484 (Signed_Char -> Unsigned_Long_Int)
108:		and ebx, 255
110:	

digitToValue$25:	; £temporary1486 = £temporary1485 + 10
111:		add ebx, 10
113:	

digitToValue$26:	; return_value = £temporary1486
115:	

digitToValue$27:	; return
116:		mov ax, [bp]
117:		mov di, [bp + 4]
118:		mov bp, [bp + 2]
119:		jmp ax
121:	

digitToValue$28:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 6], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 10], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 12], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 14], scanLongInt$5
14:		mov [bp + 16], bp
15:		add bp, 14
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1491 = return_value
25:	

scanLongInt$7:	; input = £temporary1491
26:		mov [bp + 14], bl
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1492 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov al, [bp + 14]
33:		and ax, 255
35:		cmp al, 0
36:		jge scanLongInt$10
37:		neg al
39:		neg ax
41:	

scanLongInt$10:	; parameter £temporary1492, offset 6
42:		mov [bp + 21], ax
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 15], scanLongInt$12
46:		mov [bp + 17], bp
47:		add bp, 15
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1493 = return_value
57:	

scanLongInt$14:	; if £temporary1493 == 0 goto 21
58:		cmp bx, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 15], scanLongInt$17
65:		mov [bp + 17], bp
66:		add bp, 15
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1494 = return_value
76:	

scanLongInt$19:	; input = £temporary1494
77:		mov [bp + 14], bl
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 14], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 15], scanLongInt$24
90:		mov [bp + 17], bp
91:		add bp, 15
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1497 = return_value
101:	

scanLongInt$26:	; input = £temporary1497
102:		mov [bp + 14], bl
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 14], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 10], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 15], scanLongInt$32
118:		mov [bp + 17], bp
119:		add bp, 15
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1499 = return_value
129:	

scanLongInt$34:	; input = £temporary1499
130:		mov [bp + 14], bl
132:	

scanLongInt$35:	; call header integral zero 0 stack zero 0
134:	

scanLongInt$36:	; £temporary1500 = int_to_int input (Signed_Char -> Signed_Int)
135:		mov al, [bp + 14]
137:		and ax, 255
139:		cmp al, 0
140:		jge scanLongInt$37
141:		neg al
143:		neg ax
145:	

scanLongInt$37:	; parameter £temporary1500, offset 6
146:		mov [bp + 21], ax
148:	

scanLongInt$38:	; call function noellipse-noellipse isdigit
149:		mov word [bp + 15], scanLongInt$39
150:		mov [bp + 17], bp
151:		add bp, 15
152:		jmp isdigit
154:	

scanLongInt$39:	; post call
156:	

scanLongInt$40:	; £temporary1501 = return_value
161:	

scanLongInt$41:	; if £temporary1501 == 0 goto 53
162:		cmp bx, 0
163:		je scanLongInt$53
165:	

scanLongInt$42:	; £temporary1502 = longValue * 10
166:		mov eax, [bp + 6]
168:		xor edx, edx
169:		imul dword [int4$10#]
175:	

scanLongInt$43:	; £temporary1503 = input - 48
176:		mov bl, [bp + 14]
177:		sub bl, 48
179:	

scanLongInt$44:	; £temporary1504 = int_to_int £temporary1503 (Signed_Char -> Signed_Long_Int)
181:		and ebx, 255
183:		cmp bl, 0
184:		jge scanLongInt$45
185:		neg bl
187:		neg ebx
189:	

scanLongInt$45:	; longValue = £temporary1502 + £temporary1504
190:		add eax, ebx
191:		mov [bp + 6], eax
193:	

scanLongInt$46:	; call header integral zero 0 stack zero 0
195:	

scanLongInt$47:	; call function noellipse-noellipse scanChar
196:		mov word [bp + 15], scanLongInt$48
197:		mov [bp + 17], bp
198:		add bp, 15
199:		jmp scanChar
201:	

scanLongInt$48:	; post call
203:	

scanLongInt$49:	; £temporary1506 = return_value
208:	

scanLongInt$50:	; input = £temporary1506
209:		mov [bp + 14], bl
211:	

scanLongInt$51:	; found = 1
212:		mov word [bp + 12], 1
214:	

scanLongInt$52:	; goto 35
215:		jmp scanLongInt$35
217:	

scanLongInt$53:	; if minus == 0 goto 56
218:		cmp word [bp + 10], 0
219:		je scanLongInt$56
221:	

scanLongInt$54:	; £temporary1508 = -longValue
222:		mov eax, [bp + 6]
223:		neg eax
225:	

scanLongInt$55:	; longValue = £temporary1508
226:		mov [bp + 6], eax
228:	

scanLongInt$56:	; if found == 0 goto 58
229:		cmp word [bp + 12], 0
230:		je scanLongInt$58
232:	

scanLongInt$57:	; ++g_inCount
233:		inc word [g_inCount]
235:	

scanLongInt$58:	; call header integral zero 0 stack zero 0
237:	

scanLongInt$59:	; parameter input, offset 6
238:		mov al, [bp + 14]
239:		mov [bp + 21], al
241:	

scanLongInt$60:	; call function noellipse-noellipse unscanChar
242:		mov word [bp + 15], scanLongInt$61
243:		mov [bp + 17], bp
244:		add bp, 15
245:		jmp unscanChar
247:	

scanLongInt$61:	; post call
249:	

scanLongInt$62:	; return_value = longValue
250:		mov ebx, [bp + 6]
252:	

scanLongInt$63:	; return
253:		mov ax, [bp]
254:		mov di, [bp + 4]
255:		mov bp, [bp + 2]
256:		jmp ax
258:	

scanLongInt$64:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 10], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 18], scanUnsignedLongInt$3
8:		mov [bp + 20], bp
9:		add bp, 18
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1516 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1516
20:		mov [bp + 18], bl
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 19], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1517 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 18]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanUnsignedLongInt$9
34:		neg al
36:		neg ax
38:	

scanUnsignedLongInt$9:	; parameter £temporary1517, offset 6
39:		mov [bp + 27], ax
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 21], scanUnsignedLongInt$11
43:		mov [bp + 23], bp
44:		add bp, 21
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1518 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1518 == 0 goto 20
55:		cmp bx, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 21], scanUnsignedLongInt$16
62:		mov [bp + 23], bp
63:		add bp, 21
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1519 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1519
74:		mov [bp + 18], bl
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 48 goto 49
80:		cmp byte [bp + 18], 48
81:		jne scanUnsignedLongInt$49
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 21], scanUnsignedLongInt$23
87:		mov [bp + 23], bp
88:		add bp, 21
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1522 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1522
99:		mov [bp + 18], bl
101:	

scanUnsignedLongInt$26:	; call header integral zero 0 stack zero 0
103:	

scanUnsignedLongInt$27:	; £temporary1523 = int_to_int input (Signed_Char -> Signed_Int)
104:		mov al, [bp + 18]
106:		and ax, 255
108:		cmp al, 0
109:		jge scanUnsignedLongInt$28
110:		neg al
112:		neg ax
114:	

scanUnsignedLongInt$28:	; parameter £temporary1523, offset 6
115:		mov [bp + 27], ax
117:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse tolower
118:		mov word [bp + 21], scanUnsignedLongInt$30
119:		mov [bp + 23], bp
120:		add bp, 21
121:		jmp tolower
123:	

scanUnsignedLongInt$30:	; post call
125:	

scanUnsignedLongInt$31:	; £temporary1524 = return_value
130:	

scanUnsignedLongInt$32:	; if £temporary1524 != 120 goto 44
131:		cmp bx, 120
132:		jne scanUnsignedLongInt$44
134:	

scanUnsignedLongInt$33:	; if base != 0 goto 36
135:		cmp dword [bp + 6], 0
136:		jne scanUnsignedLongInt$36
138:	

scanUnsignedLongInt$34:	; £temporary1530 = 16
139:		mov eax, 16
141:	

scanUnsignedLongInt$35:	; goto 37
142:		jmp scanUnsignedLongInt$37
144:	

scanUnsignedLongInt$36:	; £temporary1530 = base
145:		mov eax, [bp + 6]
147:	

scanUnsignedLongInt$37:	; base = £temporary1530
148:		mov [bp + 6], eax
150:	

scanUnsignedLongInt$38:	; call header integral zero 0 stack zero 0
152:	

scanUnsignedLongInt$39:	; call function noellipse-noellipse scanChar
153:		mov word [bp + 21], scanUnsignedLongInt$40
154:		mov [bp + 23], bp
155:		add bp, 21
156:		jmp scanChar
158:	

scanUnsignedLongInt$40:	; post call
160:	

scanUnsignedLongInt$41:	; £temporary1531 = return_value
165:	

scanUnsignedLongInt$42:	; input = £temporary1531
166:		mov [bp + 18], bl
168:	

scanUnsignedLongInt$43:	; goto 49
169:		jmp scanUnsignedLongInt$49
171:	

scanUnsignedLongInt$44:	; if base != 0 goto 47
172:		cmp dword [bp + 6], 0
173:		jne scanUnsignedLongInt$47
175:	

scanUnsignedLongInt$45:	; £temporary1536 = 8
176:		mov eax, 8
178:	

scanUnsignedLongInt$46:	; goto 48
179:		jmp scanUnsignedLongInt$48
181:	

scanUnsignedLongInt$47:	; £temporary1536 = base
182:		mov eax, [bp + 6]
184:	

scanUnsignedLongInt$48:	; base = £temporary1536
185:		mov [bp + 6], eax
187:	

scanUnsignedLongInt$49:	; if base != 0 goto 51
188:		cmp dword [bp + 6], 0
189:		jne scanUnsignedLongInt$51
191:	

scanUnsignedLongInt$50:	; base = 10
192:		mov dword [bp + 6], 10
194:	

scanUnsignedLongInt$51:	; call header integral zero 0 stack zero 0
196:	

scanUnsignedLongInt$52:	; £temporary1538 = int_to_int input (Signed_Char -> Signed_Int)
197:		mov al, [bp + 18]
199:		and ax, 255
201:		cmp al, 0
202:		jge scanUnsignedLongInt$53
203:		neg al
205:		neg ax
207:	

scanUnsignedLongInt$53:	; parameter £temporary1538, offset 6
208:		mov [bp + 27], ax
210:	

scanUnsignedLongInt$54:	; call function noellipse-noellipse isxdigit
211:		mov word [bp + 21], scanUnsignedLongInt$55
212:		mov [bp + 23], bp
213:		add bp, 21
214:		jmp isxdigit
216:	

scanUnsignedLongInt$55:	; post call
218:	

scanUnsignedLongInt$56:	; £temporary1539 = return_value
223:	

scanUnsignedLongInt$57:	; if £temporary1539 == 0 goto 74
224:		cmp bx, 0
225:		je scanUnsignedLongInt$74
227:	

scanUnsignedLongInt$58:	; call header integral zero 0 stack zero 0
229:	

scanUnsignedLongInt$59:	; parameter input, offset 6
230:		mov al, [bp + 18]
231:		mov [bp + 27], al
233:	

scanUnsignedLongInt$60:	; call function noellipse-noellipse digitToValue
234:		mov word [bp + 21], scanUnsignedLongInt$61
235:		mov [bp + 23], bp
236:		add bp, 21
237:		jmp digitToValue
239:	

scanUnsignedLongInt$61:	; post call
241:	

scanUnsignedLongInt$62:	; £temporary1540 = return_value
246:	

scanUnsignedLongInt$63:	; digit = £temporary1540
247:		mov [bp + 14], ebx
249:	

scanUnsignedLongInt$64:	; if digit >= base goto 74
250:		mov eax, [bp + 6]
251:		cmp [bp + 14], eax
252:		jae scanUnsignedLongInt$74
254:	

scanUnsignedLongInt$65:	; £temporary1542 = unsignedLongValue * base
255:		mov eax, [bp + 10]
257:		xor edx, edx
258:		mul dword [bp + 6]
264:	

scanUnsignedLongInt$66:	; unsignedLongValue = £temporary1542 + digit
265:		add eax, [bp + 14]
266:		mov [bp + 10], eax
268:	

scanUnsignedLongInt$67:	; found = 1
269:		mov word [bp + 19], 1
271:	

scanUnsignedLongInt$68:	; call header integral zero 0 stack zero 0
273:	

scanUnsignedLongInt$69:	; call function noellipse-noellipse scanChar
274:		mov word [bp + 21], scanUnsignedLongInt$70
275:		mov [bp + 23], bp
276:		add bp, 21
277:		jmp scanChar
279:	

scanUnsignedLongInt$70:	; post call
281:	

scanUnsignedLongInt$71:	; £temporary1544 = return_value
286:	

scanUnsignedLongInt$72:	; input = £temporary1544
287:		mov [bp + 18], bl
289:	

scanUnsignedLongInt$73:	; goto 51
290:		jmp scanUnsignedLongInt$51
292:	

scanUnsignedLongInt$74:	; if found == 0 goto 76
293:		cmp word [bp + 19], 0
294:		je scanUnsignedLongInt$76
296:	

scanUnsignedLongInt$75:	; ++g_inCount
297:		inc word [g_inCount]
299:	

scanUnsignedLongInt$76:	; call header integral zero 0 stack zero 0
301:	

scanUnsignedLongInt$77:	; parameter input, offset 6
302:		mov al, [bp + 18]
303:		mov [bp + 27], al
305:	

scanUnsignedLongInt$78:	; call function noellipse-noellipse unscanChar
306:		mov word [bp + 21], scanUnsignedLongInt$79
307:		mov [bp + 23], bp
308:		add bp, 21
309:		jmp unscanChar
311:	

scanUnsignedLongInt$79:	; post call
313:	

scanUnsignedLongInt$80:	; return_value = unsignedLongValue
314:		mov ebx, [bp + 10]
316:	

scanUnsignedLongInt$81:	; return
317:		mov ax, [bp]
318:		mov di, [bp + 4]
319:		mov bp, [bp + 2]
320:		jmp ax
322:	

scanUnsignedLongInt$82:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1554 = return_value
34:	

scanLongDouble$10:	; input = £temporary1554
35:		mov [bp + 26], bl
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1555 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov al, [bp + 26]
42:		and ax, 255
44:		cmp al, 0
45:		jge scanLongDouble$13
46:		neg al
48:		neg ax
50:	

scanLongDouble$13:	; parameter £temporary1555, offset 6
51:		mov [bp + 33], ax
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1556 = return_value
66:	

scanLongDouble$17:	; if £temporary1556 == 0 goto 24
67:		cmp bx, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1557 = return_value
85:	

scanLongDouble$22:	; input = £temporary1557
86:		mov [bp + 26], bl
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1560 = return_value
110:	

scanLongDouble$29:	; input = £temporary1560
111:		mov [bp + 26], bl
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1562 = return_value
138:	

scanLongDouble$37:	; input = £temporary1562
139:		mov [bp + 26], bl
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1563 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov al, [bp + 26]
146:		and ax, 255
148:		cmp al, 0
149:		jge scanLongDouble$40
150:		neg al
152:		neg ax
154:	

scanLongDouble$40:	; parameter £temporary1563, offset 6
155:		mov [bp + 33], ax
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1564 = return_value
170:	

scanLongDouble$44:	; if £temporary1564 == 0 goto 60
171:		cmp bx, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1565 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1566 = input - 48
184:		mov al, [bp + 26]
185:		sub al, 48
187:	

scanLongDouble$49:	; £temporary1568 = int_to_int £temporary1566 (Signed_Char -> Signed_Int)
189:		and ax, 255
191:		cmp al, 0
192:		jge scanLongDouble$50
193:		neg al
195:		neg ax
197:	

scanLongDouble$50:	; £temporary1567 = int_to_float £temporary1568 (Signed_Int -> Long_Double)
198:		mov [container2bytes#], ax
199:		fild word [container2bytes#]
201:	

scanLongDouble$51:	; £temporary1569 = £temporary1565 + £temporary1567
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1570 = return_value
222:	

scanLongDouble$57:	; input = £temporary1570
223:		mov [bp + 26], bl
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1573 = return_value
250:	

scanLongDouble$65:	; input = £temporary1573
251:		mov [bp + 26], bl
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1574 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov al, [bp + 26]
258:		and ax, 255
260:		cmp al, 0
261:		jge scanLongDouble$68
262:		neg al
264:		neg ax
266:	

scanLongDouble$68:	; parameter £temporary1574, offset 6
267:		mov [bp + 33], ax
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1575 = return_value
282:	

scanLongDouble$72:	; if £temporary1575 == 0 goto 92
283:		cmp bx, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1576 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1577 = input - 48
305:		mov al, [bp + 26]
306:		sub al, 48
308:	

scanLongDouble$80:	; £temporary1579 = int_to_int £temporary1577 (Signed_Char -> Signed_Int)
310:		and ax, 255
312:		cmp al, 0
313:		jge scanLongDouble$81
314:		neg al
316:		neg ax
318:	

scanLongDouble$81:	; £temporary1578 = int_to_float £temporary1579 (Signed_Int -> Long_Double)
319:		mov [container2bytes#], ax
320:		fild word [container2bytes#]
322:	

scanLongDouble$82:	; £temporary1580 = factor * £temporary1578
323:		fmul
325:	

scanLongDouble$83:	; £temporary1581 = value + £temporary1580
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1582 = return_value
346:	

scanLongDouble$89:	; input = £temporary1582
347:		mov [bp + 26], bl
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; parameter input, offset 6
358:		mov al, [bp + 26]
359:		mov [bp + 33], al
361:	

scanLongDouble$94:	; call function noellipse-noellipse unscanChar
362:		mov word [bp + 27], scanLongDouble$95
363:		mov [bp + 29], bp
364:		add bp, 27
365:		jmp unscanChar
367:	

scanLongDouble$95:	; post call
369:	

scanLongDouble$96:	; call header integral zero 0 stack zero 0
371:	

scanLongDouble$97:	; £temporary1585 = int_to_int input (Signed_Char -> Signed_Int)
372:		mov al, [bp + 26]
374:		and ax, 255
376:		cmp al, 0
377:		jge scanLongDouble$98
378:		neg al
380:		neg ax
382:	

scanLongDouble$98:	; parameter £temporary1585, offset 6
383:		mov [bp + 33], ax
385:	

scanLongDouble$99:	; call function noellipse-noellipse tolower
386:		mov word [bp + 27], scanLongDouble$100
387:		mov [bp + 29], bp
388:		add bp, 27
389:		jmp tolower
391:	

scanLongDouble$100:	; post call
393:	

scanLongDouble$101:	; £temporary1586 = return_value
398:	

scanLongDouble$102:	; if £temporary1586 != 101 goto 121
399:		cmp bx, 101
400:		jne scanLongDouble$121
402:	

scanLongDouble$103:	; call header integral zero 0 stack zero 0
404:	

scanLongDouble$104:	; call function noellipse-noellipse scanLongInt
405:		mov word [bp + 27], scanLongDouble$105
406:		mov [bp + 29], bp
407:		add bp, 27
408:		jmp scanLongInt
410:	

scanLongDouble$105:	; post call
412:	

scanLongDouble$106:	; £temporary1588 = return_value
417:	

scanLongDouble$107:	; £temporary1589 = int_to_float £temporary1588 (Signed_Long_Int -> Double)
418:		mov [container4bytes#], ebx
419:		fild dword [container4bytes#]
421:	

scanLongDouble$108:	; pop float exponent
422:		fstp qword [bp + 27]
424:	

scanLongDouble$109:	; push float value
425:		fld qword [bp + 10]
427:	

scanLongDouble$110:	; call header integral zero 0 stack no zero 1
428:		fstp qword [bp + 35]
430:	

scanLongDouble$111:	; push float 10.0
431:		fld qword [float8$10.0#]
433:	

scanLongDouble$112:	; parameter 10.0, offset 6
434:		fstp qword [bp + 49]
436:	

scanLongDouble$113:	; push float exponent
437:		fld qword [bp + 27]
439:	

scanLongDouble$114:	; parameter exponent, offset 14
440:		fstp qword [bp + 57]
442:	

scanLongDouble$115:	; call function noellipse-noellipse pow
443:		mov word [bp + 43], scanLongDouble$116
444:		mov [bp + 45], bp
445:		add bp, 43
446:		jmp pow
448:	

scanLongDouble$116:	; post call
449:		fstp qword [bp + 43]
450:		fld qword [bp + 35]
451:		fld qword [bp + 43]
453:	

scanLongDouble$117:	; £temporary1590 = return_value
455:	

scanLongDouble$118:	; £temporary1591 = value * £temporary1590
456:		fmul
458:	

scanLongDouble$119:	; pop float value
459:		fstp qword [bp + 10]
461:	

scanLongDouble$120:	; goto 125
462:		jmp scanLongDouble$125
464:	

scanLongDouble$121:	; call header integral zero 0 stack zero 0
466:	

scanLongDouble$122:	; parameter input, offset 6
467:		mov al, [bp + 26]
468:		mov [bp + 33], al
470:	

scanLongDouble$123:	; call function noellipse-noellipse unscanChar
471:		mov word [bp + 27], scanLongDouble$124
472:		mov [bp + 29], bp
473:		add bp, 27
474:		jmp unscanChar
476:	

scanLongDouble$124:	; post call
478:	

scanLongDouble$125:	; if minus == 0 goto 129
479:		cmp word [bp + 6], 0
480:		je scanLongDouble$129
482:	

scanLongDouble$126:	; push float value
483:		fld qword [bp + 10]
485:	

scanLongDouble$127:	; £temporary1593 = -value
486:		fchs
488:	

scanLongDouble$128:	; pop float value
489:		fstp qword [bp + 10]
491:	

scanLongDouble$129:	; if found == 0 goto 131
492:		cmp word [bp + 8], 0
493:		je scanLongDouble$131
495:	

scanLongDouble$130:	; ++g_inCount
496:		inc word [g_inCount]
498:	

scanLongDouble$131:	; push float value
499:		fld qword [bp + 10]
501:	

scanLongDouble$132:	; return_value = value
503:	

scanLongDouble$133:	; return
504:		mov ax, [bp]
505:		mov di, [bp + 4]
506:		mov bp, [bp + 2]
507:		jmp ax
509:	

scanLongDouble$134:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1606 = format + index
26:		mov si, [bp + 6]
27:		add si, [bp + 31]
29:	

scanFormat$9:	; £temporary1605 -> £temporary1606 = *£temporary1606
31:	

scanFormat$10:	; if £temporary1605 -> £temporary1606 == 0 goto 325
32:		cmp byte [si], 0
33:		je scanFormat$325
35:	

scanFormat$11:	; £temporary1610 = format + index
36:		mov si, [bp + 6]
37:		add si, [bp + 31]
39:	

scanFormat$12:	; £temporary1609 -> £temporary1610 = *£temporary1610
41:	

scanFormat$13:	; c = £temporary1609 -> £temporary1610
42:		mov al, [si]
43:		mov [bp + 10], al
45:	

scanFormat$14:	; £temporary1611 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov al, [bp + 10]
48:		and ax, 255
50:		cmp al, 0
51:		jge scanFormat$15
52:		neg al
54:		neg ax
56:	

scanFormat$15:	; d = £temporary1611 + 1
57:		add ax, 1
58:		mov [bp + 55], ax
60:	

scanFormat$16:	; if percent == 0 goto 317
61:		cmp word [bp + 13], 0
62:		je scanFormat$317
64:	

scanFormat$17:	; £temporary1613 = d - 1
65:		mov ax, [bp + 55]
66:		sub ax, 1
68:	

scanFormat$18:	; case £temporary1613 == 104 goto 36
69:		cmp ax, 104
70:		je scanFormat$36
72:	

scanFormat$19:	; case £temporary1613 == 108 goto 38
73:		cmp ax, 108
74:		je scanFormat$38
76:	

scanFormat$20:	; case £temporary1613 == 76 goto 40
77:		cmp ax, 76
78:		je scanFormat$40
80:	

scanFormat$21:	; case £temporary1613 == 42 goto 42
81:		cmp ax, 42
82:		je scanFormat$42
84:	

scanFormat$22:	; case £temporary1613 == 99 goto 44
85:		cmp ax, 99
86:		je scanFormat$44
88:	

scanFormat$23:	; case £temporary1613 == 115 goto 62
89:		cmp ax, 115
90:		je scanFormat$62
92:	

scanFormat$24:	; case £temporary1613 == 100 goto 81
93:		cmp ax, 100
94:		je scanFormat$81
96:	

scanFormat$25:	; case £temporary1613 == 105 goto 81
97:		cmp ax, 105
98:		je scanFormat$81
100:	

scanFormat$26:	; case £temporary1613 == 111 goto 116
101:		cmp ax, 111
102:		je scanFormat$116
104:	

scanFormat$27:	; case £temporary1613 == 120 goto 152
105:		cmp ax, 120
106:		je scanFormat$152
108:	

scanFormat$28:	; case £temporary1613 == 117 goto 188
109:		cmp ax, 117
110:		je scanFormat$188
112:	

scanFormat$29:	; case £temporary1613 == 103 goto 224
113:		cmp ax, 103
114:		je scanFormat$224
116:	

scanFormat$30:	; case £temporary1613 == 102 goto 224
117:		cmp ax, 102
118:		je scanFormat$224
120:	

scanFormat$31:	; case £temporary1613 == 101 goto 224
121:		cmp ax, 101
122:		je scanFormat$224
124:	

scanFormat$32:	; case £temporary1613 == 91 goto 260
125:		cmp ax, 91
126:		je scanFormat$260
128:	

scanFormat$33:	; case £temporary1613 == 110 goto 301
129:		cmp ax, 110
130:		je scanFormat$301
132:	

scanFormat$34:	; case end £temporary1613
134:	

scanFormat$35:	; goto 310
135:		jmp scanFormat$310
137:	

scanFormat$36:	; shortInt = 1
138:		mov word [bp + 15], 1
140:	

scanFormat$37:	; goto 323
141:		jmp scanFormat$323
143:	

scanFormat$38:	; longIntOrDouble = 1
144:		mov word [bp + 17], 1
146:	

scanFormat$39:	; goto 323
147:		jmp scanFormat$323
149:	

scanFormat$40:	; longDouble = 1
150:		mov word [bp + 19], 1
152:	

scanFormat$41:	; goto 323
153:		jmp scanFormat$323
155:	

scanFormat$42:	; star = 1
156:		mov word [bp + 21], 1
158:	

scanFormat$43:	; goto 323
159:		jmp scanFormat$323
161:	

scanFormat$44:	; call header integral zero 0 stack zero 0
163:	

scanFormat$45:	; call function noellipse-noellipse scanChar
164:		mov word [bp + 57], scanFormat$46
165:		mov [bp + 59], bp
166:		add bp, 57
167:		jmp scanChar
169:	

scanFormat$46:	; post call
171:	

scanFormat$47:	; £temporary1614 = return_value
176:	

scanFormat$48:	; charValue = £temporary1614
177:		mov [bp + 57], bl
179:	

scanFormat$49:	; if star != 0 goto 57
180:		cmp word [bp + 21], 0
181:		jne scanFormat$57
183:	

scanFormat$50:	; arg_list = arg_list + 2
184:		add word [bp + 8], 2
186:	

scanFormat$51:	; £temporary1618 = arg_list - 2
187:		mov si, [bp + 8]
188:		sub si, 2
190:	

scanFormat$52:	; £temporary1619 = int_to_int £temporary1618 (Signed_Int -> Pointer)
193:	

scanFormat$53:	; £temporary1620 -> £temporary1619 = *£temporary1619
195:	

scanFormat$54:	; charPtr = £temporary1620 -> £temporary1619
196:		mov ax, [si]
197:		mov [bp + 11], ax
199:	

scanFormat$55:	; £temporary1621 -> charPtr = *charPtr
200:		mov si, [bp + 11]
202:	

scanFormat$56:	; £temporary1621 -> charPtr = charValue
203:		mov al, [bp + 57]
204:		mov [si], al
206:	

scanFormat$57:	; percent = 0
207:		mov word [bp + 13], 0
209:	

scanFormat$58:	; £temporary1622 = int_to_int charValue (Signed_Char -> Signed_Int)
210:		mov al, [bp + 57]
212:		and ax, 255
214:		cmp al, 0
215:		jge scanFormat$59
216:		neg al
218:		neg ax
220:	

scanFormat$59:	; if £temporary1622 == -1 goto 323
221:		cmp ax, -1
222:		je scanFormat$323
224:	

scanFormat$60:	; ++g_inCount
225:		inc word [g_inCount]
227:	

scanFormat$61:	; goto 323
228:		jmp scanFormat$323
230:	

scanFormat$62:	; if star != 0 goto 74
231:		cmp word [bp + 21], 0
232:		jne scanFormat$74
234:	

scanFormat$63:	; arg_list = arg_list + 2
235:		add word [bp + 8], 2
237:	

scanFormat$64:	; £temporary1628 = arg_list - 2
238:		mov si, [bp + 8]
239:		sub si, 2
241:	

scanFormat$65:	; £temporary1629 = int_to_int £temporary1628 (Signed_Int -> Pointer)
244:	

scanFormat$66:	; £temporary1630 -> £temporary1629 = *£temporary1629
246:	

scanFormat$67:	; charPtr = £temporary1630 -> £temporary1629
247:		mov ax, [si]
248:		mov [bp + 11], ax
250:	

scanFormat$68:	; call header integral zero 0 stack zero 0
252:	

scanFormat$69:	; parameter charPtr, offset 6
253:		mov ax, [bp + 11]
254:		mov [bp + 63], ax
256:	

scanFormat$70:	; parameter 0, offset 8
257:		mov word [bp + 65], 0
259:	

scanFormat$71:	; call function noellipse-noellipse scanString
260:		mov word [bp + 57], scanFormat$72
261:		mov [bp + 59], bp
262:		add bp, 57
263:		jmp scanString
265:	

scanFormat$72:	; post call
267:	

scanFormat$73:	; goto 79
268:		jmp scanFormat$79
270:	

scanFormat$74:	; call header integral zero 0 stack zero 0
272:	

scanFormat$75:	; parameter 0, offset 6
273:		mov word [bp + 63], 0
275:	

scanFormat$76:	; parameter 0, offset 8
276:		mov word [bp + 65], 0
278:	

scanFormat$77:	; call function noellipse-noellipse scanString
279:		mov word [bp + 57], scanFormat$78
280:		mov [bp + 59], bp
281:		add bp, 57
282:		jmp scanString
284:	

scanFormat$78:	; post call
286:	

scanFormat$79:	; percent = 0
287:		mov word [bp + 13], 0
289:	

scanFormat$80:	; goto 323
290:		jmp scanFormat$323
292:	

scanFormat$81:	; call header integral zero 0 stack zero 0
294:	

scanFormat$82:	; call function noellipse-noellipse scanLongInt
295:		mov word [bp + 57], scanFormat$83
296:		mov [bp + 59], bp
297:		add bp, 57
298:		jmp scanLongInt
300:	

scanFormat$83:	; post call
302:	

scanFormat$84:	; £temporary1633 = return_value
307:	

scanFormat$85:	; longValue = £temporary1633
308:		mov [bp + 23], ebx
310:	

scanFormat$86:	; if star != 0 goto 114
311:		cmp word [bp + 21], 0
312:		jne scanFormat$114
314:	

scanFormat$87:	; if shortInt == 0 goto 97
315:		cmp word [bp + 15], 0
316:		je scanFormat$97
318:	

scanFormat$88:	; arg_list = arg_list + 2
319:		add word [bp + 8], 2
321:	

scanFormat$89:	; £temporary1637 = arg_list - 2
322:		mov si, [bp + 8]
323:		sub si, 2
325:	

scanFormat$90:	; £temporary1638 = int_to_int £temporary1637 (Signed_Int -> Pointer)
328:	

scanFormat$91:	; £temporary1639 -> £temporary1638 = *£temporary1638
330:	

scanFormat$92:	; shortPtr = £temporary1639 -> £temporary1638
331:		mov ax, [si]
332:		mov [bp + 29], ax
334:	

scanFormat$93:	; £temporary1640 -> shortPtr = *shortPtr
335:		mov si, [bp + 29]
337:	

scanFormat$94:	; £temporary1641 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
338:		mov eax, [bp + 23]
341:		cmp eax, 0
342:		jge scanFormat$95
343:		neg eax
345:		neg al
347:	

scanFormat$95:	; £temporary1640 -> shortPtr = £temporary1641
348:		mov [si], al
350:	

scanFormat$96:	; goto 114
351:		jmp scanFormat$114
353:	

scanFormat$97:	; if longIntOrDouble != 0 goto 107
354:		cmp word [bp + 17], 0
355:		jne scanFormat$107
357:	

scanFormat$98:	; arg_list = arg_list + 2
358:		add word [bp + 8], 2
360:	

scanFormat$99:	; £temporary1645 = arg_list - 2
361:		mov si, [bp + 8]
362:		sub si, 2
364:	

scanFormat$100:	; £temporary1646 = int_to_int £temporary1645 (Signed_Int -> Pointer)
367:	

scanFormat$101:	; £temporary1647 -> £temporary1646 = *£temporary1646
369:	

scanFormat$102:	; intPtr = £temporary1647 -> £temporary1646
370:		mov ax, [si]
371:		mov [bp + 33], ax
373:	

scanFormat$103:	; £temporary1648 -> intPtr = *intPtr
374:		mov si, [bp + 33]
376:	

scanFormat$104:	; £temporary1649 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
377:		mov eax, [bp + 23]
380:		cmp eax, 0
381:		jge scanFormat$105
382:		neg eax
384:		neg ax
386:	

scanFormat$105:	; £temporary1648 -> intPtr = £temporary1649
387:		mov [si], ax
389:	

scanFormat$106:	; goto 114
390:		jmp scanFormat$114
392:	

scanFormat$107:	; arg_list = arg_list + 2
393:		add word [bp + 8], 2
395:	

scanFormat$108:	; £temporary1651 = arg_list - 2
396:		mov si, [bp + 8]
397:		sub si, 2
399:	

scanFormat$109:	; £temporary1652 = int_to_int £temporary1651 (Signed_Int -> Pointer)
402:	

scanFormat$110:	; £temporary1653 -> £temporary1652 = *£temporary1652
404:	

scanFormat$111:	; longPtr = £temporary1653 -> £temporary1652
405:		mov ax, [si]
406:		mov [bp + 27], ax
408:	

scanFormat$112:	; £temporary1654 -> longPtr = *longPtr
409:		mov si, [bp + 27]
411:	

scanFormat$113:	; £temporary1654 -> longPtr = longValue
412:		mov eax, [bp + 23]
413:		mov [si], eax
415:	

scanFormat$114:	; percent = 0
416:		mov word [bp + 13], 0
418:	

scanFormat$115:	; goto 323
419:		jmp scanFormat$323
421:	

scanFormat$116:	; call header integral zero 0 stack zero 0
423:	

scanFormat$117:	; parameter 8, offset 6
424:		mov dword [bp + 63], 8
426:	

scanFormat$118:	; call function noellipse-noellipse scanUnsignedLongInt
427:		mov word [bp + 57], scanFormat$119
428:		mov [bp + 59], bp
429:		add bp, 57
430:		jmp scanUnsignedLongInt
432:	

scanFormat$119:	; post call
434:	

scanFormat$120:	; £temporary1656 = return_value
439:	

scanFormat$121:	; unsignedLongValue = £temporary1656
440:		mov [bp + 37], ebx
442:	

scanFormat$122:	; if star != 0 goto 150
443:		cmp word [bp + 21], 0
444:		jne scanFormat$150
446:	

scanFormat$123:	; if shortInt == 0 goto 133
447:		cmp word [bp + 15], 0
448:		je scanFormat$133
450:	

scanFormat$124:	; arg_list = arg_list + 2
451:		add word [bp + 8], 2
453:	

scanFormat$125:	; £temporary1660 = arg_list - 2
454:		mov si, [bp + 8]
455:		sub si, 2
457:	

scanFormat$126:	; £temporary1661 = int_to_int £temporary1660 (Signed_Int -> Pointer)
460:	

scanFormat$127:	; £temporary1662 -> £temporary1661 = *£temporary1661
462:	

scanFormat$128:	; unsignedShortPtr = £temporary1662 -> £temporary1661
463:		mov ax, [si]
464:		mov [bp + 43], ax
466:	

scanFormat$129:	; £temporary1663 -> unsignedShortPtr = *unsignedShortPtr
467:		mov si, [bp + 43]
469:	

scanFormat$130:	; £temporary1664 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
470:		mov eax, [bp + 37]
473:	

scanFormat$131:	; £temporary1663 -> unsignedShortPtr = £temporary1664
474:		mov [si], al
476:	

scanFormat$132:	; goto 150
477:		jmp scanFormat$150
479:	

scanFormat$133:	; if longIntOrDouble != 0 goto 143
480:		cmp word [bp + 17], 0
481:		jne scanFormat$143
483:	

scanFormat$134:	; arg_list = arg_list + 2
484:		add word [bp + 8], 2
486:	

scanFormat$135:	; £temporary1668 = arg_list - 2
487:		mov si, [bp + 8]
488:		sub si, 2
490:	

scanFormat$136:	; £temporary1669 = int_to_int £temporary1668 (Signed_Int -> Pointer)
493:	

scanFormat$137:	; £temporary1670 -> £temporary1669 = *£temporary1669
495:	

scanFormat$138:	; unsignedIntPtr = £temporary1670 -> £temporary1669
496:		mov ax, [si]
497:		mov [bp + 45], ax
499:	

scanFormat$139:	; £temporary1671 -> unsignedIntPtr = *unsignedIntPtr
500:		mov si, [bp + 45]
502:	

scanFormat$140:	; £temporary1672 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
503:		mov eax, [bp + 37]
506:	

scanFormat$141:	; £temporary1671 -> unsignedIntPtr = £temporary1672
507:		mov [si], ax
509:	

scanFormat$142:	; goto 150
510:		jmp scanFormat$150
512:	

scanFormat$143:	; arg_list = arg_list + 2
513:		add word [bp + 8], 2
515:	

scanFormat$144:	; £temporary1674 = arg_list - 2
516:		mov si, [bp + 8]
517:		sub si, 2
519:	

scanFormat$145:	; £temporary1675 = int_to_int £temporary1674 (Signed_Int -> Pointer)
522:	

scanFormat$146:	; £temporary1676 -> £temporary1675 = *£temporary1675
524:	

scanFormat$147:	; unsignedLongPtr = £temporary1676 -> £temporary1675
525:		mov ax, [si]
526:		mov [bp + 41], ax
528:	

scanFormat$148:	; £temporary1677 -> unsignedLongPtr = *unsignedLongPtr
529:		mov si, [bp + 41]
531:	

scanFormat$149:	; £temporary1677 -> unsignedLongPtr = unsignedLongValue
532:		mov eax, [bp + 37]
533:		mov [si], eax
535:	

scanFormat$150:	; percent = 0
536:		mov word [bp + 13], 0
538:	

scanFormat$151:	; goto 323
539:		jmp scanFormat$323
541:	

scanFormat$152:	; call header integral zero 0 stack zero 0
543:	

scanFormat$153:	; parameter 16, offset 6
544:		mov dword [bp + 63], 16
546:	

scanFormat$154:	; call function noellipse-noellipse scanUnsignedLongInt
547:		mov word [bp + 57], scanFormat$155
548:		mov [bp + 59], bp
549:		add bp, 57
550:		jmp scanUnsignedLongInt
552:	

scanFormat$155:	; post call
554:	

scanFormat$156:	; £temporary1679 = return_value
559:	

scanFormat$157:	; unsignedLongValue = £temporary1679
560:		mov [bp + 37], ebx
562:	

scanFormat$158:	; if star != 0 goto 186
563:		cmp word [bp + 21], 0
564:		jne scanFormat$186
566:	

scanFormat$159:	; if shortInt == 0 goto 169
567:		cmp word [bp + 15], 0
568:		je scanFormat$169
570:	

scanFormat$160:	; arg_list = arg_list + 2
571:		add word [bp + 8], 2
573:	

scanFormat$161:	; £temporary1683 = arg_list - 2
574:		mov si, [bp + 8]
575:		sub si, 2
577:	

scanFormat$162:	; £temporary1684 = int_to_int £temporary1683 (Signed_Int -> Pointer)
580:	

scanFormat$163:	; £temporary1685 -> £temporary1684 = *£temporary1684
582:	

scanFormat$164:	; unsignedShortPtr = £temporary1685 -> £temporary1684
583:		mov ax, [si]
584:		mov [bp + 43], ax
586:	

scanFormat$165:	; £temporary1686 -> unsignedShortPtr = *unsignedShortPtr
587:		mov si, [bp + 43]
589:	

scanFormat$166:	; £temporary1687 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
590:		mov eax, [bp + 37]
593:	

scanFormat$167:	; £temporary1686 -> unsignedShortPtr = £temporary1687
594:		mov [si], al
596:	

scanFormat$168:	; goto 186
597:		jmp scanFormat$186
599:	

scanFormat$169:	; if longIntOrDouble != 0 goto 179
600:		cmp word [bp + 17], 0
601:		jne scanFormat$179
603:	

scanFormat$170:	; arg_list = arg_list + 2
604:		add word [bp + 8], 2
606:	

scanFormat$171:	; £temporary1691 = arg_list - 2
607:		mov si, [bp + 8]
608:		sub si, 2
610:	

scanFormat$172:	; £temporary1692 = int_to_int £temporary1691 (Signed_Int -> Pointer)
613:	

scanFormat$173:	; £temporary1693 -> £temporary1692 = *£temporary1692
615:	

scanFormat$174:	; unsignedIntPtr = £temporary1693 -> £temporary1692
616:		mov ax, [si]
617:		mov [bp + 45], ax
619:	

scanFormat$175:	; £temporary1694 -> unsignedIntPtr = *unsignedIntPtr
620:		mov si, [bp + 45]
622:	

scanFormat$176:	; £temporary1695 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
623:		mov eax, [bp + 37]
626:	

scanFormat$177:	; £temporary1694 -> unsignedIntPtr = £temporary1695
627:		mov [si], ax
629:	

scanFormat$178:	; goto 186
630:		jmp scanFormat$186
632:	

scanFormat$179:	; arg_list = arg_list + 2
633:		add word [bp + 8], 2
635:	

scanFormat$180:	; £temporary1697 = arg_list - 2
636:		mov si, [bp + 8]
637:		sub si, 2
639:	

scanFormat$181:	; £temporary1698 = int_to_int £temporary1697 (Signed_Int -> Pointer)
642:	

scanFormat$182:	; £temporary1699 -> £temporary1698 = *£temporary1698
644:	

scanFormat$183:	; unsignedLongPtr = £temporary1699 -> £temporary1698
645:		mov ax, [si]
646:		mov [bp + 41], ax
648:	

scanFormat$184:	; £temporary1700 -> unsignedLongPtr = *unsignedLongPtr
649:		mov si, [bp + 41]
651:	

scanFormat$185:	; £temporary1700 -> unsignedLongPtr = unsignedLongValue
652:		mov eax, [bp + 37]
653:		mov [si], eax
655:	

scanFormat$186:	; percent = 0
656:		mov word [bp + 13], 0
658:	

scanFormat$187:	; goto 323
659:		jmp scanFormat$323
661:	

scanFormat$188:	; call header integral zero 0 stack zero 0
663:	

scanFormat$189:	; parameter 0, offset 6
664:		mov dword [bp + 63], 0
666:	

scanFormat$190:	; call function noellipse-noellipse scanUnsignedLongInt
667:		mov word [bp + 57], scanFormat$191
668:		mov [bp + 59], bp
669:		add bp, 57
670:		jmp scanUnsignedLongInt
672:	

scanFormat$191:	; post call
674:	

scanFormat$192:	; £temporary1702 = return_value
679:	

scanFormat$193:	; unsignedLongValue = £temporary1702
680:		mov [bp + 37], ebx
682:	

scanFormat$194:	; if star != 0 goto 222
683:		cmp word [bp + 21], 0
684:		jne scanFormat$222
686:	

scanFormat$195:	; if shortInt == 0 goto 205
687:		cmp word [bp + 15], 0
688:		je scanFormat$205
690:	

scanFormat$196:	; arg_list = arg_list + 2
691:		add word [bp + 8], 2
693:	

scanFormat$197:	; £temporary1706 = arg_list - 2
694:		mov si, [bp + 8]
695:		sub si, 2
697:	

scanFormat$198:	; £temporary1707 = int_to_int £temporary1706 (Signed_Int -> Pointer)
700:	

scanFormat$199:	; £temporary1708 -> £temporary1707 = *£temporary1707
702:	

scanFormat$200:	; unsignedShortPtr = £temporary1708 -> £temporary1707
703:		mov ax, [si]
704:		mov [bp + 43], ax
706:	

scanFormat$201:	; £temporary1709 -> unsignedShortPtr = *unsignedShortPtr
707:		mov si, [bp + 43]
709:	

scanFormat$202:	; £temporary1710 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
710:		mov eax, [bp + 37]
713:	

scanFormat$203:	; £temporary1709 -> unsignedShortPtr = £temporary1710
714:		mov [si], al
716:	

scanFormat$204:	; goto 222
717:		jmp scanFormat$222
719:	

scanFormat$205:	; if longIntOrDouble != 0 goto 215
720:		cmp word [bp + 17], 0
721:		jne scanFormat$215
723:	

scanFormat$206:	; arg_list = arg_list + 2
724:		add word [bp + 8], 2
726:	

scanFormat$207:	; £temporary1714 = arg_list - 2
727:		mov si, [bp + 8]
728:		sub si, 2
730:	

scanFormat$208:	; £temporary1715 = int_to_int £temporary1714 (Signed_Int -> Pointer)
733:	

scanFormat$209:	; £temporary1716 -> £temporary1715 = *£temporary1715
735:	

scanFormat$210:	; unsignedIntPtr = £temporary1716 -> £temporary1715
736:		mov ax, [si]
737:		mov [bp + 45], ax
739:	

scanFormat$211:	; £temporary1717 -> unsignedIntPtr = *unsignedIntPtr
740:		mov si, [bp + 45]
742:	

scanFormat$212:	; £temporary1718 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
743:		mov eax, [bp + 37]
746:	

scanFormat$213:	; £temporary1717 -> unsignedIntPtr = £temporary1718
747:		mov [si], ax
749:	

scanFormat$214:	; goto 222
750:		jmp scanFormat$222
752:	

scanFormat$215:	; arg_list = arg_list + 2
753:		add word [bp + 8], 2
755:	

scanFormat$216:	; £temporary1720 = arg_list - 2
756:		mov si, [bp + 8]
757:		sub si, 2
759:	

scanFormat$217:	; £temporary1721 = int_to_int £temporary1720 (Signed_Int -> Pointer)
762:	

scanFormat$218:	; £temporary1722 -> £temporary1721 = *£temporary1721
764:	

scanFormat$219:	; unsignedLongPtr = £temporary1722 -> £temporary1721
765:		mov ax, [si]
766:		mov [bp + 41], ax
768:	

scanFormat$220:	; £temporary1723 -> unsignedLongPtr = *unsignedLongPtr
769:		mov si, [bp + 41]
771:	

scanFormat$221:	; £temporary1723 -> unsignedLongPtr = unsignedLongValue
772:		mov eax, [bp + 37]
773:		mov [si], eax
775:	

scanFormat$222:	; percent = 0
776:		mov word [bp + 13], 0
778:	

scanFormat$223:	; goto 323
779:		jmp scanFormat$323
781:	

scanFormat$224:	; call header integral zero 0 stack zero 0
783:	

scanFormat$225:	; call function noellipse-noellipse scanLongDouble
784:		mov word [bp + 57], scanFormat$226
785:		mov [bp + 59], bp
786:		add bp, 57
787:		jmp scanLongDouble
789:	

scanFormat$226:	; post call
791:	

scanFormat$227:	; £temporary1725 = return_value
793:	

scanFormat$228:	; pop float longDoubleValue
794:		fstp qword [bp + 47]
796:	

scanFormat$229:	; if star != 0 goto 258
797:		cmp word [bp + 21], 0
798:		jne scanFormat$258
800:	

scanFormat$230:	; if longIntOrDouble == 0 goto 240
801:		cmp word [bp + 17], 0
802:		je scanFormat$240
804:	

scanFormat$231:	; arg_list = arg_list + 2
805:		add word [bp + 8], 2
807:	

scanFormat$232:	; £temporary1729 = arg_list - 2
808:		mov si, [bp + 8]
809:		sub si, 2
811:	

scanFormat$233:	; £temporary1730 = int_to_int £temporary1729 (Signed_Int -> Pointer)
814:	

scanFormat$234:	; £temporary1731 -> £temporary1730 = *£temporary1730
816:	

scanFormat$235:	; doublePtr = £temporary1731 -> £temporary1730
817:		mov ax, [si]
818:		mov [bp + 57], ax
820:	

scanFormat$236:	; £temporary1732 -> doublePtr = *doublePtr
821:		mov si, [bp + 57]
823:	

scanFormat$237:	; push float longDoubleValue
824:		fld qword [bp + 47]
826:	

scanFormat$238:	; pop float £temporary1732 -> doublePtr
827:		fstp qword [si]
829:	

scanFormat$239:	; goto 258
830:		jmp scanFormat$258
832:	

scanFormat$240:	; if longDouble == 0 goto 250
833:		cmp word [bp + 19], 0
834:		je scanFormat$250
836:	

scanFormat$241:	; arg_list = arg_list + 2
837:		add word [bp + 8], 2
839:	

scanFormat$242:	; £temporary1735 = arg_list - 2
840:		mov si, [bp + 8]
841:		sub si, 2
843:	

scanFormat$243:	; £temporary1736 = int_to_int £temporary1735 (Signed_Int -> Pointer)
846:	

scanFormat$244:	; £temporary1737 -> £temporary1736 = *£temporary1736
848:	

scanFormat$245:	; longDoublePtr = £temporary1737 -> £temporary1736
849:		mov ax, [si]
850:		mov [bp + 57], ax
852:	

scanFormat$246:	; £temporary1738 -> longDoublePtr = *longDoublePtr
853:		mov si, [bp + 57]
855:	

scanFormat$247:	; push float longDoubleValue
856:		fld qword [bp + 47]
858:	

scanFormat$248:	; pop float £temporary1738 -> longDoublePtr
859:		fstp qword [si]
861:	

scanFormat$249:	; goto 258
862:		jmp scanFormat$258
864:	

scanFormat$250:	; arg_list = arg_list + 2
865:		add word [bp + 8], 2
867:	

scanFormat$251:	; £temporary1740 = arg_list - 2
868:		mov si, [bp + 8]
869:		sub si, 2
871:	

scanFormat$252:	; £temporary1741 = int_to_int £temporary1740 (Signed_Int -> Pointer)
874:	

scanFormat$253:	; £temporary1742 -> £temporary1741 = *£temporary1741
876:	

scanFormat$254:	; floatPtr = £temporary1742 -> £temporary1741
877:		mov ax, [si]
878:		mov [bp + 57], ax
880:	

scanFormat$255:	; £temporary1743 -> floatPtr = *floatPtr
881:		mov si, [bp + 57]
883:	

scanFormat$256:	; push float longDoubleValue
884:		fld qword [bp + 47]
886:	

scanFormat$257:	; pop float £temporary1743 -> floatPtr
887:		fstp dword [si]
889:	

scanFormat$258:	; percent = 0
890:		mov word [bp + 13], 0
892:	

scanFormat$259:	; goto 323
893:		jmp scanFormat$323
895:	

scanFormat$260:	; not = 0
896:		mov word [bp + 57], 0
898:	

scanFormat$261:	; ++index
899:		inc word [bp + 31]
901:	

scanFormat$262:	; £temporary1749 = format + index
902:		mov si, [bp + 6]
903:		add si, [bp + 31]
905:	

scanFormat$263:	; £temporary1748 -> £temporary1749 = *£temporary1749
907:	

scanFormat$264:	; if £temporary1748 -> £temporary1749 != 94 goto 267
908:		cmp byte [si], 94
909:		jne scanFormat$267
911:	

scanFormat$265:	; not = 1
912:		mov word [bp + 57], 1
914:	

scanFormat$266:	; startIndex = index + 1
915:		mov ax, [bp + 31]
916:		add ax, 1
917:		mov [bp + 59], ax
919:	

scanFormat$267:	; £temporary1753 = format + index
920:		mov si, [bp + 6]
921:		add si, [bp + 31]
923:	

scanFormat$268:	; £temporary1752 -> £temporary1753 = *£temporary1753
925:	

scanFormat$269:	; if £temporary1752 -> £temporary1753 == 93 goto 272
926:		cmp byte [si], 93
927:		je scanFormat$272
929:	

scanFormat$270:	; ++index
930:		inc word [bp + 31]
932:	

scanFormat$271:	; goto 267
933:		jmp scanFormat$267
935:	

scanFormat$272:	; £temporary1757 = format + index
936:		mov si, [bp + 6]
937:		add si, [bp + 31]
939:	

scanFormat$273:	; £temporary1756 -> £temporary1757 = *£temporary1757
941:	

scanFormat$274:	; £temporary1756 -> £temporary1757 = 0
942:		mov byte [si], 0
944:	

scanFormat$275:	; if star != 0 goto 291
945:		cmp word [bp + 21], 0
946:		jne scanFormat$291
948:	

scanFormat$276:	; arg_list = arg_list + 2
949:		add word [bp + 8], 2
951:	

scanFormat$277:	; £temporary1761 = arg_list - 2
952:		mov si, [bp + 8]
953:		sub si, 2
955:	

scanFormat$278:	; £temporary1762 = int_to_int £temporary1761 (Signed_Int -> Pointer)
958:	

scanFormat$279:	; £temporary1763 -> £temporary1762 = *£temporary1762
960:	

scanFormat$280:	; string = £temporary1763 -> £temporary1762
961:		mov ax, [si]
962:		mov [bp + 61], ax
964:	

scanFormat$281:	; call header integral zero 0 stack zero 0
966:	

scanFormat$282:	; parameter string, offset 6
967:		mov ax, [bp + 61]
968:		mov [bp + 69], ax
970:	

scanFormat$283:	; £temporary1765 = format + startIndex
971:		mov si, [bp + 6]
972:		add si, [bp + 59]
974:	

scanFormat$284:	; £temporary1764 -> £temporary1765 = *£temporary1765
976:	

scanFormat$285:	; £temporary1766 = &£temporary1764 -> £temporary1765
978:	

scanFormat$286:	; parameter £temporary1766, offset 8
979:		mov [bp + 71], si
981:	

scanFormat$287:	; parameter not, offset 10
982:		mov ax, [bp + 57]
983:		mov [bp + 73], ax
985:	

scanFormat$288:	; call function noellipse-noellipse scanPattern
986:		mov word [bp + 63], scanFormat$289
987:		mov [bp + 65], bp
988:		add bp, 63
989:		jmp scanPattern
991:	

scanFormat$289:	; post call
993:	

scanFormat$290:	; goto 323
994:		jmp scanFormat$323
996:	

scanFormat$291:	; call header integral zero 0 stack zero 0
998:	

scanFormat$292:	; parameter 0, offset 6
999:		mov word [bp + 67], 0
1001:	

scanFormat$293:	; £temporary1769 = format + startIndex
1002:		mov si, [bp + 6]
1003:		add si, [bp + 59]
1005:	

scanFormat$294:	; £temporary1768 -> £temporary1769 = *£temporary1769
1007:	

scanFormat$295:	; £temporary1770 = &£temporary1768 -> £temporary1769
1009:	

scanFormat$296:	; parameter £temporary1770, offset 8
1010:		mov [bp + 69], si
1012:	

scanFormat$297:	; parameter not, offset 10
1013:		mov ax, [bp + 57]
1014:		mov [bp + 71], ax
1016:	

scanFormat$298:	; call function noellipse-noellipse scanPattern
1017:		mov word [bp + 61], scanFormat$299
1018:		mov [bp + 63], bp
1019:		add bp, 61
1020:		jmp scanPattern
1022:	

scanFormat$299:	; post call
1024:	

scanFormat$300:	; goto 323
1025:		jmp scanFormat$323
1027:	

scanFormat$301:	; arg_list = arg_list + 2
1028:		add word [bp + 8], 2
1030:	

scanFormat$302:	; £temporary1773 = arg_list - 2
1031:		mov si, [bp + 8]
1032:		sub si, 2
1034:	

scanFormat$303:	; £temporary1774 = int_to_int £temporary1773 (Signed_Int -> Pointer)
1037:	

scanFormat$304:	; £temporary1775 -> £temporary1774 = *£temporary1774
1039:	

scanFormat$305:	; charsPtr = £temporary1775 -> £temporary1774
1040:		mov ax, [si]
1041:		mov [bp + 35], ax
1043:	

scanFormat$306:	; £temporary1776 -> charsPtr = *charsPtr
1044:		mov si, [bp + 35]
1046:	

scanFormat$307:	; £temporary1776 -> charsPtr = g_inChars
1047:		mov ax, [g_inChars]
1048:		mov [si], ax
1050:	

scanFormat$308:	; percent = 0
1051:		mov word [bp + 13], 0
1053:	

scanFormat$309:	; goto 323
1054:		jmp scanFormat$323
1056:	

scanFormat$310:	; call header integral zero 0 stack zero 0
1058:	

scanFormat$311:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1059:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1061:	

scanFormat$312:	; £temporary1777 = int_to_int c (Signed_Char -> Signed_Int)
1062:		mov al, [bp + 10]
1064:		and ax, 255
1066:		cmp al, 0
1067:		jge scanFormat$313
1068:		neg al
1070:		neg ax
1072:	

scanFormat$313:	; parameter £temporary1777, offset 8
1073:		mov [bp + 65], ax
1075:	

scanFormat$314:	; call function noellipse-ellipse printf, extra 0
1076:		mov word [bp + 57], scanFormat$315
1077:		mov [bp + 59], bp
1078:		add bp, 57
1079:		mov di, bp
1080:		add di, 2
1081:		jmp printf
1083:	

scanFormat$315:	; post call
1085:	

scanFormat$316:	; goto 323
1086:		jmp scanFormat$323
1088:	

scanFormat$317:	; if c != 37 goto 323
1089:		cmp byte [bp + 10], 37
1090:		jne scanFormat$323
1092:	

scanFormat$318:	; percent = 1
1093:		mov word [bp + 13], 1
1095:	

scanFormat$319:	; shortInt = 0
1096:		mov word [bp + 15], 0
1098:	

scanFormat$320:	; longIntOrDouble = 0
1099:		mov word [bp + 17], 0
1101:	

scanFormat$321:	; longDouble = 0
1102:		mov word [bp + 19], 0
1104:	

scanFormat$322:	; star = 0
1105:		mov word [bp + 21], 0
1107:	

scanFormat$323:	; ++index
1108:		inc word [bp + 31]
1110:	

scanFormat$324:	; goto 8
1111:		jmp scanFormat$8
1113:	

scanFormat$325:	; return_value = g_inCount
1114:		mov bx, [g_inCount]
1116:	

scanFormat$326:	; return
1117:		mov ax, [bp]
1118:		mov di, [bp + 4]
1119:		mov bp, [bp + 2]
1120:		jmp ax
1122:	

scanFormat$327:	; function end scanFormat
1:	

scanf:	; £temporary1796 = &format
2:		mov si, bp
3:		add si, 6
5:	

scanf$1:	; £temporary1797 = int_to_int £temporary1796 (Pointer -> Pointer)
8:	

scanf$2:	; arg_list = £temporary1797 + 2
9:		add si, 2
10:		mov [di + 8], si
12:	

scanf$3:	; call header integral zero 0 stack zero 0
14:	

scanf$4:	; parameter format, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 16], ax
18:	

scanf$5:	; parameter arg_list, offset 8
19:		mov ax, [di + 8]
20:		mov [di + 18], ax
22:	

scanf$6:	; call function ellipse-noellipse vscanf
23:		mov word [di + 10], scanf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vscanf
30:	

scanf$7:	; post call
32:	

scanf$8:	; £temporary1799 = return_value
37:	

scanf$9:	; return_value = £temporary1799
39:	

scanf$10:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

scanf$11:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov ax, [stdin]
5:		mov [bp + 16], ax
7:	

vscanf$2:	; parameter format, offset 8
8:		mov ax, [bp + 6]
9:		mov [bp + 18], ax
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov ax, [bp + 8]
13:		mov [bp + 20], ax
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1803 = return_value
28:	

vscanf$7:	; return_value = £temporary1803
30:	

vscanf$8:	; return
31:		mov ax, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp ax
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1807 = &format
2:		mov si, bp
3:		add si, 8
5:	

fscanf$1:	; £temporary1808 = int_to_int £temporary1807 (Pointer -> Pointer)
8:	

fscanf$2:	; arg_list = £temporary1808 + 2
9:		add si, 2
10:		mov [di + 10], si
12:	

fscanf$3:	; call header integral zero 0 stack zero 0
14:	

fscanf$4:	; parameter inStream, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 18], ax
18:	

fscanf$5:	; parameter format, offset 8
19:		mov ax, [bp + 8]
20:		mov [di + 20], ax
22:	

fscanf$6:	; parameter arg_list, offset 10
23:		mov ax, [di + 10]
24:		mov [di + 22], ax
26:	

fscanf$7:	; call function ellipse-noellipse vfscanf
27:		mov word [di + 12], fscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfscanf
34:	

fscanf$8:	; post call
36:	

fscanf$9:	; £temporary1810 = return_value
41:	

fscanf$10:	; return_value = £temporary1810
43:	

fscanf$11:	; return
44:		mov ax, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp ax
49:	

fscanf$12:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1815 = int_to_int inStream (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1815
9:		mov [g_inDevice], ax
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1816 = return_value
34:	

vfscanf$9:	; return_value = £temporary1816
36:	

vfscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1819 = &format
2:		mov si, bp
3:		add si, 8
5:	

sscanf$1:	; £temporary1820 = int_to_int £temporary1819 (Pointer -> Pointer)
8:	

sscanf$2:	; arg_list = £temporary1820 + 2
9:		add si, 2
10:		mov [di + 10], si
12:	

sscanf$3:	; call header integral zero 0 stack zero 0
14:	

sscanf$4:	; parameter inString, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 18], ax
18:	

sscanf$5:	; parameter format, offset 8
19:		mov ax, [bp + 8]
20:		mov [di + 20], ax
22:	

sscanf$6:	; parameter arg_list, offset 10
23:		mov ax, [di + 10]
24:		mov [di + 22], ax
26:	

sscanf$7:	; call function ellipse-noellipse vsscanf
27:		mov word [di + 12], sscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsscanf
34:	

sscanf$8:	; post call
36:	

sscanf$9:	; £temporary1822 = return_value
41:	

sscanf$10:	; return_value = £temporary1822
43:	

sscanf$11:	; return
44:		mov ax, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp ax
49:	

sscanf$12:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1827 = int_to_int inString (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1827
9:		mov [g_inDevice], ax
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1828 = return_value
34:	

vsscanf$9:	; return_value = £temporary1828
36:	

vsscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vsscanf$11:	; function end vsscanf
