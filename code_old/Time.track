1:	

clock:	; return_value = -1
2:		mov a1758, -1
4:	

clock$1:	; return
5:		mov t1759, [bp]
6:		mov di, [bp + 4]
7:		mov bp, [bp + 2]
8:		jmp t1759
10:	

clock$2:	; function end clock
1:	

time:	; ah = 42
2:		mov a1760, 42
4:	

time$1:	; interrupt 33
5:		int 33
7:	

time$2:	; £temporary2687 = cx
9:	

time$3:	; year = £temporary2687 - 1900
10:		sub t1761, 1900
11:		mov [bp + 12], t1761
13:	

time$4:	; £temporary2689 = dh
15:	

time$5:	; month = £temporary2689 - 1
16:		sub t1762, 1
17:		mov [bp + 14], t1762
19:	

time$6:	; £temporary2691 = dl
21:	

time$7:	; monthDay = £temporary2691
22:		mov [bp + 15], t1763
24:	

time$8:	; call header integral zero 0 stack zero 0
26:	

time$9:	; parameter string_25i2D25i2D25i0A#, offset 6
27:		mov word [bp + 22], string_25i2D25i2D25i0A#
29:	

time$10:	; parameter year, offset 8
30:		mov a1764, [bp + 12]
31:		mov [bp + 24], a1764
33:	

time$11:	; £temporary2692 = int_to_int month (Signed_Short_Int -> Signed_Int)
34:		mov a1765, [bp + 14]
36:		and a1765, 255
38:		cmp a1765, 0
39:		jge time$12
40:		neg a1765
42:		neg a1765
44:	

time$12:	; parameter £temporary2692, offset 10
45:		mov [bp + 26], a1765
47:	

time$13:	; £temporary2693 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
48:		mov a1766, [bp + 15]
50:		and a1766, 255
52:		cmp a1766, 0
53:		jge time$14
54:		neg a1766
56:		neg a1766
58:	

time$14:	; parameter £temporary2693, offset 12
59:		mov [bp + 28], a1766
61:	

time$15:	; call function noellipse-ellipse printf, extra 0
62:		mov word [bp + 16], time$16
63:		mov [bp + 18], bp
64:		add bp, 16
65:		mov di, bp
66:		add di, 6
67:		jmp printf
69:	

time$16:	; post call
71:	

time$17:	; ah = 44
72:		mov a1767, 44
74:	

time$18:	; interrupt 33
75:		int 33
77:	

time$19:	; £temporary2696 = ch
79:	

time$20:	; hour = £temporary2696
80:		mov [bp + 16], t1768
82:	

time$21:	; £temporary2697 = cl
84:	

time$22:	; min = £temporary2697
85:		mov [bp + 17], t1769
87:	

time$23:	; £temporary2698 = dh
89:	

time$24:	; sec = £temporary2698
90:		mov [bp + 18], t1770
92:	

time$25:	; £temporary2699 = year % 4
93:		mov a1771, [bp + 12]
95:		xor dx, dx
96:		idiv word [int2$4#]
102:	

time$26:	; if £temporary2699 != 0 goto 29
103:		cmp t1773, 0
104:		jne time$29
106:	

time$27:	; £temporary2701 = 1
107:		mov t1774, 1
109:	

time$28:	; goto 30
110:		jmp time$30
112:	

time$29:	; £temporary2701 = 0
113:		mov t1775, 0
115:	

time$30:	; leapYear = £temporary2701
116:		mov [bp + 19], t1775
118:	

time$31:	; daysOfMonths[0] = 31
119:		mov word [bp + 21], 31
121:	

time$32:	; if leapYear == 0 goto 35
122:		cmp word [bp + 19], 0
123:		je time$35
125:	

time$33:	; £temporary2706 = 29
126:		mov t1776, 29
128:	

time$34:	; goto 36
129:		jmp time$36
131:	

time$35:	; £temporary2706 = 28
132:		mov t1777, 28
134:	

time$36:	; daysOfMonths[1] = £temporary2706
135:		mov [bp + 23], t1777
137:	

time$37:	; daysOfMonths[2] = 31
138:		mov word [bp + 25], 31
140:	

time$38:	; daysOfMonths[3] = 30
141:		mov word [bp + 27], 30
143:	

time$39:	; daysOfMonths[4] = 31
144:		mov word [bp + 29], 31
146:	

time$40:	; daysOfMonths[5] = 30
147:		mov word [bp + 31], 30
149:	

time$41:	; daysOfMonths[6] = 30
150:		mov word [bp + 33], 30
152:	

time$42:	; daysOfMonths[7] = 31
153:		mov word [bp + 35], 31
155:	

time$43:	; daysOfMonths[8] = 30
156:		mov word [bp + 37], 30
158:	

time$44:	; daysOfMonths[9] = 31
159:		mov word [bp + 39], 31
161:	

time$45:	; daysOfMonths[10] = 30
162:		mov word [bp + 41], 30
164:	

time$46:	; daysOfMonths[11] = 31
165:		mov word [bp + 43], 31
167:	

time$47:	; £temporary2719 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
168:		mov a1778, [bp + 15]
170:		and a1778, 255
172:		cmp a1778, 0
173:		jge time$48
174:		neg a1778
176:		neg a1778
178:	

time$48:	; yearDay = £temporary2719 - 1
179:		sub a1778, 1
180:		mov [bp + 45], a1778
182:	

time$49:	; mon = 0
183:		mov word [bp + 47], 0
185:	

time$50:	; £temporary2721 = int_to_int month (Signed_Short_Int -> Signed_Int)
186:		mov a1779, [bp + 14]
188:		and a1779, 255
190:		cmp a1779, 0
191:		jge time$51
192:		neg a1779
194:		neg a1779
196:	

time$51:	; if mon >= £temporary2721 goto 58
197:		cmp [bp + 47], a1779
198:		jge time$58
200:	

time$52:	; £temporary2725 = mon * 2
201:		mov a1780, [bp + 47]
203:		xor dx, dx
204:		mul word [int2$2#]
210:	

time$53:	; £temporary2726 = daysOfMonths + £temporary2725
211:		mov a1784, bp
212:		add a1784, 21
213:		add a1784, t1783
215:	

time$54:	; £temporary2724 -> £temporary2726 = *£temporary2726
217:	

time$55:	; yearDay = yearDay + £temporary2724 -> £temporary2726
218:		mov t1785, [a1784]
219:		add [bp + 45], t1785
221:	

time$56:	; ++mon
222:		inc word [bp + 47]
224:	

time$57:	; goto 50
225:		jmp time$50
227:	

time$58:	; call header integral zero 0 stack zero 0
229:	

time$59:	; parameter string_25i2025i0A#, offset 6
230:		mov word [bp + 55], string_25i2025i0A#
232:	

time$60:	; parameter yearDay, offset 8
233:		mov a1786, [bp + 45]
234:		mov [bp + 57], a1786
236:	

time$61:	; £temporary2728 = int_to_int month (Signed_Short_Int -> Signed_Int)
237:		mov a1787, [bp + 14]
239:		and a1787, 255
241:		cmp a1787, 0
242:		jge time$62
243:		neg a1787
245:		neg a1787
247:	

time$62:	; parameter £temporary2728, offset 10
248:		mov [bp + 59], a1787
250:	

time$63:	; call function noellipse-ellipse printf, extra 0
251:		mov word [bp + 49], time$64
252:		mov [bp + 51], bp
253:		add bp, 49
254:		mov di, bp
255:		add di, 4
256:		jmp printf
258:	

time$64:	; post call
260:	

time$65:	; £temporary2731 = int_to_int sec (Signed_Short_Int -> Signed_Int)
261:		mov a1788, [bp + 18]
263:		and a1788, 255
265:		cmp a1788, 0
266:		jge time$66
267:		neg a1788
269:		neg a1788
271:	

time$66:	; s$tm_sec = £temporary2731
272:		mov [bp + 49], a1788
274:	

time$67:	; £temporary2733 = int_to_int min (Signed_Short_Int -> Signed_Int)
275:		mov a1789, [bp + 17]
277:		and a1789, 255
279:		cmp a1789, 0
280:		jge time$68
281:		neg a1789
283:		neg a1789
285:	

time$68:	; s$tm_min = £temporary2733
286:		mov [bp + 51], a1789
288:	

time$69:	; £temporary2735 = int_to_int hour (Signed_Short_Int -> Signed_Int)
289:		mov a1790, [bp + 16]
291:		and a1790, 255
293:		cmp a1790, 0
294:		jge time$70
295:		neg a1790
297:		neg a1790
299:	

time$70:	; s$tm_hour = £temporary2735
300:		mov [bp + 53], a1790
302:	

time$71:	; £temporary2737 = int_to_int monthDay (Signed_Short_Int -> Signed_Int)
303:		mov a1791, [bp + 15]
305:		and a1791, 255
307:		cmp a1791, 0
308:		jge time$72
309:		neg a1791
311:		neg a1791
313:	

time$72:	; s$tm_mday = £temporary2737
314:		mov [bp + 55], a1791
316:	

time$73:	; £temporary2739 = int_to_int month (Signed_Short_Int -> Signed_Int)
317:		mov a1792, [bp + 14]
319:		and a1792, 255
321:		cmp a1792, 0
322:		jge time$74
323:		neg a1792
325:		neg a1792
327:	

time$74:	; s$tm_mon = £temporary2739
328:		mov [bp + 57], a1792
330:	

time$75:	; s$tm_year = year
331:		mov a1793, [bp + 12]
332:		mov [bp + 59], a1793
334:	

time$76:	; s$tm_wday = 0
335:		mov word [bp + 61], 0
337:	

time$77:	; s$tm_yday = yearDay
338:		mov a1794, [bp + 45]
339:		mov [bp + 63], a1794
341:	

time$78:	; s$tm_isdst = 0
342:		mov word [bp + 65], 0
344:	

time$79:	; call header integral zero 0 stack zero 0
346:	

time$80:	; £temporary2744 = &s
347:		mov t1795, bp
348:		add t1795, 49
350:	

time$81:	; parameter £temporary2744, offset 6
351:		mov [bp + 73], t1795
353:	

time$82:	; call function noellipse-noellipse mktime
354:		mov word [bp + 67], time$83
355:		mov [bp + 69], bp
356:		add bp, 67
357:		jmp mktime
359:	

time$83:	; post call
361:	

time$84:	; £temporary2745 = return_value
366:	

time$85:	; time = £temporary2745
367:		mov [bp + 8], t1797
369:	

time$86:	; if timePtr == 0 goto 89
370:		cmp word [bp + 6], 0
371:		je time$89
373:	

time$87:	; £temporary2747 -> timePtr = *timePtr
374:		mov a1798, [bp + 6]
376:	

time$88:	; £temporary2747 -> timePtr = time
377:		mov a1799, [bp + 8]
378:		mov [a1798], a1799
380:	

time$89:	; return_value = time
381:		mov a1800, [bp + 8]
383:	

time$90:	; return
384:		mov t1801, [bp]
385:		mov di, [bp + 4]
386:		mov bp, [bp + 2]
387:		jmp t1801
389:	

time$91:	; function end time
1:	

mktime:	; if tp == 0 goto 28
2:		cmp word [bp + 6], 0
3:		je mktime$28
5:	

mktime$1:	; £temporary2758 -> tp = *tp, offset 10
6:		mov a1802, [bp + 6]
8:	

mktime$2:	; £temporary2759 = £temporary2758 -> tp - 69
9:		mov t1803, [a1802 + 10]
10:		sub t1803, 69
12:	

mktime$3:	; £temporary2760 = £temporary2759 / 4
14:		xor dx, dx
15:		idiv word [int2$4#]
21:	

mktime$4:	; £temporary2761 = int_to_int £temporary2760 (Signed_Int -> Signed_Long_Int)
23:		and t1806, 65535
25:		cmp t1806, 0
26:		jge mktime$5
27:		neg t1806
29:		neg t1806
31:	

mktime$5:	; leapDays = £temporary2761
32:		mov [bp + 8], t1806
34:	

mktime$6:	; £temporary2762 -> tp = *tp, offset 10
35:		mov a1807, [bp + 6]
37:	

mktime$7:	; £temporary2763 = £temporary2762 -> tp - 70
38:		mov t1808, [a1807 + 10]
39:		sub t1808, 70
41:	

mktime$8:	; £temporary2764 = £temporary2763 * 365
43:		xor dx, dx
44:		imul word [int2$365#]
50:	

mktime$9:	; £temporary2765 = int_to_int £temporary2764 (Signed_Int -> Signed_Long_Int)
52:		and t1811, 65535
54:		cmp t1811, 0
55:		jge mktime$10
56:		neg t1811
58:		neg t1811
60:	

mktime$10:	; £temporary2766 = £temporary2765 + leapDays
61:		add t1811, [bp + 8]
63:	

mktime$11:	; £temporary2767 -> tp = *tp, offset 14
64:		mov a1812, [bp + 6]
66:	

mktime$12:	; £temporary2768 = int_to_int £temporary2767 -> tp (Signed_Int -> Signed_Long_Int)
67:		mov t1813, [a1812 + 14]
69:		and t1813, 65535
71:		cmp t1813, 0
72:		jge mktime$13
73:		neg t1813
75:		neg t1813
77:	

mktime$13:	; totalDays = £temporary2766 + £temporary2768
78:		add t1811, t1813
79:		mov [bp + 12], t1811
81:	

mktime$14:	; £temporary2770 = totalDays * 86400
82:		mov a1814, [bp + 12]
84:		xor edx, edx
85:		imul dword [int4$86400#]
91:		mov t1820, t1817
93:	

mktime$15:	; £temporary2771 -> tp = *tp, offset 4
94:		mov a1818, [bp + 6]
96:	

mktime$16:	; £temporary2772 = int_to_int £temporary2771 -> tp (Signed_Int -> Signed_Long_Int)
97:		mov t1819, [a1818 + 4]
99:		and t1819, 65535
101:		cmp t1819, 0
102:		jge mktime$17
103:		neg t1819
105:		neg t1819
107:	

mktime$17:	; £temporary2773 = £temporary2772 * 3600
109:		xor edx, edx
110:		imul dword [int4$3600#]
116:	

mktime$18:	; £temporary2774 = £temporary2770 + £temporary2773
117:		add t1820, t1823
119:	

mktime$19:	; £temporary2775 -> tp = *tp, offset 2
120:		mov a1824, [bp + 6]
122:	

mktime$20:	; £temporary2776 = int_to_int £temporary2775 -> tp (Signed_Int -> Signed_Long_Int)
123:		mov t1825, [a1824 + 2]
125:		and t1825, 65535
127:		cmp t1825, 0
128:		jge mktime$21
129:		neg t1825
131:		neg t1825
133:	

mktime$21:	; £temporary2777 = £temporary2776 * 60
135:		xor edx, edx
136:		imul dword [int4$60#]
142:	

mktime$22:	; £temporary2778 = £temporary2774 + £temporary2777
143:		add t1820, t1828
145:	

mktime$23:	; £temporary2779 -> tp = *tp
146:		mov a1829, [bp + 6]
148:	

mktime$24:	; £temporary2780 = int_to_int £temporary2779 -> tp (Signed_Int -> Signed_Long_Int)
149:		mov t1830, [a1829]
151:		and t1830, 65535
153:		cmp t1830, 0
154:		jge mktime$25
155:		neg t1830
157:		neg t1830
159:	

mktime$25:	; £temporary2781 = £temporary2778 + £temporary2780
160:		add t1820, t1830
162:	

mktime$26:	; return_value = £temporary2781
164:	

mktime$27:	; return
165:		mov t1831, [bp]
166:		mov di, [bp + 4]
167:		mov bp, [bp + 2]
168:		jmp t1831
170:	

mktime$28:	; return_value = 0
171:		mov a1832, 0
173:	

mktime$29:	; return
174:		mov t1833, [bp]
175:		mov di, [bp + 4]
176:		mov bp, [bp + 2]
177:		jmp t1833
179:	

mktime$30:	; function end mktime
1:	

gmtime:	; year = 1970
2:		mov word [bp + 8], 1970
4:	

gmtime$1:	; if timePtr == 0 goto 86
5:		cmp word [bp + 6], 0
6:		je gmtime$86
8:	

gmtime$2:	; £temporary2783 -> timePtr = *timePtr
9:		mov a1834, [bp + 6]
11:	

gmtime$3:	; time = £temporary2783 -> timePtr
12:		mov t1835, [a1834]
13:		mov [bp + 10], t1835
15:	

gmtime$4:	; secondsOfDay = time % 86400
16:		mov a1836, [bp + 10]
18:		xor edx, edx
19:		idiv dword [int4$86400#]
20:		mov [bp + 14], edx
22:	

gmtime$5:	; £temporary2786 = secondsOfDay / 3600
23:		mov a1838, [bp + 14]
25:		xor edx, edx
26:		idiv dword [int4$3600#]
32:	

gmtime$6:	; £temporary2787 = int_to_int £temporary2786 (Signed_Long_Int -> Signed_Int)
35:		cmp t1841, 0
36:		jge gmtime$7
37:		neg t1841
39:		neg t1841
41:	

gmtime$7:	; g_timeStruct$tm_hour = £temporary2787
42:		mov [@30$g_timeStruct + 4], t1841
44:	

gmtime$8:	; £temporary2789 = secondsOfDay % 3600
45:		mov a1842, [bp + 14]
47:		xor edx, edx
48:		idiv dword [int4$3600#]
54:	

gmtime$9:	; £temporary2790 = £temporary2789 / 60
55:		mov t1845, t1844
57:		xor edx, edx
58:		idiv dword [int4$60#]
64:	

gmtime$10:	; £temporary2791 = int_to_int £temporary2790 (Signed_Long_Int -> Signed_Int)
67:		cmp t1848, 0
68:		jge gmtime$11
69:		neg t1848
71:		neg t1848
73:	

gmtime$11:	; g_timeStruct$tm_min = £temporary2791
74:		mov [@30$g_timeStruct + 2], t1848
76:	

gmtime$12:	; £temporary2793 = secondsOfDay % 3600
77:		mov a1849, [bp + 14]
79:		xor edx, edx
80:		idiv dword [int4$3600#]
86:	

gmtime$13:	; £temporary2794 = £temporary2793 % 60
87:		mov t1852, t1851
89:		xor edx, edx
90:		idiv dword [int4$60#]
96:	

gmtime$14:	; £temporary2795 = int_to_int £temporary2794 (Signed_Long_Int -> Signed_Int)
99:		cmp t1854, 0
100:		jge gmtime$15
101:		neg t1854
103:		neg t1854
105:	

gmtime$15:	; g_timeStruct$tm_sec = £temporary2795
106:		mov [@30$g_timeStruct], t1854
108:	

gmtime$16:	; totalDays = time / 86400
109:		mov a1855, [bp + 10]
111:		xor edx, edx
112:		idiv dword [int4$86400#]
113:		mov [bp + 18], eax
115:	

gmtime$17:	; if totalDays >= 3 goto 22
116:		cmp dword [bp + 18], 3
117:		jge gmtime$22
119:	

gmtime$18:	; £temporary2799 = totalDays + 4
120:		mov a1858, [bp + 18]
121:		add a1858, 4
123:	

gmtime$19:	; £temporary2800 = int_to_int £temporary2799 (Signed_Long_Int -> Signed_Int)
126:		cmp a1858, 0
127:		jge gmtime$20
128:		neg a1858
130:		neg a1858
132:	

gmtime$20:	; g_timeStruct$tm_wday = £temporary2800
133:		mov [@30$g_timeStruct + 12], a1858
135:	

gmtime$21:	; goto 26
136:		jmp gmtime$26
138:	

gmtime$22:	; £temporary2802 = totalDays - 3
139:		mov a1859, [bp + 18]
140:		sub a1859, 3
142:	

gmtime$23:	; £temporary2803 = £temporary2802 % 7
144:		xor edx, edx
145:		idiv dword [int4$7#]
151:	

gmtime$24:	; £temporary2804 = int_to_int £temporary2803 (Signed_Long_Int -> Signed_Int)
154:		cmp t1861, 0
155:		jge gmtime$25
156:		neg t1861
158:		neg t1861
160:	

gmtime$25:	; g_timeStruct$tm_wday = £temporary2804
161:		mov [@30$g_timeStruct + 12], t1861
163:	

gmtime$26:	; £temporary2805 = year % 4
164:		mov a1862, [bp + 8]
166:		xor dx, dx
167:		idiv word [int2$4#]
173:	

gmtime$27:	; if £temporary2805 != 0 goto 30
174:		cmp t1864, 0
175:		jne gmtime$30
177:	

gmtime$28:	; £temporary2807 = year % 100
178:		mov a1865, [bp + 8]
180:		xor dx, dx
181:		idiv word [int2$100#]
187:	

gmtime$29:	; if £temporary2807 != 0 goto 32
188:		cmp t1867, 0
189:		jne gmtime$32
191:	

gmtime$30:	; £temporary2810 = year % 400
192:		mov a1868, [bp + 8]
194:		xor dx, dx
195:		idiv word [int2$400#]
201:	

gmtime$31:	; if £temporary2810 != 0 goto 34
202:		cmp t1870, 0
203:		jne gmtime$34
205:	

gmtime$32:	; £temporary2813 = 1
206:		mov t1871, 1
208:	

gmtime$33:	; goto 35
209:		jmp gmtime$35
211:	

gmtime$34:	; £temporary2813 = 0
212:		mov t1872, 0
214:	

gmtime$35:	; leapYear = £temporary2813
215:		mov [bp + 22], t1872
217:	

gmtime$36:	; if leapYear == 0 goto 39
218:		cmp word [bp + 22], 0
219:		je gmtime$39
221:	

gmtime$37:	; £temporary2818 = 366
222:		mov t1873, 366
224:	

gmtime$38:	; goto 40
225:		jmp gmtime$40
227:	

gmtime$39:	; £temporary2818 = 365
228:		mov t1874, 365
230:	

gmtime$40:	; daysOfYear = £temporary2818
231:		mov [bp + 24], t1874
233:	

gmtime$41:	; £temporary2819 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
234:		mov a1875, [bp + 24]
236:		and a1875, 65535
238:		cmp a1875, 0
239:		jge gmtime$42
240:		neg a1875
242:		neg a1875
244:	

gmtime$42:	; if totalDays >= £temporary2819 goto 82
245:		cmp [bp + 18], a1875
246:		jge gmtime$82
248:	

gmtime$43:	; g_timeStruct$tm_year = year - 1900
249:		mov a1876, [bp + 8]
250:		sub a1876, 1900
251:		mov [@30$g_timeStruct], a1876
253:	

gmtime$44:	; £temporary2824 = int_to_int totalDays (Signed_Long_Int -> Signed_Int)
254:		mov a1877, [bp + 18]
257:		cmp a1877, 0
258:		jge gmtime$45
259:		neg a1877
261:		neg a1877
263:	

gmtime$45:	; g_timeStruct$tm_yday = £temporary2824
264:		mov [@30$g_timeStruct + 14], a1877
266:	

gmtime$46:	; daysOfMonths[0] = 31
267:		mov word [bp + 26], 31
269:	

gmtime$47:	; if leapYear == 0 goto 50
270:		cmp word [bp + 22], 0
271:		je gmtime$50
273:	

gmtime$48:	; £temporary2829 = 29
274:		mov t1878, 29
276:	

gmtime$49:	; goto 51
277:		jmp gmtime$51
279:	

gmtime$50:	; £temporary2829 = 28
280:		mov t1879, 28
282:	

gmtime$51:	; daysOfMonths[1] = £temporary2829
283:		mov [bp + 28], t1879
285:	

gmtime$52:	; daysOfMonths[2] = 31
286:		mov word [bp + 30], 31
288:	

gmtime$53:	; daysOfMonths[3] = 30
289:		mov word [bp + 32], 30
291:	

gmtime$54:	; daysOfMonths[4] = 31
292:		mov word [bp + 34], 31
294:	

gmtime$55:	; daysOfMonths[5] = 30
295:		mov word [bp + 36], 30
297:	

gmtime$56:	; daysOfMonths[6] = 30
298:		mov word [bp + 38], 30
300:	

gmtime$57:	; daysOfMonths[7] = 31
301:		mov word [bp + 40], 31
303:	

gmtime$58:	; daysOfMonths[8] = 30
304:		mov word [bp + 42], 30
306:	

gmtime$59:	; daysOfMonths[9] = 31
307:		mov word [bp + 44], 31
309:	

gmtime$60:	; daysOfMonths[10] = 30
310:		mov word [bp + 46], 30
312:	

gmtime$61:	; daysOfMonths[11] = 31
313:		mov word [bp + 48], 31
315:	

gmtime$62:	; month = 0
316:		mov word [bp + 50], 0
318:	

gmtime$63:	; £temporary2843 = month * 2
319:		mov a1880, [bp + 50]
321:		xor dx, dx
322:		mul word [int2$2#]
328:	

gmtime$64:	; £temporary2844 = daysOfMonths + £temporary2843
329:		mov a1884, bp
330:		add a1884, 26
331:		add a1884, t1883
333:	

gmtime$65:	; £temporary2842 -> £temporary2844 = *£temporary2844
335:	

gmtime$66:	; £temporary2845 = int_to_int £temporary2842 -> £temporary2844 (Signed_Int -> Signed_Long_Int)
336:		mov t1885, [a1884]
338:		and t1885, 65535
340:		cmp t1885, 0
341:		jge gmtime$67
342:		neg t1885
344:		neg t1885
346:	

gmtime$67:	; if totalDays < £temporary2845 goto 75
347:		cmp [bp + 18], t1885
348:		jl gmtime$75
350:	

gmtime$68:	; £temporary2848 = month * 2
351:		mov a1886, [bp + 50]
353:		xor dx, dx
354:		mul word [int2$2#]
360:	

gmtime$69:	; £temporary2849 = daysOfMonths + £temporary2848
361:		mov a1890, bp
362:		add a1890, 26
363:		add a1890, t1889
365:	

gmtime$70:	; £temporary2847 -> £temporary2849 = *£temporary2849
367:	

gmtime$71:	; £temporary2850 = int_to_int £temporary2847 -> £temporary2849 (Signed_Int -> Signed_Long_Int)
368:		mov t1891, [a1890]
370:		and t1891, 65535
372:		cmp t1891, 0
373:		jge gmtime$72
374:		neg t1891
376:		neg t1891
378:	

gmtime$72:	; totalDays = totalDays - £temporary2850
379:		sub [bp + 18], t1891
381:	

gmtime$73:	; ++month
382:		inc word [bp + 50]
384:	

gmtime$74:	; goto 63
385:		jmp gmtime$63
387:	

gmtime$75:	; g_timeStruct$tm_mon = month
388:		mov a1892, [bp + 50]
389:		mov [@30$g_timeStruct + 8], a1892
391:	

gmtime$76:	; £temporary2855 = totalDays + 1
392:		mov a1893, [bp + 18]
393:		add a1893, 1
395:	

gmtime$77:	; £temporary2856 = int_to_int £temporary2855 (Signed_Long_Int -> Signed_Int)
398:		cmp a1893, 0
399:		jge gmtime$78
400:		neg a1893
402:		neg a1893
404:	

gmtime$78:	; g_timeStruct$tm_mday = £temporary2856
405:		mov [@30$g_timeStruct + 6], a1893
407:	

gmtime$79:	; g_timeStruct$tm_isdst = -1
408:		mov word [@30$g_timeStruct + 16], -1
410:	

gmtime$80:	; return_value = (@30$g_timeStruct,0)
411:		mov a1894, @30$g_timeStruct
413:	

gmtime$81:	; return
414:		mov t1895, [bp]
415:		mov di, [bp + 4]
416:		mov bp, [bp + 2]
417:		jmp t1895
419:	

gmtime$82:	; ++year
420:		inc word [bp + 8]
422:	

gmtime$83:	; £temporary2859 = int_to_int daysOfYear (Signed_Int -> Signed_Long_Int)
423:		mov a1896, [bp + 24]
425:		and a1896, 65535
427:		cmp a1896, 0
428:		jge gmtime$84
429:		neg a1896
431:		neg a1896
433:	

gmtime$84:	; totalDays = totalDays - £temporary2859
434:		sub [bp + 18], a1896
436:	

gmtime$85:	; goto 26
437:		jmp gmtime$26
439:	

gmtime$86:	; return_value = 0
440:		mov a1897, 0
442:	

gmtime$87:	; return
443:		mov t1898, [bp]
444:		mov di, [bp + 4]
445:		mov bp, [bp + 2]
446:		jmp t1898
448:	

gmtime$88:	; function end gmtime
1:	

difftime:	; £temporary2862 = time2 - time1
2:		mov a1899, [bp + 10]
3:		sub a1899, [bp + 6]
5:	

difftime$1:	; £temporary2863 = int_to_float £temporary2862 (Unsigned_Long_Int -> Double)
6:		mov [container4bytes#], a1899
7:		fild dword [container4bytes#]
9:	

difftime$2:	; return_value = £temporary2863
11:	

difftime$3:	; return
12:		mov t1900, [bp]
13:		mov di, [bp + 4]
14:		mov bp, [bp + 2]
15:		jmp t1900
17:	

difftime$4:	; function end difftime
1:	

default_test:	; empty
3:	

default_test$1:	; return
4:		mov t1901, [bp]
5:		mov di, [bp + 4]
6:		mov bp, [bp + 2]
7:		jmp t1901
9:	

default_test$2:	; function end default_test
1:	

asctime:	; localeConvPtr = 0
2:		mov word [bp + 8], 0
4:	

asctime$1:	; if localeConvPtr == 0 goto 5
5:		cmp word [bp + 8], 0
6:		je asctime$5
8:	

asctime$2:	; £temporary2865 -> localeConvPtr = *localeConvPtr, offset 4
9:		mov a1902, [bp + 8]
11:	

asctime$3:	; £temporary2869 = £temporary2865 -> localeConvPtr
12:		mov t1903, [a1902 + 4]
14:	

asctime$4:	; goto 6
15:		jmp asctime$6
17:	

asctime$5:	; £temporary2869 = 0
18:		mov t1904, 0
20:	

asctime$6:	; shortDayList = £temporary2869
21:		mov [bp + 10], t1904
23:	

asctime$7:	; if localeConvPtr == 0 goto 11
24:		cmp word [bp + 8], 0
25:		je asctime$11
27:	

asctime$8:	; £temporary2871 -> localeConvPtr = *localeConvPtr, offset 8
28:		mov a1905, [bp + 8]
30:	

asctime$9:	; £temporary2875 = £temporary2871 -> localeConvPtr
31:		mov t1906, [a1905 + 8]
33:	

asctime$10:	; goto 12
34:		jmp asctime$12
36:	

asctime$11:	; £temporary2875 = 0
37:		mov t1907, 0
39:	

asctime$12:	; shortMonthList = £temporary2875
40:		mov [bp + 12], t1907
42:	

asctime$13:	; if shortDayList == 0 goto 16
43:		cmp word [bp + 10], 0
44:		je asctime$16
46:	

asctime$14:	; £temporary2880 = shortDayList
47:		mov t1908, [bp + 10]
49:	

asctime$15:	; goto 17
50:		jmp asctime$17
52:	

asctime$16:	; £temporary2880 = g_defaultShortDayList
53:		mov t1909, @32$g_defaultShortDayList
55:	

asctime$17:	; shortDayList = £temporary2880
56:		mov [bp + 10], t1909
58:	

asctime$18:	; if shortMonthList == 0 goto 21
59:		cmp word [bp + 12], 0
60:		je asctime$21
62:	

asctime$19:	; £temporary2885 = shortMonthList
63:		mov t1910, [bp + 12]
65:	

asctime$20:	; goto 22
66:		jmp asctime$22
68:	

asctime$21:	; £temporary2885 = g_defaultShortMonthList
69:		mov t1911, @34$g_defaultShortMonthList
71:	

asctime$22:	; shortMonthList = £temporary2885
72:		mov [bp + 12], t1911
74:	

asctime$23:	; call header integral zero 0 stack zero 0
76:	

asctime$24:	; parameter g_timeString, offset 6
77:		mov word [bp + 20], @31$g_timeString
79:	

asctime$25:	; parameter string_25s2025s20252i202502i3A2502i3A2502i202504i#, offset 8
80:		mov word [bp + 22], string_25s2025s20252i202502i3A2502i3A2502i202504i#
82:	

asctime$26:	; £temporary2886 -> tp = *tp, offset 12
83:		mov a1912, [bp + 6]
85:	

asctime$27:	; £temporary2888 = £temporary2886 -> tp * 2
86:		mov t1913, [a1912 + 12]
88:		xor dx, dx
89:		mul word [int2$2#]
95:	

asctime$28:	; £temporary2889 = shortDayList + £temporary2888
96:		mov a1917, [bp + 10]
97:		add a1917, t1916
99:	

asctime$29:	; £temporary2887 -> £temporary2889 = *£temporary2889
101:	

asctime$30:	; parameter £temporary2887 -> £temporary2889, offset 10
102:		mov t1918, [a1917]
103:		mov [bp + 24], t1918
105:	

asctime$31:	; £temporary2890 -> tp = *tp, offset 8
106:		mov a1919, [bp + 6]
108:	

asctime$32:	; £temporary2892 = £temporary2890 -> tp * 2
109:		mov t1920, [a1919 + 8]
111:		xor dx, dx
112:		mul word [int2$2#]
118:	

asctime$33:	; £temporary2893 = shortMonthList + £temporary2892
119:		mov a1924, [bp + 12]
120:		add a1924, t1923
122:	

asctime$34:	; £temporary2891 -> £temporary2893 = *£temporary2893
124:	

asctime$35:	; parameter £temporary2891 -> £temporary2893, offset 12
125:		mov t1925, [a1924]
126:		mov [bp + 26], t1925
128:	

asctime$36:	; £temporary2894 -> tp = *tp, offset 6
129:		mov a1926, [bp + 6]
131:	

asctime$37:	; parameter £temporary2894 -> tp, offset 14
132:		mov t1927, [a1926 + 6]
133:		mov [bp + 28], t1927
135:	

asctime$38:	; £temporary2895 -> tp = *tp, offset 4
136:		mov a1928, [bp + 6]
138:	

asctime$39:	; parameter £temporary2895 -> tp, offset 16
139:		mov t1929, [a1928 + 4]
140:		mov [bp + 30], t1929
142:	

asctime$40:	; £temporary2896 -> tp = *tp, offset 2
143:		mov a1930, [bp + 6]
145:	

asctime$41:	; parameter £temporary2896 -> tp, offset 18
146:		mov t1931, [a1930 + 2]
147:		mov [bp + 32], t1931
149:	

asctime$42:	; £temporary2897 -> tp = *tp
150:		mov a1932, [bp + 6]
152:	

asctime$43:	; parameter £temporary2897 -> tp, offset 20
153:		mov t1933, [a1932]
154:		mov [bp + 34], t1933
156:	

asctime$44:	; £temporary2898 -> tp = *tp, offset 10
157:		mov a1934, [bp + 6]
159:	

asctime$45:	; £temporary2899 = £temporary2898 -> tp + 1900
160:		mov t1935, [a1934 + 10]
161:		add t1935, 1900
163:	

asctime$46:	; parameter £temporary2899, offset 22
164:		mov [bp + 36], t1935
166:	

asctime$47:	; call function noellipse-ellipse sprintf, extra 0
167:		mov word [bp + 14], asctime$48
168:		mov [bp + 16], bp
169:		add bp, 14
170:		mov di, bp
171:		add di, 14
172:		jmp sprintf
174:	

asctime$48:	; post call
176:	

asctime$49:	; return_value = g_timeString
177:		mov a1936, @31$g_timeString
179:	

asctime$50:	; return
180:		mov t1937, [bp]
181:		mov di, [bp + 4]
182:		mov bp, [bp + 2]
183:		jmp t1937
185:	

asctime$51:	; function end asctime
1:	

ctime:	; call header integral zero 0 stack zero 0
3:	

ctime$1:	; call header integral zero 0 stack zero 0
5:	

ctime$2:	; parameter time, offset 6
6:		mov a1938, [bp + 6]
7:		mov [bp + 14], a1938
9:	

ctime$3:	; call function noellipse-noellipse localtime
10:		mov word [bp + 8], ctime$4
11:		mov [bp + 10], bp
12:		add bp, 8
13:		jmp localtime
15:	

ctime$4:	; post call
17:	

ctime$5:	; £temporary2910 = return_value
22:	

ctime$6:	; parameter £temporary2910, offset 6
23:		mov [bp + 14], t1940
25:	

ctime$7:	; call function noellipse-noellipse asctime
26:		mov word [bp + 8], ctime$8
27:		mov [bp + 10], bp
28:		add bp, 8
29:		jmp asctime
31:	

ctime$8:	; post call
33:	

ctime$9:	; £temporary2911 = return_value
38:	

ctime$10:	; return_value = £temporary2911
40:	

ctime$11:	; return
41:		mov t1943, [bp]
42:		mov di, [bp + 4]
43:		mov bp, [bp + 2]
44:		jmp t1943
46:	

ctime$12:	; function end ctime
1:	

localtime:	; call header integral zero 0 stack zero 0
3:	

localtime$1:	; parameter timePtr, offset 6
4:		mov a1944, [bp + 6]
5:		mov [bp + 14], a1944
7:	

localtime$2:	; call function noellipse-noellipse gmtime
8:		mov word [bp + 8], localtime$3
9:		mov [bp + 10], bp
10:		add bp, 8
11:		jmp gmtime
13:	

localtime$3:	; post call
15:	

localtime$4:	; £temporary2914 = return_value
20:	

localtime$5:	; tmPtr = £temporary2914
21:		mov [bp + 8], t1946
23:	

localtime$6:	; call header integral zero 0 stack zero 0
25:	

localtime$7:	; call function noellipse-noellipse localeconv
26:		mov word [bp + 10], localtime$8
27:		mov [bp + 12], bp
28:		add bp, 10
29:		jmp localeconv
31:	

localtime$8:	; post call
33:	

localtime$9:	; £temporary2915 = return_value
38:	

localtime$10:	; localeConvPtr = £temporary2915
39:		mov [bp + 10], t1948
41:	

localtime$11:	; timeZone = 0
42:		mov word [bp + 12], 0
44:	

localtime$12:	; if localeConvPtr == 0 goto 21
45:		cmp word [bp + 10], 0
46:		je localtime$21
48:	

localtime$13:	; £temporary2917 -> tmPtr = *tmPtr, offset 16
49:		mov a1949, [bp + 8]
51:	

localtime$14:	; if £temporary2917 -> tmPtr == 0 goto 18
52:		cmp word [a1949 + 16], 0
53:		je localtime$18
55:	

localtime$15:	; £temporary2918 -> localeConvPtr = *localeConvPtr
56:		mov a1950, [bp + 10]
58:	

localtime$16:	; £temporary2924 = £temporary2918 -> localeConvPtr
59:		mov t1951, [a1950]
61:	

localtime$17:	; goto 20
62:		jmp localtime$20
64:	

localtime$18:	; £temporary2919 -> localeConvPtr = *localeConvPtr, offset 2
65:		mov a1952, [bp + 10]
67:	

localtime$19:	; £temporary2924 = £temporary2919 -> localeConvPtr
68:		mov t1953, [a1952 + 2]
70:	

localtime$20:	; timeZone = £temporary2924
71:		mov [bp + 12], t1953
73:	

localtime$21:	; £temporary2925 -> timePtr = *timePtr
74:		mov a1954, [bp + 6]
76:	

localtime$22:	; £temporary2926 = timeZone * 3600
77:		mov a1955, [bp + 12]
79:		xor dx, dx
80:		imul word [int2$3600#]
86:	

localtime$23:	; £temporary2927 = int_to_int £temporary2926 (Signed_Int -> Unsigned_Long_Int)
88:		and t1958, 65535
90:	

localtime$24:	; time = £temporary2925 -> timePtr + £temporary2927
91:		mov t1959, [a1954]
92:		add t1959, t1958
93:		mov [bp + 14], t1959
95:	

localtime$25:	; call header integral zero 0 stack zero 0
97:	

localtime$26:	; £temporary2929 = &time
98:		mov t1960, bp
99:		add t1960, 14
101:	

localtime$27:	; parameter £temporary2929, offset 6
102:		mov [bp + 24], t1960
104:	

localtime$28:	; call function noellipse-noellipse gmtime
105:		mov word [bp + 18], localtime$29
106:		mov [bp + 20], bp
107:		add bp, 18
108:		jmp gmtime
110:	

localtime$29:	; post call
112:	

localtime$30:	; £temporary2930 = return_value
117:	

localtime$31:	; return_value = £temporary2930
119:	

localtime$32:	; return
120:		mov t1963, [bp]
121:		mov di, [bp + 4]
122:		mov bp, [bp + 2]
123:		jmp t1963
125:	

localtime$33:	; function end localtime
1:	

strftime:	; call header integral zero 0 stack zero 0
3:	

strftime$1:	; call function noellipse-noellipse localeconv
4:		mov word [bp + 14], strftime$2
5:		mov [bp + 16], bp
6:		add bp, 14
7:		jmp localeconv
9:	

strftime$2:	; post call
11:	

strftime$3:	; £temporary2934 = return_value
16:	

strftime$4:	; localeConvPtr = £temporary2934
17:		mov [bp + 14], t1965
19:	

strftime$5:	; if localeConvPtr == 0 goto 9
20:		cmp word [bp + 14], 0
21:		je strftime$9
23:	

strftime$6:	; £temporary2936 -> localeConvPtr = *localeConvPtr, offset 4
24:		mov a1966, [bp + 14]
26:	

strftime$7:	; £temporary2940 = £temporary2936 -> localeConvPtr
27:		mov t1967, [a1966 + 4]
29:	

strftime$8:	; goto 10
30:		jmp strftime$10
32:	

strftime$9:	; £temporary2940 = 0
33:		mov t1968, 0
35:	

strftime$10:	; shortDayList = £temporary2940
36:		mov [bp + 16], t1968
38:	

strftime$11:	; if localeConvPtr == 0 goto 15
39:		cmp word [bp + 14], 0
40:		je strftime$15
42:	

strftime$12:	; £temporary2942 -> localeConvPtr = *localeConvPtr, offset 8
43:		mov a1969, [bp + 14]
45:	

strftime$13:	; £temporary2946 = £temporary2942 -> localeConvPtr
46:		mov t1970, [a1969 + 8]
48:	

strftime$14:	; goto 16
49:		jmp strftime$16
51:	

strftime$15:	; £temporary2946 = 0
52:		mov t1971, 0
54:	

strftime$16:	; shortMonthList = £temporary2946
55:		mov [bp + 18], t1971
57:	

strftime$17:	; if localeConvPtr == 0 goto 21
58:		cmp word [bp + 14], 0
59:		je strftime$21
61:	

strftime$18:	; £temporary2948 -> localeConvPtr = *localeConvPtr, offset 6
62:		mov a1972, [bp + 14]
64:	

strftime$19:	; £temporary2952 = £temporary2948 -> localeConvPtr
65:		mov t1973, [a1972 + 6]
67:	

strftime$20:	; goto 22
68:		jmp strftime$22
70:	

strftime$21:	; £temporary2952 = 0
71:		mov t1974, 0
73:	

strftime$22:	; longDayList = £temporary2952
74:		mov [bp + 20], t1974
76:	

strftime$23:	; if localeConvPtr == 0 goto 27
77:		cmp word [bp + 14], 0
78:		je strftime$27
80:	

strftime$24:	; £temporary2954 -> localeConvPtr = *localeConvPtr, offset 10
81:		mov a1975, [bp + 14]
83:	

strftime$25:	; £temporary2958 = £temporary2954 -> localeConvPtr
84:		mov t1976, [a1975 + 10]
86:	

strftime$26:	; goto 28
87:		jmp strftime$28
89:	

strftime$27:	; £temporary2958 = 0
90:		mov t1977, 0
92:	

strftime$28:	; longMonthList = £temporary2958
93:		mov [bp + 22], t1977
95:	

strftime$29:	; call header integral zero 0 stack zero 0
97:	

strftime$30:	; parameter s, offset 6
98:		mov a1978, [bp + 6]
99:		mov [bp + 30], a1978
101:	

strftime$31:	; parameter string_#, offset 8
102:		mov word [bp + 32], string_#
104:	

strftime$32:	; call function noellipse-noellipse strcpy
105:		mov word [bp + 24], strftime$33
106:		mov [bp + 26], bp
107:		add bp, 24
108:		jmp strcpy
110:	

strftime$33:	; post call
112:	

strftime$34:	; if shortDayList == 0 goto 37
113:		cmp word [bp + 16], 0
114:		je strftime$37
116:	

strftime$35:	; £temporary2964 = shortDayList
117:		mov t1979, [bp + 16]
119:	

strftime$36:	; goto 38
120:		jmp strftime$38
122:	

strftime$37:	; £temporary2964 = g_defaultShortDayList
123:		mov t1980, @32$g_defaultShortDayList
125:	

strftime$38:	; shortDayList = £temporary2964
126:		mov [bp + 16], t1980
128:	

strftime$39:	; if longDayList == 0 goto 42
129:		cmp word [bp + 20], 0
130:		je strftime$42
132:	

strftime$40:	; £temporary2969 = longDayList
133:		mov t1981, [bp + 20]
135:	

strftime$41:	; goto 43
136:		jmp strftime$43
138:	

strftime$42:	; £temporary2969 = g_defaultLongDayList
139:		mov t1982, @33$g_defaultLongDayList
141:	

strftime$43:	; longDayList = £temporary2969
142:		mov [bp + 20], t1982
144:	

strftime$44:	; if shortMonthList == 0 goto 47
145:		cmp word [bp + 18], 0
146:		je strftime$47
148:	

strftime$45:	; £temporary2974 = shortMonthList
149:		mov t1983, [bp + 18]
151:	

strftime$46:	; goto 48
152:		jmp strftime$48
154:	

strftime$47:	; £temporary2974 = g_defaultShortMonthList
155:		mov t1984, @34$g_defaultShortMonthList
157:	

strftime$48:	; shortMonthList = £temporary2974
158:		mov [bp + 18], t1984
160:	

strftime$49:	; if longMonthList == 0 goto 52
161:		cmp word [bp + 22], 0
162:		je strftime$52
164:	

strftime$50:	; £temporary2979 = longMonthList
165:		mov t1985, [bp + 22]
167:	

strftime$51:	; goto 53
168:		jmp strftime$53
170:	

strftime$52:	; £temporary2979 = g_defaultLongMonthList
171:		mov t1986, @35$g_defaultLongMonthList
173:	

strftime$53:	; longMonthList = £temporary2979
174:		mov [bp + 22], t1986
176:	

strftime$54:	; £temporary2980 -> tp = *tp, offset 10
177:		mov a1987, [bp + 12]
179:	

strftime$55:	; £temporary2981 = £temporary2980 -> tp - 69
180:		mov t1988, [a1987 + 10]
181:		sub t1988, 69
183:	

strftime$56:	; leapDays = £temporary2981 / 4
185:		xor dx, dx
186:		idiv word [int2$4#]
187:		mov [bp + 24], ax
189:	

strftime$57:	; £temporary2983 -> tp = *tp, offset 10
190:		mov a1991, [bp + 12]
192:	

strftime$58:	; £temporary2984 = £temporary2983 -> tp - 70
193:		mov t1992, [a1991 + 10]
194:		sub t1992, 70
196:	

strftime$59:	; £temporary2985 = £temporary2984 * 365
198:		xor dx, dx
199:		imul word [int2$365#]
205:	

strftime$60:	; £temporary2986 = £temporary2985 + leapDays
206:		add t1995, [bp + 24]
208:	

strftime$61:	; £temporary2987 -> tp = *tp, offset 14
209:		mov a1996, [bp + 12]
211:	

strftime$62:	; £temporary2988 = £temporary2986 + £temporary2987 -> tp
212:		add t1995, [a1996 + 14]
214:	

strftime$63:	; £temporary2989 = int_to_int £temporary2988 (Signed_Int -> Signed_Long_Int)
216:		and t1995, 65535
218:		cmp t1995, 0
219:		jge strftime$64
220:		neg t1995
222:		neg t1995
224:	

strftime$64:	; totalDays = £temporary2989
225:		mov [bp + 26], t1995
227:	

strftime$65:	; call header integral zero 0 stack zero 0
229:	

strftime$66:	; parameter string_leap20days2025i2C20total20days2025lu0A#, offset 6
230:		mov word [bp + 36], string_leap20days2025i2C20total20days2025lu0A#
232:	

strftime$67:	; parameter leapDays, offset 8
233:		mov a1997, [bp + 24]
234:		mov [bp + 38], a1997
236:	

strftime$68:	; parameter totalDays, offset 10
237:		mov a1998, [bp + 26]
238:		mov [bp + 40], a1998
240:	

strftime$69:	; call function noellipse-ellipse printf, extra 0
241:		mov word [bp + 30], strftime$70
242:		mov [bp + 32], bp
243:		add bp, 30
244:		mov di, bp
245:		add di, 6
246:		jmp printf
248:	

strftime$70:	; post call
250:	

strftime$71:	; if totalDays >= 3 goto 76
251:		cmp dword [bp + 26], 3
252:		jge strftime$76
254:	

strftime$72:	; £temporary2992 = totalDays + 4
255:		mov a1999, [bp + 26]
256:		add a1999, 4
258:	

strftime$73:	; £temporary2993 = int_to_int £temporary2992 (Signed_Long_Int -> Signed_Int)
261:		cmp a1999, 0
262:		jge strftime$74
263:		neg a1999
265:		neg a1999
267:	

strftime$74:	; yearDaySunday = £temporary2993
268:		mov [bp + 30], a1999
270:	

strftime$75:	; goto 80
271:		jmp strftime$80
273:	

strftime$76:	; £temporary2994 = totalDays - 3
274:		mov a2000, [bp + 26]
275:		sub a2000, 3
277:	

strftime$77:	; £temporary2995 = £temporary2994 % 7
279:		xor edx, edx
280:		idiv dword [int4$7#]
286:	

strftime$78:	; £temporary2996 = int_to_int £temporary2995 (Signed_Long_Int -> Signed_Int)
289:		cmp t2002, 0
290:		jge strftime$79
291:		neg t2002
293:		neg t2002
295:	

strftime$79:	; yearDaySunday = £temporary2996
296:		mov [bp + 30], t2002
298:	

strftime$80:	; call header integral zero 0 stack zero 0
300:	

strftime$81:	; parameter string_yearDaySunday2025i0A#, offset 6
301:		mov word [bp + 40], string_yearDaySunday2025i0A#
303:	

strftime$82:	; parameter yearDaySunday, offset 8
304:		mov a2003, [bp + 30]
305:		mov [bp + 42], a2003
307:	

strftime$83:	; call function noellipse-ellipse printf, extra 0
308:		mov word [bp + 34], strftime$84
309:		mov [bp + 36], bp
310:		add bp, 34
311:		mov di, bp
312:		add di, 2
313:		jmp printf
315:	

strftime$84:	; post call
317:	

strftime$85:	; if totalDays >= 4 goto 90
318:		cmp dword [bp + 26], 4
319:		jge strftime$90
321:	

strftime$86:	; £temporary2999 = totalDays + 3
322:		mov a2004, [bp + 26]
323:		add a2004, 3
325:	

strftime$87:	; £temporary3000 = int_to_int £temporary2999 (Signed_Long_Int -> Signed_Int)
328:		cmp a2004, 0
329:		jge strftime$88
330:		neg a2004
332:		neg a2004
334:	

strftime$88:	; yearDayMonday = £temporary3000
335:		mov [bp + 32], a2004
337:	

strftime$89:	; goto 94
338:		jmp strftime$94
340:	

strftime$90:	; £temporary3001 = totalDays - 4
341:		mov a2005, [bp + 26]
342:		sub a2005, 4
344:	

strftime$91:	; £temporary3002 = £temporary3001 % 7
346:		xor edx, edx
347:		idiv dword [int4$7#]
353:	

strftime$92:	; £temporary3003 = int_to_int £temporary3002 (Signed_Long_Int -> Signed_Int)
356:		cmp t2007, 0
357:		jge strftime$93
358:		neg t2007
360:		neg t2007
362:	

strftime$93:	; yearDayMonday = £temporary3003
363:		mov [bp + 32], t2007
365:	

strftime$94:	; call header integral zero 0 stack zero 0
367:	

strftime$95:	; parameter string_yearDayMonday2025i0A#, offset 6
368:		mov word [bp + 40], string_yearDayMonday2025i0A#
370:	

strftime$96:	; parameter yearDayMonday, offset 8
371:		mov a2008, [bp + 32]
372:		mov [bp + 42], a2008
374:	

strftime$97:	; call function noellipse-ellipse printf, extra 0
375:		mov word [bp + 34], strftime$98
376:		mov [bp + 36], bp
377:		add bp, 34
378:		mov di, bp
379:		add di, 2
380:		jmp printf
382:	

strftime$98:	; post call
384:	

strftime$99:	; index = 0
385:		mov word [bp + 34], 0
387:	

strftime$100:	; £temporary3006 = fmt + index
388:		mov a2009, [bp + 10]
389:		add a2009, [bp + 34]
391:	

strftime$101:	; £temporary3005 -> £temporary3006 = *£temporary3006
393:	

strftime$102:	; if £temporary3005 -> £temporary3006 == 0 goto 366
394:		cmp byte [a2009], 0
395:		je strftime$366
397:	

strftime$103:	; £temporary3010 = fmt + index
398:		mov a2010, [bp + 10]
399:		add a2010, [bp + 34]
401:	

strftime$104:	; £temporary3009 -> £temporary3010 = *£temporary3010
403:	

strftime$105:	; if £temporary3009 -> £temporary3010 != 37 goto 341
404:		cmp byte [a2010], 37
405:		jne strftime$341
407:	

strftime$106:	; £temporary3012 = index + 1
408:		mov a2011, [bp + 34]
409:		add a2011, 1
411:	

strftime$107:	; £temporary3014 = fmt + £temporary3012
412:		mov a2012, [bp + 10]
413:		add a2012, a2011
415:	

strftime$108:	; £temporary3013 -> £temporary3014 = *£temporary3014
416:		mov t2013, [a2012]
417:		mov [bp + 56], t2013
419:	

strftime$109:	; case £temporary3013 -> £temporary3014 == 97 goto 133
420:		mov t2014, [bp + 56]
421:		cmp t2014, 97
422:		je strftime$133
424:	

strftime$110:	; case £temporary3013 -> £temporary3014 == 65 goto 143
425:		cmp t2014, 65
426:		je strftime$143
428:	

strftime$111:	; case £temporary3013 -> £temporary3014 == 98 goto 153
429:		cmp t2014, 98
430:		je strftime$153
432:	

strftime$112:	; case £temporary3013 -> £temporary3014 == 66 goto 163
433:		cmp t2014, 66
434:		je strftime$163
436:	

strftime$113:	; case £temporary3013 -> £temporary3014 == 99 goto 173
437:		cmp t2014, 99
438:		je strftime$173
440:	

strftime$114:	; case £temporary3013 -> £temporary3014 == 100 goto 193
441:		cmp t2014, 100
442:		je strftime$193
444:	

strftime$115:	; case £temporary3013 -> £temporary3014 == 72 goto 201
445:		cmp t2014, 72
446:		je strftime$201
448:	

strftime$116:	; case £temporary3013 -> £temporary3014 == 73 goto 209
449:		cmp t2014, 73
450:		je strftime$209
452:	

strftime$117:	; case £temporary3013 -> £temporary3014 == 106 goto 218
453:		cmp t2014, 106
454:		je strftime$218
456:	

strftime$118:	; case £temporary3013 -> £temporary3014 == 109 goto 226
457:		cmp t2014, 109
458:		je strftime$226
460:	

strftime$119:	; case £temporary3013 -> £temporary3014 == 77 goto 235
461:		cmp t2014, 77
462:		je strftime$235
464:	

strftime$120:	; case £temporary3013 -> £temporary3014 == 112 goto 243
465:		cmp t2014, 112
466:		je strftime$243
468:	

strftime$121:	; case £temporary3013 -> £temporary3014 == 83 goto 255
469:		cmp t2014, 83
470:		je strftime$255
472:	

strftime$122:	; case £temporary3013 -> £temporary3014 == 85 goto 263
473:		cmp t2014, 85
474:		je strftime$263
476:	

strftime$123:	; case £temporary3013 -> £temporary3014 == 119 goto 270
477:		cmp t2014, 119
478:		je strftime$270
480:	

strftime$124:	; case £temporary3013 -> £temporary3014 == 87 goto 278
481:		cmp t2014, 87
482:		je strftime$278
484:	

strftime$125:	; case £temporary3013 -> £temporary3014 == 120 goto 285
485:		cmp t2014, 120
486:		je strftime$285
488:	

strftime$126:	; case £temporary3013 -> £temporary3014 == 88 goto 299
489:		cmp t2014, 88
490:		je strftime$299
492:	

strftime$127:	; case £temporary3013 -> £temporary3014 == 121 goto 311
493:		cmp t2014, 121
494:		je strftime$311
496:	

strftime$128:	; case £temporary3013 -> £temporary3014 == 89 goto 320
497:		cmp t2014, 89
498:		je strftime$320
500:	

strftime$129:	; case £temporary3013 -> £temporary3014 == 90 goto 329
501:		cmp t2014, 90
502:		je strftime$329
504:	

strftime$130:	; case £temporary3013 -> £temporary3014 == 37 goto 335
505:		cmp t2014, 37
506:		je strftime$335
508:	

strftime$131:	; case end £temporary3013 -> £temporary3014
510:	

strftime$132:	; goto 347
511:		jmp strftime$347
513:	

strftime$133:	; call header integral zero 0 stack zero 0
515:	

strftime$134:	; parameter add, offset 6
516:		mov [bp + 62], bp
517:		add word [bp + 62], 36
519:	

strftime$135:	; £temporary3015 -> tp = *tp, offset 12
520:		mov a2015, [bp + 12]
522:	

strftime$136:	; £temporary3017 = £temporary3015 -> tp * 2
523:		mov t2016, [a2015 + 12]
525:		xor dx, dx
526:		mul word [int2$2#]
532:	

strftime$137:	; £temporary3018 = shortDayList + £temporary3017
533:		mov a2020, [bp + 16]
534:		add a2020, t2019
536:	

strftime$138:	; £temporary3016 -> £temporary3018 = *£temporary3018
538:	

strftime$139:	; parameter £temporary3016 -> £temporary3018, offset 8
539:		mov t2021, [a2020]
540:		mov [bp + 64], t2021
542:	

strftime$140:	; call function noellipse-noellipse strcpy
543:		mov word [bp + 56], strftime$141
544:		mov [bp + 58], bp
545:		add bp, 56
546:		jmp strcpy
548:	

strftime$141:	; post call
550:	

strftime$142:	; goto 347
551:		jmp strftime$347
553:	

strftime$143:	; call header integral zero 0 stack zero 0
555:	

strftime$144:	; parameter add, offset 6
556:		mov [bp + 62], bp
557:		add word [bp + 62], 36
559:	

strftime$145:	; £temporary3020 -> tp = *tp, offset 12
560:		mov a2022, [bp + 12]
562:	

strftime$146:	; £temporary3022 = £temporary3020 -> tp * 2
563:		mov t2023, [a2022 + 12]
565:		xor dx, dx
566:		mul word [int2$2#]
572:	

strftime$147:	; £temporary3023 = longDayList + £temporary3022
573:		mov a2027, [bp + 20]
574:		add a2027, t2026
576:	

strftime$148:	; £temporary3021 -> £temporary3023 = *£temporary3023
578:	

strftime$149:	; parameter £temporary3021 -> £temporary3023, offset 8
579:		mov t2028, [a2027]
580:		mov [bp + 64], t2028
582:	

strftime$150:	; call function noellipse-noellipse strcpy
583:		mov word [bp + 56], strftime$151
584:		mov [bp + 58], bp
585:		add bp, 56
586:		jmp strcpy
588:	

strftime$151:	; post call
590:	

strftime$152:	; goto 347
591:		jmp strftime$347
593:	

strftime$153:	; call header integral zero 0 stack zero 0
595:	

strftime$154:	; parameter add, offset 6
596:		mov [bp + 62], bp
597:		add word [bp + 62], 36
599:	

strftime$155:	; £temporary3025 -> tp = *tp, offset 8
600:		mov a2029, [bp + 12]
602:	

strftime$156:	; £temporary3027 = £temporary3025 -> tp * 2
603:		mov t2030, [a2029 + 8]
605:		xor dx, dx
606:		mul word [int2$2#]
612:	

strftime$157:	; £temporary3028 = shortMonthList + £temporary3027
613:		mov a2034, [bp + 18]
614:		add a2034, t2033
616:	

strftime$158:	; £temporary3026 -> £temporary3028 = *£temporary3028
618:	

strftime$159:	; parameter £temporary3026 -> £temporary3028, offset 8
619:		mov t2035, [a2034]
620:		mov [bp + 64], t2035
622:	

strftime$160:	; call function noellipse-noellipse strcpy
623:		mov word [bp + 56], strftime$161
624:		mov [bp + 58], bp
625:		add bp, 56
626:		jmp strcpy
628:	

strftime$161:	; post call
630:	

strftime$162:	; goto 347
631:		jmp strftime$347
633:	

strftime$163:	; call header integral zero 0 stack zero 0
635:	

strftime$164:	; parameter add, offset 6
636:		mov [bp + 62], bp
637:		add word [bp + 62], 36
639:	

strftime$165:	; £temporary3030 -> tp = *tp, offset 8
640:		mov a2036, [bp + 12]
642:	

strftime$166:	; £temporary3032 = £temporary3030 -> tp * 2
643:		mov t2037, [a2036 + 8]
645:		xor dx, dx
646:		mul word [int2$2#]
652:	

strftime$167:	; £temporary3033 = longMonthList + £temporary3032
653:		mov a2041, [bp + 22]
654:		add a2041, t2040
656:	

strftime$168:	; £temporary3031 -> £temporary3033 = *£temporary3033
658:	

strftime$169:	; parameter £temporary3031 -> £temporary3033, offset 8
659:		mov t2042, [a2041]
660:		mov [bp + 64], t2042
662:	

strftime$170:	; call function noellipse-noellipse strcpy
663:		mov word [bp + 56], strftime$171
664:		mov [bp + 58], bp
665:		add bp, 56
666:		jmp strcpy
668:	

strftime$171:	; post call
670:	

strftime$172:	; goto 347
671:		jmp strftime$347
673:	

strftime$173:	; call header integral zero 0 stack zero 0
675:	

strftime$174:	; parameter add, offset 6
676:		mov [bp + 62], bp
677:		add word [bp + 62], 36
679:	

strftime$175:	; parameter string_2504d2D2502d2D2502d202502d3A2502d3A2502d#, offset 8
680:		mov word [bp + 64], string_2504d2D2502d2D2502d202502d3A2502d3A2502d#
682:	

strftime$176:	; £temporary3035 -> tp = *tp, offset 10
683:		mov a2043, [bp + 12]
685:	

strftime$177:	; £temporary3036 = £temporary3035 -> tp + 1900
686:		mov t2044, [a2043 + 10]
687:		add t2044, 1900
689:	

strftime$178:	; parameter £temporary3036, offset 10
690:		mov [bp + 66], t2044
692:	

strftime$179:	; £temporary3037 -> tp = *tp, offset 8
693:		mov a2045, [bp + 12]
695:	

strftime$180:	; £temporary3038 = £temporary3037 -> tp + 1
696:		mov t2046, [a2045 + 8]
697:		add t2046, 1
699:	

strftime$181:	; parameter £temporary3038, offset 12
700:		mov [bp + 68], t2046
702:	

strftime$182:	; £temporary3039 -> tp = *tp, offset 6
703:		mov a2047, [bp + 12]
705:	

strftime$183:	; parameter £temporary3039 -> tp, offset 14
706:		mov t2048, [a2047 + 6]
707:		mov [bp + 70], t2048
709:	

strftime$184:	; £temporary3040 -> tp = *tp, offset 4
710:		mov a2049, [bp + 12]
712:	

strftime$185:	; parameter £temporary3040 -> tp, offset 16
713:		mov t2050, [a2049 + 4]
714:		mov [bp + 72], t2050
716:	

strftime$186:	; £temporary3041 -> tp = *tp, offset 2
717:		mov a2051, [bp + 12]
719:	

strftime$187:	; parameter £temporary3041 -> tp, offset 18
720:		mov t2052, [a2051 + 2]
721:		mov [bp + 74], t2052
723:	

strftime$188:	; £temporary3042 -> tp = *tp
724:		mov a2053, [bp + 12]
726:	

strftime$189:	; parameter £temporary3042 -> tp, offset 20
727:		mov t2054, [a2053]
728:		mov [bp + 76], t2054
730:	

strftime$190:	; call function noellipse-ellipse sprintf, extra 0
731:		mov word [bp + 56], strftime$191
732:		mov [bp + 58], bp
733:		add bp, 56
734:		mov di, bp
735:		add di, 12
736:		jmp sprintf
738:	

strftime$191:	; post call
740:	

strftime$192:	; goto 347
741:		jmp strftime$347
743:	

strftime$193:	; call header integral zero 0 stack zero 0
745:	

strftime$194:	; parameter add, offset 6
746:		mov [bp + 62], bp
747:		add word [bp + 62], 36
749:	

strftime$195:	; parameter string_2502d#, offset 8
750:		mov word [bp + 64], string_2502d#
752:	

strftime$196:	; £temporary3044 -> tp = *tp, offset 6
753:		mov a2055, [bp + 12]
755:	

strftime$197:	; parameter £temporary3044 -> tp, offset 10
756:		mov t2056, [a2055 + 6]
757:		mov [bp + 66], t2056
759:	

strftime$198:	; call function noellipse-ellipse sprintf, extra 0
760:		mov word [bp + 56], strftime$199
761:		mov [bp + 58], bp
762:		add bp, 56
763:		mov di, bp
764:		add di, 2
765:		jmp sprintf
767:	

strftime$199:	; post call
769:	

strftime$200:	; goto 347
770:		jmp strftime$347
772:	

strftime$201:	; call header integral zero 0 stack zero 0
774:	

strftime$202:	; parameter add, offset 6
775:		mov [bp + 62], bp
776:		add word [bp + 62], 36
778:	

strftime$203:	; parameter string_2502d#, offset 8
779:		mov word [bp + 64], string_2502d#
781:	

strftime$204:	; £temporary3046 -> tp = *tp, offset 4
782:		mov a2057, [bp + 12]
784:	

strftime$205:	; parameter £temporary3046 -> tp, offset 10
785:		mov t2058, [a2057 + 4]
786:		mov [bp + 66], t2058
788:	

strftime$206:	; call function noellipse-ellipse sprintf, extra 0
789:		mov word [bp + 56], strftime$207
790:		mov [bp + 58], bp
791:		add bp, 56
792:		mov di, bp
793:		add di, 2
794:		jmp sprintf
796:	

strftime$207:	; post call
798:	

strftime$208:	; goto 347
799:		jmp strftime$347
801:	

strftime$209:	; call header integral zero 0 stack zero 0
803:	

strftime$210:	; parameter add, offset 6
804:		mov [bp + 62], bp
805:		add word [bp + 62], 36
807:	

strftime$211:	; parameter string_2502d#, offset 8
808:		mov word [bp + 64], string_2502d#
810:	

strftime$212:	; £temporary3048 -> tp = *tp, offset 4
811:		mov a2059, [bp + 12]
813:	

strftime$213:	; £temporary3049 = £temporary3048 -> tp % 12
814:		mov t2060, [a2059 + 4]
816:		xor dx, dx
817:		idiv word [int2$12#]
823:	

strftime$214:	; parameter £temporary3049, offset 10
824:		mov [bp + 66], t2062
826:	

strftime$215:	; call function noellipse-ellipse sprintf, extra 0
827:		mov word [bp + 56], strftime$216
828:		mov [bp + 58], bp
829:		add bp, 56
830:		mov di, bp
831:		add di, 2
832:		jmp sprintf
834:	

strftime$216:	; post call
836:	

strftime$217:	; goto 347
837:		jmp strftime$347
839:	

strftime$218:	; call header integral zero 0 stack zero 0
841:	

strftime$219:	; parameter add, offset 6
842:		mov [bp + 62], bp
843:		add word [bp + 62], 36
845:	

strftime$220:	; parameter string_2503d#, offset 8
846:		mov word [bp + 64], string_2503d#
848:	

strftime$221:	; £temporary3051 -> tp = *tp, offset 14
849:		mov a2063, [bp + 12]
851:	

strftime$222:	; parameter £temporary3051 -> tp, offset 10
852:		mov t2064, [a2063 + 14]
853:		mov [bp + 66], t2064
855:	

strftime$223:	; call function noellipse-ellipse sprintf, extra 0
856:		mov word [bp + 56], strftime$224
857:		mov [bp + 58], bp
858:		add bp, 56
859:		mov di, bp
860:		add di, 2
861:		jmp sprintf
863:	

strftime$224:	; post call
865:	

strftime$225:	; goto 347
866:		jmp strftime$347
868:	

strftime$226:	; call header integral zero 0 stack zero 0
870:	

strftime$227:	; parameter add, offset 6
871:		mov [bp + 62], bp
872:		add word [bp + 62], 36
874:	

strftime$228:	; parameter string_2502d#, offset 8
875:		mov word [bp + 64], string_2502d#
877:	

strftime$229:	; £temporary3053 -> tp = *tp, offset 8
878:		mov a2065, [bp + 12]
880:	

strftime$230:	; £temporary3054 = £temporary3053 -> tp + 1
881:		mov t2066, [a2065 + 8]
882:		add t2066, 1
884:	

strftime$231:	; parameter £temporary3054, offset 10
885:		mov [bp + 66], t2066
887:	

strftime$232:	; call function noellipse-ellipse sprintf, extra 0
888:		mov word [bp + 56], strftime$233
889:		mov [bp + 58], bp
890:		add bp, 56
891:		mov di, bp
892:		add di, 2
893:		jmp sprintf
895:	

strftime$233:	; post call
897:	

strftime$234:	; goto 347
898:		jmp strftime$347
900:	

strftime$235:	; call header integral zero 0 stack zero 0
902:	

strftime$236:	; parameter add, offset 6
903:		mov [bp + 62], bp
904:		add word [bp + 62], 36
906:	

strftime$237:	; parameter string_2502d#, offset 8
907:		mov word [bp + 64], string_2502d#
909:	

strftime$238:	; £temporary3056 -> tp = *tp, offset 2
910:		mov a2067, [bp + 12]
912:	

strftime$239:	; parameter £temporary3056 -> tp, offset 10
913:		mov t2068, [a2067 + 2]
914:		mov [bp + 66], t2068
916:	

strftime$240:	; call function noellipse-ellipse sprintf, extra 0
917:		mov word [bp + 56], strftime$241
918:		mov [bp + 58], bp
919:		add bp, 56
920:		mov di, bp
921:		add di, 2
922:		jmp sprintf
924:	

strftime$241:	; post call
926:	

strftime$242:	; goto 347
927:		jmp strftime$347
929:	

strftime$243:	; call header integral zero 0 stack zero 0
931:	

strftime$244:	; parameter add, offset 6
932:		mov [bp + 62], bp
933:		add word [bp + 62], 36
935:	

strftime$245:	; parameter string_25s#, offset 8
936:		mov word [bp + 64], string_25s#
938:	

strftime$246:	; £temporary3058 -> tp = *tp, offset 4
939:		mov a2069, [bp + 12]
941:	

strftime$247:	; if £temporary3058 -> tp >= 12 goto 250
942:		cmp word [a2069 + 4], 12
943:		jge strftime$250
945:	

strftime$248:	; £temporary3063 = string_AM#
946:		mov t2070, string_AM#
948:	

strftime$249:	; goto 251
949:		jmp strftime$251
951:	

strftime$250:	; £temporary3063 = string_PM#
952:		mov t2071, string_PM#
954:	

strftime$251:	; parameter £temporary3063, offset 10
955:		mov [bp + 66], t2071
957:	

strftime$252:	; call function noellipse-ellipse sprintf, extra 0
958:		mov word [bp + 56], strftime$253
959:		mov [bp + 58], bp
960:		add bp, 56
961:		mov di, bp
962:		add di, 2
963:		jmp sprintf
965:	

strftime$253:	; post call
967:	

strftime$254:	; goto 347
968:		jmp strftime$347
970:	

strftime$255:	; call header integral zero 0 stack zero 0
972:	

strftime$256:	; parameter add, offset 6
973:		mov [bp + 62], bp
974:		add word [bp + 62], 36
976:	

strftime$257:	; parameter string_2502d#, offset 8
977:		mov word [bp + 64], string_2502d#
979:	

strftime$258:	; £temporary3065 -> tp = *tp
980:		mov a2072, [bp + 12]
982:	

strftime$259:	; parameter £temporary3065 -> tp, offset 10
983:		mov t2073, [a2072]
984:		mov [bp + 66], t2073
986:	

strftime$260:	; call function noellipse-ellipse sprintf, extra 0
987:		mov word [bp + 56], strftime$261
988:		mov [bp + 58], bp
989:		add bp, 56
990:		mov di, bp
991:		add di, 2
992:		jmp sprintf
994:	

strftime$261:	; post call
996:	

strftime$262:	; goto 347
997:		jmp strftime$347
999:	

strftime$263:	; call header integral zero 0 stack zero 0
1001:	

strftime$264:	; parameter add, offset 6
1002:		mov [bp + 62], bp
1003:		add word [bp + 62], 36
1005:	

strftime$265:	; parameter string_2502d#, offset 8
1006:		mov word [bp + 64], string_2502d#
1008:	

strftime$266:	; parameter yearDaySunday, offset 10
1009:		mov a2074, [bp + 30]
1010:		mov [bp + 66], a2074
1012:	

strftime$267:	; call function noellipse-ellipse sprintf, extra 0
1013:		mov word [bp + 56], strftime$268
1014:		mov [bp + 58], bp
1015:		add bp, 56
1016:		mov di, bp
1017:		add di, 2
1018:		jmp sprintf
1020:	

strftime$268:	; post call
1022:	

strftime$269:	; goto 347
1023:		jmp strftime$347
1025:	

strftime$270:	; call header integral zero 0 stack zero 0
1027:	

strftime$271:	; parameter add, offset 6
1028:		mov [bp + 62], bp
1029:		add word [bp + 62], 36
1031:	

strftime$272:	; parameter string_2502d#, offset 8
1032:		mov word [bp + 64], string_2502d#
1034:	

strftime$273:	; £temporary3068 -> tp = *tp, offset 12
1035:		mov a2075, [bp + 12]
1037:	

strftime$274:	; parameter £temporary3068 -> tp, offset 10
1038:		mov t2076, [a2075 + 12]
1039:		mov [bp + 66], t2076
1041:	

strftime$275:	; call function noellipse-ellipse sprintf, extra 0
1042:		mov word [bp + 56], strftime$276
1043:		mov [bp + 58], bp
1044:		add bp, 56
1045:		mov di, bp
1046:		add di, 2
1047:		jmp sprintf
1049:	

strftime$276:	; post call
1051:	

strftime$277:	; goto 347
1052:		jmp strftime$347
1054:	

strftime$278:	; call header integral zero 0 stack zero 0
1056:	

strftime$279:	; parameter add, offset 6
1057:		mov [bp + 62], bp
1058:		add word [bp + 62], 36
1060:	

strftime$280:	; parameter string_2502d#, offset 8
1061:		mov word [bp + 64], string_2502d#
1063:	

strftime$281:	; parameter yearDayMonday, offset 10
1064:		mov a2077, [bp + 32]
1065:		mov [bp + 66], a2077
1067:	

strftime$282:	; call function noellipse-ellipse sprintf, extra 0
1068:		mov word [bp + 56], strftime$283
1069:		mov [bp + 58], bp
1070:		add bp, 56
1071:		mov di, bp
1072:		add di, 2
1073:		jmp sprintf
1075:	

strftime$283:	; post call
1077:	

strftime$284:	; goto 347
1078:		jmp strftime$347
1080:	

strftime$285:	; call header integral zero 0 stack zero 0
1082:	

strftime$286:	; parameter add, offset 6
1083:		mov [bp + 62], bp
1084:		add word [bp + 62], 36
1086:	

strftime$287:	; parameter string_2504d2D2502d2D2502d#, offset 8
1087:		mov word [bp + 64], string_2504d2D2502d2D2502d#
1089:	

strftime$288:	; £temporary3071 -> tp = *tp, offset 10
1090:		mov a2078, [bp + 12]
1092:	

strftime$289:	; £temporary3072 = £temporary3071 -> tp + 1900
1093:		mov t2079, [a2078 + 10]
1094:		add t2079, 1900
1096:	

strftime$290:	; parameter £temporary3072, offset 10
1097:		mov [bp + 66], t2079
1099:	

strftime$291:	; £temporary3073 -> tp = *tp, offset 8
1100:		mov a2080, [bp + 12]
1102:	

strftime$292:	; £temporary3074 = £temporary3073 -> tp + 1
1103:		mov t2081, [a2080 + 8]
1104:		add t2081, 1
1106:	

strftime$293:	; parameter £temporary3074, offset 12
1107:		mov [bp + 68], t2081
1109:	

strftime$294:	; £temporary3075 -> tp = *tp, offset 6
1110:		mov a2082, [bp + 12]
1112:	

strftime$295:	; parameter £temporary3075 -> tp, offset 14
1113:		mov t2083, [a2082 + 6]
1114:		mov [bp + 70], t2083
1116:	

strftime$296:	; call function noellipse-ellipse sprintf, extra 0
1117:		mov word [bp + 56], strftime$297
1118:		mov [bp + 58], bp
1119:		add bp, 56
1120:		mov di, bp
1121:		add di, 6
1122:		jmp sprintf
1124:	

strftime$297:	; post call
1126:	

strftime$298:	; goto 347
1127:		jmp strftime$347
1129:	

strftime$299:	; call header integral zero 0 stack zero 0
1131:	

strftime$300:	; parameter add, offset 6
1132:		mov [bp + 62], bp
1133:		add word [bp + 62], 36
1135:	

strftime$301:	; parameter string_2502d3A2502d3A2502d#, offset 8
1136:		mov word [bp + 64], string_2502d3A2502d3A2502d#
1138:	

strftime$302:	; £temporary3077 -> tp = *tp, offset 4
1139:		mov a2084, [bp + 12]
1141:	

strftime$303:	; parameter £temporary3077 -> tp, offset 10
1142:		mov t2085, [a2084 + 4]
1143:		mov [bp + 66], t2085
1145:	

strftime$304:	; £temporary3078 -> tp = *tp, offset 2
1146:		mov a2086, [bp + 12]
1148:	

strftime$305:	; parameter £temporary3078 -> tp, offset 12
1149:		mov t2087, [a2086 + 2]
1150:		mov [bp + 68], t2087
1152:	

strftime$306:	; £temporary3079 -> tp = *tp
1153:		mov a2088, [bp + 12]
1155:	

strftime$307:	; parameter £temporary3079 -> tp, offset 14
1156:		mov t2089, [a2088]
1157:		mov [bp + 70], t2089
1159:	

strftime$308:	; call function noellipse-ellipse sprintf, extra 0
1160:		mov word [bp + 56], strftime$309
1161:		mov [bp + 58], bp
1162:		add bp, 56
1163:		mov di, bp
1164:		add di, 6
1165:		jmp sprintf
1167:	

strftime$309:	; post call
1169:	

strftime$310:	; goto 347
1170:		jmp strftime$347
1172:	

strftime$311:	; call header integral zero 0 stack zero 0
1174:	

strftime$312:	; parameter add, offset 6
1175:		mov [bp + 62], bp
1176:		add word [bp + 62], 36
1178:	

strftime$313:	; parameter string_2502d#, offset 8
1179:		mov word [bp + 64], string_2502d#
1181:	

strftime$314:	; £temporary3081 -> tp = *tp, offset 10
1182:		mov a2090, [bp + 12]
1184:	

strftime$315:	; £temporary3082 = £temporary3081 -> tp % 100
1185:		mov t2091, [a2090 + 10]
1187:		xor dx, dx
1188:		idiv word [int2$100#]
1194:	

strftime$316:	; parameter £temporary3082, offset 10
1195:		mov [bp + 66], t2093
1197:	

strftime$317:	; call function noellipse-ellipse sprintf, extra 0
1198:		mov word [bp + 56], strftime$318
1199:		mov [bp + 58], bp
1200:		add bp, 56
1201:		mov di, bp
1202:		add di, 2
1203:		jmp sprintf
1205:	

strftime$318:	; post call
1207:	

strftime$319:	; goto 347
1208:		jmp strftime$347
1210:	

strftime$320:	; call header integral zero 0 stack zero 0
1212:	

strftime$321:	; parameter add, offset 6
1213:		mov [bp + 62], bp
1214:		add word [bp + 62], 36
1216:	

strftime$322:	; parameter string_2504d#, offset 8
1217:		mov word [bp + 64], string_2504d#
1219:	

strftime$323:	; £temporary3084 -> tp = *tp, offset 10
1220:		mov a2094, [bp + 12]
1222:	

strftime$324:	; £temporary3085 = £temporary3084 -> tp + 1900
1223:		mov t2095, [a2094 + 10]
1224:		add t2095, 1900
1226:	

strftime$325:	; parameter £temporary3085, offset 10
1227:		mov [bp + 66], t2095
1229:	

strftime$326:	; call function noellipse-ellipse sprintf, extra 0
1230:		mov word [bp + 56], strftime$327
1231:		mov [bp + 58], bp
1232:		add bp, 56
1233:		mov di, bp
1234:		add di, 2
1235:		jmp sprintf
1237:	

strftime$327:	; post call
1239:	

strftime$328:	; goto 347
1240:		jmp strftime$347
1242:	

strftime$329:	; call header integral zero 0 stack zero 0
1244:	

strftime$330:	; parameter add, offset 6
1245:		mov [bp + 62], bp
1246:		add word [bp + 62], 36
1248:	

strftime$331:	; parameter string_#, offset 8
1249:		mov word [bp + 64], string_#
1251:	

strftime$332:	; call function noellipse-noellipse strcpy
1252:		mov word [bp + 56], strftime$333
1253:		mov [bp + 58], bp
1254:		add bp, 56
1255:		jmp strcpy
1257:	

strftime$333:	; post call
1259:	

strftime$334:	; goto 347
1260:		jmp strftime$347
1262:	

strftime$335:	; call header integral zero 0 stack zero 0
1264:	

strftime$336:	; parameter add, offset 6
1265:		mov [bp + 62], bp
1266:		add word [bp + 62], 36
1268:	

strftime$337:	; parameter string_25#, offset 8
1269:		mov word [bp + 64], string_25#
1271:	

strftime$338:	; call function noellipse-noellipse strcpy
1272:		mov word [bp + 56], strftime$339
1273:		mov [bp + 58], bp
1274:		add bp, 56
1275:		jmp strcpy
1277:	

strftime$339:	; post call
1279:	

strftime$340:	; goto 347
1280:		jmp strftime$347
1282:	

strftime$341:	; £temporary3089 -> add = *add
1283:		mov a2096, bp
1284:		add a2096, 36
1286:	

strftime$342:	; £temporary3091 = fmt + index
1287:		mov a2097, [bp + 10]
1288:		add a2097, [bp + 34]
1290:	

strftime$343:	; £temporary3090 -> £temporary3091 = *£temporary3091
1292:	

strftime$344:	; £temporary3089 -> add = £temporary3090 -> £temporary3091
1293:		mov t2098, [a2097]
1294:		mov [a2096], t2098
1296:	

strftime$345:	; £temporary3092 -> add = *add, offset 1
1297:		mov a2099, bp
1298:		add a2099, 36
1300:	

strftime$346:	; £temporary3092 -> add = 0
1301:		mov byte [a2099 + 1], 0
1303:	

strftime$347:	; call header integral zero 0 stack zero 0
1305:	

strftime$348:	; parameter s, offset 6
1306:		mov a2100, [bp + 6]
1307:		mov [bp + 62], a2100
1309:	

strftime$349:	; call function noellipse-noellipse strlen
1310:		mov word [bp + 56], strftime$350
1311:		mov [bp + 58], bp
1312:		add bp, 56
1313:		jmp strlen
1315:	

strftime$350:	; post call
1317:	

strftime$351:	; £temporary3093 = return_value
1322:	

strftime$352:	; call header integral no zero 1 stack zero 0
1323:		mov [bp + 56], t2102
1325:	

strftime$353:	; parameter add, offset 6
1326:		mov [bp + 64], bp
1327:		add word [bp + 64], 36
1329:	

strftime$354:	; call function noellipse-noellipse strlen
1330:		mov word [bp + 58], strftime$355
1331:		mov [bp + 60], bp
1332:		add bp, 58
1333:		jmp strlen
1335:	

strftime$355:	; post call
1336:		mov t2102, [bp + 56]
1338:		mov t2103, t2102
1340:	

strftime$356:	; £temporary3094 = return_value
1345:	

strftime$357:	; £temporary3095 = £temporary3093 + £temporary3094
1346:		add t2103, t2105
1348:	

strftime$358:	; if £temporary3095 >= smax goto 366
1349:		cmp t2103, [bp + 8]
1350:		jge strftime$366
1352:	

strftime$359:	; call header integral zero 0 stack zero 0
1354:	

strftime$360:	; parameter s, offset 6
1355:		mov a2106, [bp + 6]
1356:		mov [bp + 62], a2106
1358:	

strftime$361:	; parameter add, offset 8
1359:		mov [bp + 64], bp
1360:		add word [bp + 64], 36
1362:	

strftime$362:	; call function noellipse-noellipse strcat
1363:		mov word [bp + 56], strftime$363
1364:		mov [bp + 58], bp
1365:		add bp, 56
1366:		jmp strcat
1368:	

strftime$363:	; post call
1370:	

strftime$364:	; ++index
1371:		inc word [bp + 34]
1373:	

strftime$365:	; goto 100
1374:		jmp strftime$100
1376:	

strftime$366:	; call header integral zero 0 stack zero 0
1378:	

strftime$367:	; parameter s, offset 6
1379:		mov a2107, [bp + 6]
1380:		mov [bp + 42], a2107
1382:	

strftime$368:	; call function noellipse-noellipse strlen
1383:		mov word [bp + 36], strftime$369
1384:		mov [bp + 38], bp
1385:		add bp, 36
1386:		jmp strlen
1388:	

strftime$369:	; post call
1390:	

strftime$370:	; £temporary3098 = return_value
1395:	

strftime$371:	; return_value = £temporary3098
1397:	

strftime$372:	; return
1398:		mov t2110, [bp]
1399:		mov di, [bp + 4]
1400:		mov bp, [bp + 2]
1401:		jmp t2110
1403:	

strftime$373:	; function end strftime
