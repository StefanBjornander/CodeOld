1:	

exp:	; push 0
2:		fldz
4:	

exp$1:	; pop float i
5:		fstp qword [bp + 14]
7:	

exp$2:	; push 0
8:		fldz
10:	

exp$3:	; pop float sum
11:		fstp qword [bp + 30]
13:	

exp$4:	; push 1
14:		fld1
16:	

exp$5:	; pop float faculty
17:		fstp qword [bp + 38]
19:	

exp$6:	; push 1
20:		fld1
22:	

exp$7:	; top float power
23:		fst qword [bp + 46]
25:	

exp$8:	; push float faculty
26:		fld qword [bp + 38]
28:	

exp$9:	; £temporary525 = power / faculty
29:		fdiv
31:	

exp$10:	; pop float term
32:		fstp qword [bp + 22]
34:	

exp$11:	; push float sum
35:		fld qword [bp + 30]
37:	

exp$12:	; push float term
38:		fld qword [bp + 22]
40:	

exp$13:	; £temporary526 = sum + term
41:		fadd
43:	

exp$14:	; pop float sum
44:		fstp qword [bp + 30]
46:	

exp$15:	; push float power
47:		fld qword [bp + 46]
49:	

exp$16:	; push float x
50:		fld qword [bp + 6]
52:	

exp$17:	; £temporary527 = power * x
53:		fmul
55:	

exp$18:	; pop float power
56:		fstp qword [bp + 46]
58:	

exp$19:	; push float faculty
59:		fld qword [bp + 38]
61:	

exp$20:	; push float i
62:		fld qword [bp + 14]
64:	

exp$21:	; £temporary528 = faculty * i
65:		fmul
67:	

exp$22:	; pop float faculty
68:		fstp qword [bp + 38]
70:	

exp$23:	; call header integral zero 0 stack zero 0
72:	

exp$24:	; push float term
73:		fld qword [bp + 22]
75:	

exp$25:	; parameter term, offset 6
76:		fstp qword [bp + 60]
78:	

exp$26:	; call function noellipse-noellipse fabs
79:		mov word [bp + 54], exp$27
80:		mov [bp + 56], bp
81:		add bp, 54
82:		jmp fabs
84:	

exp$27:	; post call
86:	

exp$28:	; £temporary529 = return_value
88:	

exp$29:	; push float 0.000000001
89:		fld qword [float8$0.000000001#]
91:	

exp$30:	; if £temporary529 >= 0.000000001 goto 8
92:		fcompp
93:		fstsw ax
94:		sahf
95:		jbe exp$8
97:	

exp$31:	; push float sum
98:		fld qword [bp + 30]
100:	

exp$32:	; return_value = sum
102:	

exp$33:	; return
103:		mov t359, [bp]
104:		mov di, [bp + 4]
105:		mov bp, [bp + 2]
106:		jmp t359
108:	

exp$34:	; function end exp
1:	

log:	; push float x
2:		fld qword [bp + 6]
4:	

log$1:	; push 0
5:		fldz
7:	

log$2:	; if x <= 0 goto 72
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jae log$72
13:	

log$3:	; n = 0
14:		mov word [bp + 14], 0
16:	

log$4:	; push float x
17:		fld qword [bp + 6]
19:	

log$5:	; push 1
20:		fld1
22:	

log$6:	; if x <= 1 goto 16
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae log$16
28:	

log$7:	; push float x
29:		fld qword [bp + 6]
31:	

log$8:	; push 1
32:		fld1
34:	

log$9:	; if x <= 1 goto 28
35:		fcompp
36:		fstsw ax
37:		sahf
38:		jae log$28
40:	

log$10:	; push float x
41:		fld qword [bp + 6]
43:	

log$11:	; push float 2.7182818284590452353602874
44:		fld qword [float8$2.7182818284590452353602874#]
46:	

log$12:	; £temporary535 = x / 2.7182818284590452353602874
47:		fdiv
49:	

log$13:	; pop float x
50:		fstp qword [bp + 6]
52:	

log$14:	; ++n
53:		inc word [bp + 14]
55:	

log$15:	; goto 7
56:		jmp log$7
58:	

log$16:	; push float x
59:		fld qword [bp + 6]
61:	

log$17:	; push float 0.3678794411714423215955237798
62:		fld qword [float8$0.3678794411714423215955237798#]
64:	

log$18:	; if x >= 0.3678794411714423215955237798 goto 28
65:		fcompp
66:		fstsw ax
67:		sahf
68:		jbe log$28
70:	

log$19:	; push float x
71:		fld qword [bp + 6]
73:	

log$20:	; push float 0.3678794411714423215955237798
74:		fld qword [float8$0.3678794411714423215955237798#]
76:	

log$21:	; if x >= 0.3678794411714423215955237798 goto 28
77:		fcompp
78:		fstsw ax
79:		sahf
80:		jbe log$28
82:	

log$22:	; push float x
83:		fld qword [bp + 6]
85:	

log$23:	; push float 2.7182818284590452353602874
86:		fld qword [float8$2.7182818284590452353602874#]
88:	

log$24:	; £temporary539 = x * 2.7182818284590452353602874
89:		fmul
91:	

log$25:	; pop float x
92:		fstp qword [bp + 6]
94:	

log$26:	; --n
95:		dec word [bp + 14]
97:	

log$27:	; goto 19
98:		jmp log$19
100:	

log$28:	; push 1
101:		fld1
103:	

log$29:	; pop float i
104:		fstp qword [bp + 16]
106:	

log$30:	; push 1
107:		fld1
109:	

log$31:	; pop float term
110:		fstp qword [bp + 24]
112:	

log$32:	; push 0
113:		fldz
115:	

log$33:	; pop float sum
116:		fstp qword [bp + 32]
118:	

log$34:	; push 1
119:		fld1
121:	

log$35:	; pop float sign
122:		fstp qword [bp + 40]
124:	

log$36:	; push float x
125:		fld qword [bp + 6]
127:	

log$37:	; push 1
128:		fld1
130:	

log$38:	; £temporary541 = x - 1
131:		fsub
133:	

log$39:	; top float x_minus_1
134:		fst qword [bp + 48]
136:	

log$40:	; pop float power
137:		fstp qword [bp + 56]
139:	

log$41:	; push float sign
140:		fld qword [bp + 40]
142:	

log$42:	; push float power
143:		fld qword [bp + 56]
145:	

log$43:	; £temporary542 = sign * power
146:		fmul
148:	

log$44:	; push float i
149:		fld qword [bp + 16]
151:	

log$45:	; £temporary543 = £temporary542 / i
152:		fdiv
154:	

log$46:	; pop float term
155:		fstp qword [bp + 24]
157:	

log$47:	; push float sum
158:		fld qword [bp + 32]
160:	

log$48:	; push float term
161:		fld qword [bp + 24]
163:	

log$49:	; £temporary544 = sum + term
164:		fadd
166:	

log$50:	; pop float sum
167:		fstp qword [bp + 32]
169:	

log$51:	; push float power
170:		fld qword [bp + 56]
172:	

log$52:	; push float x_minus_1
173:		fld qword [bp + 48]
175:	

log$53:	; £temporary545 = power * x_minus_1
176:		fmul
178:	

log$54:	; pop float power
179:		fstp qword [bp + 56]
181:	

log$55:	; push float sign
182:		fld qword [bp + 40]
184:	

log$56:	; push float -1.0
185:		fld qword [float8$minus1.0#]
187:	

log$57:	; £temporary546 = sign * -1.0
188:		fmul
190:	

log$58:	; pop float sign
191:		fstp qword [bp + 40]
193:	

log$59:	; call header integral zero 0 stack zero 0
195:	

log$60:	; push float term
196:		fld qword [bp + 24]
198:	

log$61:	; parameter term, offset 6
199:		fstp qword [bp + 70]
201:	

log$62:	; call function noellipse-noellipse fabs
202:		mov word [bp + 64], log$63
203:		mov [bp + 66], bp
204:		add bp, 64
205:		jmp fabs
207:	

log$63:	; post call
209:	

log$64:	; £temporary547 = return_value
211:	

log$65:	; push float 0.000000001
212:		fld qword [float8$0.000000001#]
214:	

log$66:	; if £temporary547 >= 0.000000001 goto 41
215:		fcompp
216:		fstsw ax
217:		sahf
218:		jbe log$41
220:	

log$67:	; push float sum
221:		fld qword [bp + 32]
223:	

log$68:	; £temporary549 = int_to_float n (Signed_Int -> Double)
224:		fild word [bp + 14]
226:	

log$69:	; £temporary550 = sum + £temporary549
227:		fadd
229:	

log$70:	; return_value = £temporary550
231:	

log$71:	; return
232:		mov t360, [bp]
233:		mov di, [bp + 4]
234:		mov bp, [bp + 2]
235:		jmp t360
237:	

log$72:	; errno = 6
238:		mov word [errno], 6
240:	

log$73:	; push 0
241:		fldz
243:	

log$74:	; return_value = 0
245:	

log$75:	; return
246:		mov t361, [bp]
247:		mov di, [bp + 4]
248:		mov bp, [bp + 2]
249:		jmp t361
251:	

log$76:	; function end log
1:	

log10:	; call header integral zero 0 stack zero 0
3:	

log10$1:	; push float x
4:		fld qword [bp + 6]
6:	

log10$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

log10$3:	; call function noellipse-noellipse log
10:		mov word [bp + 14], log10$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp log
15:	

log10$4:	; post call
17:	

log10$5:	; £temporary552 = return_value
19:	

log10$6:	; push float 2.3025850929940456840179914
20:		fld qword [float8$2.3025850929940456840179914#]
22:	

log10$7:	; £temporary553 = £temporary552 / 2.3025850929940456840179914
23:		fdiv
25:	

log10$8:	; return_value = £temporary553
27:	

log10$9:	; return
28:		mov t362, [bp]
29:		mov di, [bp + 4]
30:		mov bp, [bp + 2]
31:		jmp t362
33:	

log10$10:	; function end log10
1:	

pow:	; push float x
2:		fld qword [bp + 6]
4:	

pow$1:	; push 0
5:		fldz
7:	

pow$2:	; if x <= 0 goto 18
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jae pow$18
13:	

pow$3:	; call header integral zero 0 stack zero 0
15:	

pow$4:	; push float y
16:		fld qword [bp + 14]
18:	

pow$5:	; call header integral zero 0 stack no zero 1
19:		fstp qword [bp + 22]
21:	

pow$6:	; push float x
22:		fld qword [bp + 6]
24:	

pow$7:	; parameter x, offset 6
25:		fstp qword [bp + 36]
27:	

pow$8:	; call function noellipse-noellipse log
28:		mov word [bp + 30], pow$9
29:		mov [bp + 32], bp
30:		add bp, 30
31:		jmp log
33:	

pow$9:	; post call
34:		fstp qword [bp + 30]
35:		fld qword [bp + 22]
36:		fld qword [bp + 30]
38:	

pow$10:	; £temporary556 = return_value
40:	

pow$11:	; £temporary557 = y * £temporary556
41:		fmul
43:	

pow$12:	; parameter £temporary557, offset 6
44:		fstp qword [bp + 28]
46:	

pow$13:	; call function noellipse-noellipse exp
47:		mov word [bp + 22], pow$14
48:		mov [bp + 24], bp
49:		add bp, 22
50:		jmp exp
52:	

pow$14:	; post call
54:	

pow$15:	; £temporary558 = return_value
56:	

pow$16:	; return_value = £temporary558
58:	

pow$17:	; return
59:		mov t363, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp t363
64:	

pow$18:	; push float x
65:		fld qword [bp + 6]
67:	

pow$19:	; push 0
68:		fldz
70:	

pow$20:	; if x != 0 goto 27
71:		fcompp
72:		fstsw ax
73:		sahf
74:		jne pow$27
76:	

pow$21:	; push float y
77:		fld qword [bp + 14]
79:	

pow$22:	; push 0
80:		fldz
82:	

pow$23:	; if y <= 0 goto 27
83:		fcompp
84:		fstsw ax
85:		sahf
86:		jae pow$27
88:	

pow$24:	; push 0
89:		fldz
91:	

pow$25:	; return_value = 0
93:	

pow$26:	; return
94:		mov t364, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp t364
99:	

pow$27:	; push float x
100:		fld qword [bp + 6]
102:	

pow$28:	; push 0
103:		fldz
105:	

pow$29:	; if x >= 0 goto 81
106:		fcompp
107:		fstsw ax
108:		sahf
109:		jbe pow$81
111:	

pow$30:	; call header integral zero 0 stack zero 0
113:	

pow$31:	; push float y
114:		fld qword [bp + 14]
116:	

pow$32:	; parameter y, offset 6
117:		fstp qword [bp + 28]
119:	

pow$33:	; call function noellipse-noellipse floor
120:		mov word [bp + 22], pow$34
121:		mov [bp + 24], bp
122:		add bp, 22
123:		jmp floor
125:	

pow$34:	; post call
127:	

pow$35:	; £temporary563 = return_value
129:	

pow$36:	; call header integral zero 0 stack no zero 1
130:		fstp qword [bp + 22]
132:	

pow$37:	; push float y
133:		fld qword [bp + 14]
135:	

pow$38:	; parameter y, offset 6
136:		fstp qword [bp + 36]
138:	

pow$39:	; call function noellipse-noellipse ceil
139:		mov word [bp + 30], pow$40
140:		mov [bp + 32], bp
141:		add bp, 30
142:		jmp ceil
144:	

pow$40:	; post call
145:		fstp qword [bp + 30]
146:		fld qword [bp + 22]
147:		fld qword [bp + 30]
149:	

pow$41:	; £temporary564 = return_value
151:	

pow$42:	; if £temporary563 != £temporary564 goto 81
152:		fcompp
153:		fstsw ax
154:		sahf
155:		jne pow$81
157:	

pow$43:	; push float y
158:		fld qword [bp + 14]
160:	

pow$44:	; £temporary567 = float_to_int y (Double -> Signed_Long_Int)
161:		fistp dword [container4bytes#]
162:		mov t365, [container4bytes#]
164:	

pow$45:	; long_y = £temporary567
165:		mov [bp + 22], t365
167:	

pow$46:	; £temporary568 = long_y % 2
168:		mov a366, [bp + 22]
170:		xor edx, edx
171:		idiv dword [int4$2#]
177:	

pow$47:	; if £temporary568 != 0 goto 64
178:		cmp t368, 0
179:		jne pow$64
181:	

pow$48:	; call header integral zero 0 stack zero 0
183:	

pow$49:	; push float y
184:		fld qword [bp + 14]
186:	

pow$50:	; call header integral zero 0 stack no zero 1
187:		fstp qword [bp + 26]
189:	

pow$51:	; push float x
190:		fld qword [bp + 6]
192:	

pow$52:	; £temporary570 = -x
193:		fchs
195:	

pow$53:	; parameter £temporary570, offset 6
196:		fstp qword [bp + 40]
198:	

pow$54:	; call function noellipse-noellipse log
199:		mov word [bp + 34], pow$55
200:		mov [bp + 36], bp
201:		add bp, 34
202:		jmp log
204:	

pow$55:	; post call
205:		fstp qword [bp + 34]
206:		fld qword [bp + 26]
207:		fld qword [bp + 34]
209:	

pow$56:	; £temporary571 = return_value
211:	

pow$57:	; £temporary572 = y * £temporary571
212:		fmul
214:	

pow$58:	; parameter £temporary572, offset 6
215:		fstp qword [bp + 32]
217:	

pow$59:	; call function noellipse-noellipse exp
218:		mov word [bp + 26], pow$60
219:		mov [bp + 28], bp
220:		add bp, 26
221:		jmp exp
223:	

pow$60:	; post call
225:	

pow$61:	; £temporary573 = return_value
227:	

pow$62:	; return_value = £temporary573
229:	

pow$63:	; return
230:		mov t369, [bp]
231:		mov di, [bp + 4]
232:		mov bp, [bp + 2]
233:		jmp t369
235:	

pow$64:	; call header integral zero 0 stack zero 0
237:	

pow$65:	; push float y
238:		fld qword [bp + 14]
240:	

pow$66:	; call header integral zero 0 stack no zero 1
241:		fstp qword [bp + 26]
243:	

pow$67:	; push float x
244:		fld qword [bp + 6]
246:	

pow$68:	; £temporary574 = -x
247:		fchs
249:	

pow$69:	; parameter £temporary574, offset 6
250:		fstp qword [bp + 40]
252:	

pow$70:	; call function noellipse-noellipse log
253:		mov word [bp + 34], pow$71
254:		mov [bp + 36], bp
255:		add bp, 34
256:		jmp log
258:	

pow$71:	; post call
259:		fstp qword [bp + 34]
260:		fld qword [bp + 26]
261:		fld qword [bp + 34]
263:	

pow$72:	; £temporary575 = return_value
265:	

pow$73:	; £temporary576 = y * £temporary575
266:		fmul
268:	

pow$74:	; parameter £temporary576, offset 6
269:		fstp qword [bp + 32]
271:	

pow$75:	; call function noellipse-noellipse exp
272:		mov word [bp + 26], pow$76
273:		mov [bp + 28], bp
274:		add bp, 26
275:		jmp exp
277:	

pow$76:	; post call
279:	

pow$77:	; £temporary577 = return_value
281:	

pow$78:	; £temporary578 = -£temporary577
282:		fchs
284:	

pow$79:	; return_value = £temporary578
286:	

pow$80:	; return
287:		mov t370, [bp]
288:		mov di, [bp + 4]
289:		mov bp, [bp + 2]
290:		jmp t370
292:	

pow$81:	; errno = 6
293:		mov word [errno], 6
295:	

pow$82:	; push 0
296:		fldz
298:	

pow$83:	; return_value = 0
300:	

pow$84:	; return
301:		mov t371, [bp]
302:		mov di, [bp + 4]
303:		mov bp, [bp + 2]
304:		jmp t371
306:	

pow$85:	; function end pow
1:	

ldexp:	; push float x
2:		fld qword [bp + 6]
4:	

ldexp$1:	; call header integral zero 0 stack no zero 1
5:		fstp qword [bp + 16]
7:	

ldexp$2:	; push float 2
8:		fld qword [float8$2#]
10:	

ldexp$3:	; parameter 2, offset 6
11:		fstp qword [bp + 30]
13:	

ldexp$4:	; £temporary587 = int_to_float n (Signed_Int -> Double)
14:		fild word [bp + 14]
16:	

ldexp$5:	; parameter £temporary587, offset 14
17:		fstp qword [bp + 38]
19:	

ldexp$6:	; call function noellipse-noellipse pow
20:		mov word [bp + 24], ldexp$7
21:		mov [bp + 26], bp
22:		add bp, 24
23:		jmp pow
25:	

ldexp$7:	; post call
26:		fstp qword [bp + 24]
27:		fld qword [bp + 16]
28:		fld qword [bp + 24]
30:	

ldexp$8:	; £temporary588 = return_value
32:	

ldexp$9:	; £temporary589 = x * £temporary588
33:		fmul
35:	

ldexp$10:	; return_value = £temporary589
37:	

ldexp$11:	; return
38:		mov t372, [bp]
39:		mov di, [bp + 4]
40:		mov bp, [bp + 2]
41:		jmp t372
43:	

ldexp$12:	; function end ldexp
1:	

@24$log2:	; call header integral zero 0 stack zero 0
3:	

@24$log2$1:	; push float x
4:		fld qword [bp + 6]
6:	

@24$log2$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

@24$log2$3:	; call function noellipse-noellipse log
10:		mov word [bp + 14], @24$log2$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp log
15:	

@24$log2$4:	; post call
17:	

@24$log2$5:	; £temporary592 = return_value
19:	

@24$log2$6:	; push float 0.6931471805599453094172321
20:		fld qword [float8$0.6931471805599453094172321#]
22:	

@24$log2$7:	; £temporary593 = £temporary592 / 0.6931471805599453094172321
23:		fdiv
25:	

@24$log2$8:	; £temporary594 = float_to_int £temporary593 (Double -> Signed_Int)
26:		fistp word [container2bytes#]
27:		mov t373, [container2bytes#]
29:	

@24$log2$9:	; return_value = £temporary594
31:	

@24$log2$10:	; return
32:		mov t374, [bp]
33:		mov di, [bp + 4]
34:		mov bp, [bp + 2]
35:		jmp t374
37:	

@24$log2$11:	; function end log2
1:	

frexp:	; push float x
2:		fld qword [bp + 6]
4:	

frexp$1:	; push 0
5:		fldz
7:	

frexp$2:	; if x == 0 goto 32
8:		fcompp
9:		fstsw ax
10:		sahf
11:		je frexp$32
13:	

frexp$3:	; call header integral zero 0 stack zero 0
15:	

frexp$4:	; call header integral zero 0 stack zero 0
17:	

frexp$5:	; push float x
18:		fld qword [bp + 6]
20:	

frexp$6:	; parameter x, offset 6
21:		fstp qword [bp + 22]
23:	

frexp$7:	; call function noellipse-noellipse fabs
24:		mov word [bp + 16], frexp$8
25:		mov [bp + 18], bp
26:		add bp, 16
27:		jmp fabs
29:	

frexp$8:	; post call
31:	

frexp$9:	; £temporary597 = return_value
33:	

frexp$10:	; parameter £temporary597, offset 6
34:		fstp qword [bp + 22]
36:	

frexp$11:	; call function noellipse-noellipse log2
37:		mov word [bp + 16], frexp$12
38:		mov [bp + 18], bp
39:		add bp, 16
40:		jmp @24$log2
42:	

frexp$12:	; post call
44:	

frexp$13:	; £temporary598 = return_value
49:	

frexp$14:	; £temporary599 = £temporary598 + 1
50:		add t376, 1
52:	

frexp$15:	; £temporary600 = int_to_int £temporary599 (Signed_Int -> Signed_Int)
55:	

frexp$16:	; exponent = £temporary600
56:		mov [bp + 16], t376
58:	

frexp$17:	; if p == 0 goto 20
59:		cmp word [bp + 14], 0
60:		je frexp$20
62:	

frexp$18:	; £temporary602 -> p = *p
63:		mov a377, [bp + 14]
65:	

frexp$19:	; £temporary602 -> p = exponent
66:		mov a378, [bp + 16]
67:		mov [a377], a378
69:	

frexp$20:	; push float x
70:		fld qword [bp + 6]
72:	

frexp$21:	; call header integral zero 0 stack no zero 1
73:		fstp qword [bp + 18]
75:	

frexp$22:	; push float 2
76:		fld qword [float8$2#]
78:	

frexp$23:	; parameter 2, offset 6
79:		fstp qword [bp + 32]
81:	

frexp$24:	; £temporary603 = int_to_float exponent (Signed_Int -> Double)
82:		fild word [bp + 16]
84:	

frexp$25:	; parameter £temporary603, offset 14
85:		fstp qword [bp + 40]
87:	

frexp$26:	; call function noellipse-noellipse pow
88:		mov word [bp + 26], frexp$27
89:		mov [bp + 28], bp
90:		add bp, 26
91:		jmp pow
93:	

frexp$27:	; post call
94:		fstp qword [bp + 26]
95:		fld qword [bp + 18]
96:		fld qword [bp + 26]
98:	

frexp$28:	; £temporary604 = return_value
100:	

frexp$29:	; £temporary605 = x / £temporary604
101:		fdiv
103:	

frexp$30:	; return_value = £temporary605
105:	

frexp$31:	; return
106:		mov t379, [bp]
107:		mov di, [bp + 4]
108:		mov bp, [bp + 2]
109:		jmp t379
111:	

frexp$32:	; if p == 0 goto 35
112:		cmp word [bp + 14], 0
113:		je frexp$35
115:	

frexp$33:	; £temporary607 -> p = *p
116:		mov a380, [bp + 14]
118:	

frexp$34:	; £temporary607 -> p = 0
119:		mov word [a380], 0
121:	

frexp$35:	; push 0
122:		fldz
124:	

frexp$36:	; return_value = 0
126:	

frexp$37:	; return
127:		mov t381, [bp]
128:		mov di, [bp + 4]
129:		mov bp, [bp + 2]
130:		jmp t381
132:	

frexp$38:	; function end frexp
1:	

sqrt:	; push float x
2:		fld qword [bp + 6]
4:	

sqrt$1:	; push 0
5:		fldz
7:	

sqrt$2:	; if x < 0 goto 26
8:		fcompp
9:		fstsw ax
10:		sahf
11:		ja sqrt$26
13:	

sqrt$3:	; push 1
14:		fld1
16:	

sqrt$4:	; top float root_i_plus_1
17:		fst qword [bp + 22]
19:	

sqrt$5:	; top float root_i
20:		fst qword [bp + 14]
22:	

sqrt$6:	; push float x
23:		fld qword [bp + 6]
25:	

sqrt$7:	; push float root_i
26:		fld qword [bp + 14]
28:	

sqrt$8:	; £temporary613 = x / root_i
29:		fdiv
31:	

sqrt$9:	; £temporary614 = root_i + £temporary613
32:		fadd
34:	

sqrt$10:	; push float 2
35:		fld qword [float8$2#]
37:	

sqrt$11:	; £temporary615 = £temporary614 / 2
38:		fdiv
40:	

sqrt$12:	; pop float root_i_plus_1
41:		fstp qword [bp + 22]
43:	

sqrt$13:	; call header integral zero 0 stack zero 0
45:	

sqrt$14:	; push float root_i_plus_1
46:		fld qword [bp + 22]
48:	

sqrt$15:	; push float root_i
49:		fld qword [bp + 14]
51:	

sqrt$16:	; £temporary616 = root_i_plus_1 - root_i
52:		fsub
54:	

sqrt$17:	; parameter £temporary616, offset 6
55:		fstp qword [bp + 36]
57:	

sqrt$18:	; call function noellipse-noellipse fabs
58:		mov word [bp + 30], sqrt$19
59:		mov [bp + 32], bp
60:		add bp, 30
61:		jmp fabs
63:	

sqrt$19:	; post call
65:	

sqrt$20:	; £temporary617 = return_value
67:	

sqrt$21:	; push float 0.000000001
68:		fld qword [float8$0.000000001#]
70:	

sqrt$22:	; if £temporary617 >= 0.000000001 goto 5
71:		fcompp
72:		fstsw ax
73:		sahf
74:		jbe sqrt$5
76:	

sqrt$23:	; push float root_i_plus_1
77:		fld qword [bp + 22]
79:	

sqrt$24:	; return_value = root_i_plus_1
81:	

sqrt$25:	; return
82:		mov t382, [bp]
83:		mov di, [bp + 4]
84:		mov bp, [bp + 2]
85:		jmp t382
87:	

sqrt$26:	; errno = 6
88:		mov word [errno], 6
90:	

sqrt$27:	; push 0
91:		fldz
93:	

sqrt$28:	; return_value = 0
95:	

sqrt$29:	; return
96:		mov t383, [bp]
97:		mov di, [bp + 4]
98:		mov bp, [bp + 2]
99:		jmp t383
101:	

sqrt$30:	; function end sqrt
1:	

modf:	; call header integral zero 0 stack zero 0
3:	

modf$1:	; push float x
4:		fld qword [bp + 6]
6:	

modf$2:	; parameter x, offset 6
7:		fstp qword [bp + 22]
9:	

modf$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 16], modf$4
11:		mov [bp + 18], bp
12:		add bp, 16
13:		jmp fabs
15:	

modf$4:	; post call
17:	

modf$5:	; £temporary620 = return_value
19:	

modf$6:	; top float abs_x
20:		fst qword [bp + 16]
22:	

modf$7:	; £temporary621 = float_to_int abs_x (Double -> Signed_Long_Int)
23:		fistp dword [container4bytes#]
24:		mov t384, [container4bytes#]
26:	

modf$8:	; £temporary622 = int_to_float £temporary621 (Signed_Long_Int -> Double)
27:		mov [container4bytes#], t384
28:		fild dword [container4bytes#]
30:	

modf$9:	; pop float integral
31:		fstp qword [bp + 24]
33:	

modf$10:	; push float abs_x
34:		fld qword [bp + 16]
36:	

modf$11:	; push float integral
37:		fld qword [bp + 24]
39:	

modf$12:	; £temporary623 = abs_x - integral
40:		fsub
42:	

modf$13:	; pop float fractional
43:		fstp qword [bp + 32]
45:	

modf$14:	; if p == 0 goto 25
46:		cmp word [bp + 14], 0
47:		je modf$25
49:	

modf$15:	; £temporary625 -> p = *p
50:		mov a385, [bp + 14]
52:	

modf$16:	; push float x
53:		fld qword [bp + 6]
55:	

modf$17:	; push 0
56:		fldz
58:	

modf$18:	; if x <= 0 goto 22
59:		fcompp
60:		fstsw ax
61:		sahf
62:		jae modf$22
64:	

modf$19:	; push float fractional
65:		fld qword [bp + 32]
67:	

modf$20:	; decrease stack
69:	

modf$21:	; goto 24
70:		jmp modf$24
72:	

modf$22:	; push float fractional
73:		fld qword [bp + 32]
75:	

modf$23:	; £temporary627 = -fractional
76:		fchs
78:	

modf$24:	; pop float £temporary625 -> p
79:		fstp qword [a385]
81:	

modf$25:	; push float x
82:		fld qword [bp + 6]
84:	

modf$26:	; push 0
85:		fldz
87:	

modf$27:	; if x <= 0 goto 31
88:		fcompp
89:		fstsw ax
90:		sahf
91:		jae modf$31
93:	

modf$28:	; push float integral
94:		fld qword [bp + 24]
96:	

modf$29:	; decrease stack
98:	

modf$30:	; goto 33
99:		jmp modf$33
101:	

modf$31:	; push float integral
102:		fld qword [bp + 24]
104:	

modf$32:	; £temporary633 = -integral
105:		fchs
107:	

modf$33:	; return_value = £temporary637
109:	

modf$34:	; return
110:		mov t386, [bp]
111:		mov di, [bp + 4]
112:		mov bp, [bp + 2]
113:		jmp t386
115:	

modf$35:	; function end modf
1:	

fmod:	; push float y
2:		fld qword [bp + 14]
4:	

fmod$1:	; push 0
5:		fldz
7:	

fmod$2:	; if y == 0 goto 28
8:		fcompp
9:		fstsw ax
10:		sahf
11:		je fmod$28
13:	

fmod$3:	; push float x
14:		fld qword [bp + 6]
16:	

fmod$4:	; push float y
17:		fld qword [bp + 14]
19:	

fmod$5:	; £temporary640 = x / y
20:		fdiv
22:	

fmod$6:	; pop float quotient
23:		fstp qword [bp + 22]
25:	

fmod$7:	; call header integral zero 0 stack zero 0
27:	

fmod$8:	; push float quotient
28:		fld qword [bp + 22]
30:	

fmod$9:	; push float quotient
31:		fld qword [bp + 22]
33:	

fmod$10:	; £temporary641 = float_to_int quotient (Double -> Signed_Long_Int)
34:		fistp dword [container4bytes#]
35:		mov t387, [container4bytes#]
37:	

fmod$11:	; £temporary642 = int_to_float £temporary641 (Signed_Long_Int -> Double)
38:		mov [container4bytes#], t387
39:		fild dword [container4bytes#]
41:	

fmod$12:	; £temporary643 = quotient - £temporary642
42:		fsub
44:	

fmod$13:	; parameter £temporary643, offset 6
45:		fstp qword [bp + 36]
47:	

fmod$14:	; call function noellipse-noellipse fabs
48:		mov word [bp + 30], fmod$15
49:		mov [bp + 32], bp
50:		add bp, 30
51:		jmp fabs
53:	

fmod$15:	; post call
55:	

fmod$16:	; £temporary644 = return_value
57:	

fmod$17:	; pop float remainder
58:		fstp qword [bp + 30]
60:	

fmod$18:	; push float x
61:		fld qword [bp + 6]
63:	

fmod$19:	; push 0
64:		fldz
66:	

fmod$20:	; if x <= 0 goto 24
67:		fcompp
68:		fstsw ax
69:		sahf
70:		jae fmod$24
72:	

fmod$21:	; push float remainder
73:		fld qword [bp + 30]
75:	

fmod$22:	; decrease stack
77:	

fmod$23:	; goto 26
78:		jmp fmod$26
80:	

fmod$24:	; push float remainder
81:		fld qword [bp + 30]
83:	

fmod$25:	; £temporary646 = -remainder
84:		fchs
86:	

fmod$26:	; return_value = £temporary650
88:	

fmod$27:	; return
89:		mov t388, [bp]
90:		mov di, [bp + 4]
91:		mov bp, [bp + 2]
92:		jmp t388
94:	

fmod$28:	; errno = 6
95:		mov word [errno], 6
97:	

fmod$29:	; push 0
98:		fldz
100:	

fmod$30:	; return_value = 0
102:	

fmod$31:	; return
103:		mov t389, [bp]
104:		mov di, [bp + 4]
105:		mov bp, [bp + 2]
106:		jmp t389
108:	

fmod$32:	; function end fmod
1:	

sin:	; call header integral zero 0 stack zero 0
3:	

sin$1:	; push float x
4:		fld qword [bp + 6]
6:	

sin$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

sin$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 14], sin$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp fabs
15:	

sin$4:	; post call
17:	

sin$5:	; £temporary652 = return_value
19:	

sin$6:	; push float 6.2831853071795864769252866
20:		fld qword [float8$6.2831853071795864769252866#]
22:	

sin$7:	; if £temporary652 <= 6.2831853071795864769252866 goto 17
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae sin$17
28:	

sin$8:	; call header integral zero 0 stack zero 0
30:	

sin$9:	; push float x
31:		fld qword [bp + 6]
33:	

sin$10:	; parameter x, offset 6
34:		fstp qword [bp + 20]
36:	

sin$11:	; push float 6.2831853071795864769252866
37:		fld qword [float8$6.2831853071795864769252866#]
39:	

sin$12:	; parameter 6.2831853071795864769252866, offset 14
40:		fstp qword [bp + 28]
42:	

sin$13:	; call function noellipse-noellipse fmod
43:		mov word [bp + 14], sin$14
44:		mov [bp + 16], bp
45:		add bp, 14
46:		jmp fmod
48:	

sin$14:	; post call
50:	

sin$15:	; £temporary654 = return_value
52:	

sin$16:	; pop float x
53:		fstp qword [bp + 6]
55:	

sin$17:	; push 0
56:		fldz
58:	

sin$18:	; pop float i
59:		fstp qword [bp + 14]
61:	

sin$19:	; push 0
62:		fldz
64:	

sin$20:	; pop float sum
65:		fstp qword [bp + 30]
67:	

sin$21:	; push 1
68:		fld1
70:	

sin$22:	; pop float sign
71:		fstp qword [bp + 38]
73:	

sin$23:	; push float x
74:		fld qword [bp + 6]
76:	

sin$24:	; pop float power
77:		fstp qword [bp + 46]
79:	

sin$25:	; push 1
80:		fld1
82:	

sin$26:	; pop float faculty
83:		fstp qword [bp + 54]
85:	

sin$27:	; push float sign
86:		fld qword [bp + 38]
88:	

sin$28:	; push float power
89:		fld qword [bp + 46]
91:	

sin$29:	; £temporary655 = sign * power
92:		fmul
94:	

sin$30:	; push float faculty
95:		fld qword [bp + 54]
97:	

sin$31:	; £temporary656 = £temporary655 / faculty
98:		fdiv
100:	

sin$32:	; pop float term
101:		fstp qword [bp + 22]
103:	

sin$33:	; push float sum
104:		fld qword [bp + 30]
106:	

sin$34:	; push float term
107:		fld qword [bp + 22]
109:	

sin$35:	; £temporary657 = sum + term
110:		fadd
112:	

sin$36:	; pop float sum
113:		fstp qword [bp + 30]
115:	

sin$37:	; push float sign
116:		fld qword [bp + 38]
118:	

sin$38:	; push float -1
119:		fld qword [float8$minus1#]
121:	

sin$39:	; £temporary658 = sign * -1
122:		fmul
124:	

sin$40:	; pop float sign
125:		fstp qword [bp + 38]
127:	

sin$41:	; push float power
128:		fld qword [bp + 46]
130:	

sin$42:	; push float x
131:		fld qword [bp + 6]
133:	

sin$43:	; push float x
134:		fld qword [bp + 6]
136:	

sin$44:	; £temporary659 = x * x
137:		fmul
139:	

sin$45:	; £temporary660 = power * £temporary659
140:		fmul
142:	

sin$46:	; pop float power
143:		fstp qword [bp + 46]
145:	

sin$47:	; push float faculty
146:		fld qword [bp + 54]
148:	

sin$48:	; push float i
149:		fld qword [bp + 14]
151:	

sin$49:	; push 1
152:		fld1
154:	

sin$50:	; i = i + 1
155:		fadd
157:	

sin$51:	; top float i
158:		fst qword [bp + 14]
160:	

sin$52:	; push float i
161:		fld qword [bp + 14]
163:	

sin$53:	; push 1
164:		fld1
166:	

sin$54:	; i = i + 1
167:		fadd
169:	

sin$55:	; top float i
170:		fst qword [bp + 14]
172:	

sin$56:	; £temporary663 = £temporary661 * £temporary662
173:		fmul
175:	

sin$57:	; £temporary664 = faculty * £temporary663
176:		fmul
178:	

sin$58:	; pop float faculty
179:		fstp qword [bp + 54]
181:	

sin$59:	; call header integral zero 0 stack zero 0
183:	

sin$60:	; push float term
184:		fld qword [bp + 22]
186:	

sin$61:	; parameter term, offset 6
187:		fstp qword [bp + 68]
189:	

sin$62:	; call function noellipse-noellipse fabs
190:		mov word [bp + 62], sin$63
191:		mov [bp + 64], bp
192:		add bp, 62
193:		jmp fabs
195:	

sin$63:	; post call
197:	

sin$64:	; £temporary665 = return_value
199:	

sin$65:	; push float 0.000000001
200:		fld qword [float8$0.000000001#]
202:	

sin$66:	; if £temporary665 >= 0.000000001 goto 27
203:		fcompp
204:		fstsw ax
205:		sahf
206:		jbe sin$27
208:	

sin$67:	; push float sum
209:		fld qword [bp + 30]
211:	

sin$68:	; return_value = sum
213:	

sin$69:	; return
214:		mov t390, [bp]
215:		mov di, [bp + 4]
216:		mov bp, [bp + 2]
217:		jmp t390
219:	

sin$70:	; function end sin
1:	

cos:	; call header integral zero 0 stack zero 0
3:	

cos$1:	; push float x
4:		fld qword [bp + 6]
6:	

cos$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

cos$3:	; call function noellipse-noellipse fabs
10:		mov word [bp + 14], cos$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp fabs
15:	

cos$4:	; post call
17:	

cos$5:	; £temporary671 = return_value
19:	

cos$6:	; push float 6.2831853071795864769252866
20:		fld qword [float8$6.2831853071795864769252866#]
22:	

cos$7:	; if £temporary671 <= 6.2831853071795864769252866 goto 17
23:		fcompp
24:		fstsw ax
25:		sahf
26:		jae cos$17
28:	

cos$8:	; call header integral zero 0 stack zero 0
30:	

cos$9:	; push float x
31:		fld qword [bp + 6]
33:	

cos$10:	; parameter x, offset 6
34:		fstp qword [bp + 20]
36:	

cos$11:	; push float 6.2831853071795864769252866
37:		fld qword [float8$6.2831853071795864769252866#]
39:	

cos$12:	; parameter 6.2831853071795864769252866, offset 14
40:		fstp qword [bp + 28]
42:	

cos$13:	; call function noellipse-noellipse fmod
43:		mov word [bp + 14], cos$14
44:		mov [bp + 16], bp
45:		add bp, 14
46:		jmp fmod
48:	

cos$14:	; post call
50:	

cos$15:	; £temporary673 = return_value
52:	

cos$16:	; pop float x
53:		fstp qword [bp + 6]
55:	

cos$17:	; push 0
56:		fldz
58:	

cos$18:	; pop float i
59:		fstp qword [bp + 14]
61:	

cos$19:	; push 0
62:		fldz
64:	

cos$20:	; pop float sum
65:		fstp qword [bp + 30]
67:	

cos$21:	; push 1
68:		fld1
70:	

cos$22:	; pop float sign
71:		fstp qword [bp + 38]
73:	

cos$23:	; push 1
74:		fld1
76:	

cos$24:	; pop float power
77:		fstp qword [bp + 46]
79:	

cos$25:	; push 1
80:		fld1
82:	

cos$26:	; pop float faculty
83:		fstp qword [bp + 54]
85:	

cos$27:	; push float sign
86:		fld qword [bp + 38]
88:	

cos$28:	; push float power
89:		fld qword [bp + 46]
91:	

cos$29:	; £temporary674 = sign * power
92:		fmul
94:	

cos$30:	; push float faculty
95:		fld qword [bp + 54]
97:	

cos$31:	; £temporary675 = £temporary674 / faculty
98:		fdiv
100:	

cos$32:	; pop float term
101:		fstp qword [bp + 22]
103:	

cos$33:	; push float sum
104:		fld qword [bp + 30]
106:	

cos$34:	; push float term
107:		fld qword [bp + 22]
109:	

cos$35:	; £temporary676 = sum + term
110:		fadd
112:	

cos$36:	; pop float sum
113:		fstp qword [bp + 30]
115:	

cos$37:	; push float sign
116:		fld qword [bp + 38]
118:	

cos$38:	; push float -1
119:		fld qword [float8$minus1#]
121:	

cos$39:	; £temporary677 = sign * -1
122:		fmul
124:	

cos$40:	; pop float sign
125:		fstp qword [bp + 38]
127:	

cos$41:	; push float power
128:		fld qword [bp + 46]
130:	

cos$42:	; push float x
131:		fld qword [bp + 6]
133:	

cos$43:	; push float x
134:		fld qword [bp + 6]
136:	

cos$44:	; £temporary678 = x * x
137:		fmul
139:	

cos$45:	; £temporary679 = power * £temporary678
140:		fmul
142:	

cos$46:	; pop float power
143:		fstp qword [bp + 46]
145:	

cos$47:	; push float faculty
146:		fld qword [bp + 54]
148:	

cos$48:	; push float i
149:		fld qword [bp + 14]
151:	

cos$49:	; push 1
152:		fld1
154:	

cos$50:	; i = i + 1
155:		fadd
157:	

cos$51:	; top float i
158:		fst qword [bp + 14]
160:	

cos$52:	; push float i
161:		fld qword [bp + 14]
163:	

cos$53:	; push 1
164:		fld1
166:	

cos$54:	; i = i + 1
167:		fadd
169:	

cos$55:	; top float i
170:		fst qword [bp + 14]
172:	

cos$56:	; £temporary682 = £temporary680 * £temporary681
173:		fmul
175:	

cos$57:	; £temporary683 = faculty * £temporary682
176:		fmul
178:	

cos$58:	; pop float faculty
179:		fstp qword [bp + 54]
181:	

cos$59:	; call header integral zero 0 stack zero 0
183:	

cos$60:	; push float term
184:		fld qword [bp + 22]
186:	

cos$61:	; parameter term, offset 6
187:		fstp qword [bp + 68]
189:	

cos$62:	; call function noellipse-noellipse fabs
190:		mov word [bp + 62], cos$63
191:		mov [bp + 64], bp
192:		add bp, 62
193:		jmp fabs
195:	

cos$63:	; post call
197:	

cos$64:	; £temporary684 = return_value
199:	

cos$65:	; push float 0.000000001
200:		fld qword [float8$0.000000001#]
202:	

cos$66:	; if £temporary684 >= 0.000000001 goto 27
203:		fcompp
204:		fstsw ax
205:		sahf
206:		jbe cos$27
208:	

cos$67:	; push float sum
209:		fld qword [bp + 30]
211:	

cos$68:	; return_value = sum
213:	

cos$69:	; return
214:		mov t391, [bp]
215:		mov di, [bp + 4]
216:		mov bp, [bp + 2]
217:		jmp t391
219:	

cos$70:	; function end cos
1:	

tan:	; call header integral zero 0 stack zero 0
3:	

tan$1:	; push float x
4:		fld qword [bp + 6]
6:	

tan$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

tan$3:	; call function noellipse-noellipse cos
10:		mov word [bp + 14], tan$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp cos
15:	

tan$4:	; post call
17:	

tan$5:	; £temporary690 = return_value
19:	

tan$6:	; top float cos_x
20:		fst qword [bp + 14]
22:	

tan$7:	; push 0
23:		fldz
25:	

tan$8:	; if cos_x == 0 goto 19
26:		fcompp
27:		fstsw ax
28:		sahf
29:		je tan$19
31:	

tan$9:	; call header integral zero 0 stack zero 0
33:	

tan$10:	; push float x
34:		fld qword [bp + 6]
36:	

tan$11:	; parameter x, offset 6
37:		fstp qword [bp + 28]
39:	

tan$12:	; call function noellipse-noellipse sin
40:		mov word [bp + 22], tan$13
41:		mov [bp + 24], bp
42:		add bp, 22
43:		jmp sin
45:	

tan$13:	; post call
47:	

tan$14:	; £temporary692 = return_value
49:	

tan$15:	; push float cos_x
50:		fld qword [bp + 14]
52:	

tan$16:	; £temporary693 = £temporary692 / cos_x
53:		fdiv
55:	

tan$17:	; return_value = £temporary693
57:	

tan$18:	; return
58:		mov t392, [bp]
59:		mov di, [bp + 4]
60:		mov bp, [bp + 2]
61:		jmp t392
63:	

tan$19:	; errno = 6
64:		mov word [errno], 6
66:	

tan$20:	; push 0
67:		fldz
69:	

tan$21:	; return_value = 0
71:	

tan$22:	; return
72:		mov t393, [bp]
73:		mov di, [bp + 4]
74:		mov bp, [bp + 2]
75:		jmp t393
77:	

tan$23:	; function end tan
1:	

asin:	; push float x
2:		fld qword [bp + 6]
4:	

asin$1:	; push 1
5:		fld1
7:	

asin$2:	; if x != 1 goto 6
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jne asin$6
13:	

asin$3:	; push float 1.57079632679489661923132165
14:		fld qword [float8$1.57079632679489661923132165#]
16:	

asin$4:	; return_value = 1.57079632679489661923132165
18:	

asin$5:	; return
19:		mov t394, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp t394
24:	

asin$6:	; push float x
25:		fld qword [bp + 6]
27:	

asin$7:	; push float -1
28:		fld qword [float8$minus1#]
30:	

asin$8:	; if x != -1 goto 12
31:		fcompp
32:		fstsw ax
33:		sahf
34:		jne asin$12
36:	

asin$9:	; push float -1.57079632679489661923132165
37:		fld qword [float8$minus1.57079632679489661923132165#]
39:	

asin$10:	; return_value = -1.57079632679489661923132165
41:	

asin$11:	; return
42:		mov t395, [bp]
43:		mov di, [bp + 4]
44:		mov bp, [bp + 2]
45:		jmp t395
47:	

asin$12:	; call header integral zero 0 stack zero 0
49:	

asin$13:	; push float x
50:		fld qword [bp + 6]
52:	

asin$14:	; parameter x, offset 6
53:		fstp qword [bp + 20]
55:	

asin$15:	; call function noellipse-noellipse fabs
56:		mov word [bp + 14], asin$16
57:		mov [bp + 16], bp
58:		add bp, 14
59:		jmp fabs
61:	

asin$16:	; post call
63:	

asin$17:	; £temporary698 = return_value
65:	

asin$18:	; push 1
66:		fld1
68:	

asin$19:	; if £temporary698 >= 1 goto 39
69:		fcompp
70:		fstsw ax
71:		sahf
72:		jbe asin$39
74:	

asin$20:	; call header integral zero 0 stack zero 0
76:	

asin$21:	; push float x
77:		fld qword [bp + 6]
79:	

asin$22:	; call header integral zero 0 stack no zero 1
80:		fstp qword [bp + 14]
82:	

asin$23:	; push 1
83:		fld1
85:	

asin$24:	; push float x
86:		fld qword [bp + 6]
88:	

asin$25:	; push float x
89:		fld qword [bp + 6]
91:	

asin$26:	; £temporary700 = x * x
92:		fmul
94:	

asin$27:	; £temporary701 = 1 - £temporary700
95:		fsub
97:	

asin$28:	; parameter £temporary701, offset 6
98:		fstp qword [bp + 28]
100:	

asin$29:	; call function noellipse-noellipse sqrt
101:		mov word [bp + 22], asin$30
102:		mov [bp + 24], bp
103:		add bp, 22
104:		jmp sqrt
106:	

asin$30:	; post call
107:		fstp qword [bp + 22]
108:		fld qword [bp + 14]
109:		fld qword [bp + 22]
111:	

asin$31:	; £temporary702 = return_value
113:	

asin$32:	; £temporary703 = x / £temporary702
114:		fdiv
116:	

asin$33:	; parameter £temporary703, offset 6
117:		fstp qword [bp + 20]
119:	

asin$34:	; call function noellipse-noellipse atan
120:		mov word [bp + 14], asin$35
121:		mov [bp + 16], bp
122:		add bp, 14
123:		jmp atan
125:	

asin$35:	; post call
127:	

asin$36:	; £temporary704 = return_value
129:	

asin$37:	; return_value = £temporary704
131:	

asin$38:	; return
132:		mov t396, [bp]
133:		mov di, [bp + 4]
134:		mov bp, [bp + 2]
135:		jmp t396
137:	

asin$39:	; errno = 6
138:		mov word [errno], 6
140:	

asin$40:	; push 0
141:		fldz
143:	

asin$41:	; return_value = 0
145:	

asin$42:	; return
146:		mov t397, [bp]
147:		mov di, [bp + 4]
148:		mov bp, [bp + 2]
149:		jmp t397
151:	

asin$43:	; function end asin
1:	

acos:	; push float x
2:		fld qword [bp + 6]
4:	

acos$1:	; push 0
5:		fldz
7:	

acos$2:	; if x != 0 goto 6
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jne acos$6
13:	

acos$3:	; push float 1.57079632679489661923132165
14:		fld qword [float8$1.57079632679489661923132165#]
16:	

acos$4:	; return_value = 1.57079632679489661923132165
18:	

acos$5:	; return
19:		mov t398, [bp]
20:		mov di, [bp + 4]
21:		mov bp, [bp + 2]
22:		jmp t398
24:	

acos$6:	; call header integral zero 0 stack zero 0
26:	

acos$7:	; push float x
27:		fld qword [bp + 6]
29:	

acos$8:	; parameter x, offset 6
30:		fstp qword [bp + 20]
32:	

acos$9:	; call function noellipse-noellipse fabs
33:		mov word [bp + 14], acos$10
34:		mov [bp + 16], bp
35:		add bp, 14
36:		jmp fabs
38:	

acos$10:	; post call
40:	

acos$11:	; £temporary709 = return_value
42:	

acos$12:	; push 1
43:		fld1
45:	

acos$13:	; if £temporary709 >= 1 goto 33
46:		fcompp
47:		fstsw ax
48:		sahf
49:		jbe acos$33
51:	

acos$14:	; call header integral zero 0 stack zero 0
53:	

acos$15:	; push float x
54:		fld qword [bp + 6]
56:	

acos$16:	; call header integral zero 0 stack no zero 1
57:		fstp qword [bp + 14]
59:	

acos$17:	; push 1
60:		fld1
62:	

acos$18:	; push float x
63:		fld qword [bp + 6]
65:	

acos$19:	; push float x
66:		fld qword [bp + 6]
68:	

acos$20:	; £temporary711 = x * x
69:		fmul
71:	

acos$21:	; £temporary712 = 1 - £temporary711
72:		fsub
74:	

acos$22:	; parameter £temporary712, offset 6
75:		fstp qword [bp + 28]
77:	

acos$23:	; call function noellipse-noellipse sqrt
78:		mov word [bp + 22], acos$24
79:		mov [bp + 24], bp
80:		add bp, 22
81:		jmp sqrt
83:	

acos$24:	; post call
84:		fstp qword [bp + 22]
85:		fld qword [bp + 14]
86:		fld qword [bp + 22]
88:	

acos$25:	; £temporary713 = return_value
90:	

acos$26:	; £temporary714 = x / £temporary713
91:		fdiv
93:	

acos$27:	; parameter £temporary714, offset 6
94:		fstp qword [bp + 20]
96:	

acos$28:	; call function noellipse-noellipse atan
97:		mov word [bp + 14], acos$29
98:		mov [bp + 16], bp
99:		add bp, 14
100:		jmp atan
102:	

acos$29:	; post call
104:	

acos$30:	; £temporary715 = return_value
106:	

acos$31:	; return_value = £temporary715
108:	

acos$32:	; return
109:		mov t399, [bp]
110:		mov di, [bp + 4]
111:		mov bp, [bp + 2]
112:		jmp t399
114:	

acos$33:	; errno = 6
115:		mov word [errno], 6
117:	

acos$34:	; push 0
118:		fldz
120:	

acos$35:	; return_value = 0
122:	

acos$36:	; return
123:		mov t400, [bp]
124:		mov di, [bp + 4]
125:		mov bp, [bp + 2]
126:		jmp t400
128:	

acos$37:	; function end acos
1:	

atan:	; push float x
2:		fld qword [bp + 6]
4:	

atan$1:	; push 0
5:		fldz
7:	

atan$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe atan$13
13:	

atan$3:	; call header integral zero 0 stack zero 0
15:	

atan$4:	; push float x
16:		fld qword [bp + 6]
18:	

atan$5:	; £temporary720 = -x
19:		fchs
21:	

atan$6:	; parameter £temporary720, offset 6
22:		fstp qword [bp + 20]
24:	

atan$7:	; call function noellipse-noellipse atan
25:		mov word [bp + 14], atan$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp atan
30:	

atan$8:	; post call
32:	

atan$9:	; £temporary721 = return_value
34:	

atan$10:	; £temporary722 = -£temporary721
35:		fchs
37:	

atan$11:	; return_value = £temporary722
39:	

atan$12:	; return
40:		mov t401, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t401
45:	

atan$13:	; push float x
46:		fld qword [bp + 6]
48:	

atan$14:	; push 1
49:		fld1
51:	

atan$15:	; if x <= 1 goto 28
52:		fcompp
53:		fstsw ax
54:		sahf
55:		jae atan$28
57:	

atan$16:	; push float 1.57079632679489661923132165
58:		fld qword [float8$1.57079632679489661923132165#]
60:	

atan$17:	; call header integral zero 0 stack no zero 1
61:		fstp qword [bp + 14]
63:	

atan$18:	; push 1
64:		fld1
66:	

atan$19:	; push float x
67:		fld qword [bp + 6]
69:	

atan$20:	; £temporary724 = 1 / x
70:		fdiv
72:	

atan$21:	; parameter £temporary724, offset 6
73:		fstp qword [bp + 28]
75:	

atan$22:	; call function noellipse-noellipse atan
76:		mov word [bp + 22], atan$23
77:		mov [bp + 24], bp
78:		add bp, 22
79:		jmp atan
81:	

atan$23:	; post call
82:		fstp qword [bp + 22]
83:		fld qword [bp + 14]
84:		fld qword [bp + 22]
86:	

atan$24:	; £temporary725 = return_value
88:	

atan$25:	; £temporary726 = 1.57079632679489661923132165 - £temporary725
89:		fsub
91:	

atan$26:	; return_value = £temporary726
93:	

atan$27:	; return
94:		mov t402, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp t402
99:	

atan$28:	; push float x
100:		fld qword [bp + 6]
102:	

atan$29:	; push float 0.5
103:		fld qword [float8$0.5#]
105:	

atan$30:	; if x <= 0.5 goto 54
106:		fcompp
107:		fstsw ax
108:		sahf
109:		jae atan$54
111:	

atan$31:	; push float 2
112:		fld qword [float8$2#]
114:	

atan$32:	; call header integral zero 0 stack no zero 1
115:		fstp qword [bp + 14]
117:	

atan$33:	; push float x
118:		fld qword [bp + 6]
120:	

atan$34:	; push 1
121:		fld1
123:	

atan$35:	; call header integral zero 0 stack no zero 3
124:		fstp qword [bp + 14]
125:		fstp qword [bp + 22]
126:		fstp qword [bp + 30]
128:	

atan$36:	; push 1
129:		fld1
131:	

atan$37:	; push float x
132:		fld qword [bp + 6]
134:	

atan$38:	; push float x
135:		fld qword [bp + 6]
137:	

atan$39:	; £temporary728 = x * x
138:		fmul
140:	

atan$40:	; £temporary729 = 1 + £temporary728
141:		fadd
143:	

atan$41:	; parameter £temporary729, offset 6
144:		fstp qword [bp + 52]
146:	

atan$42:	; call function noellipse-noellipse sqrt
147:		mov word [bp + 46], atan$43
148:		mov [bp + 48], bp
149:		add bp, 46
150:		jmp sqrt
152:	

atan$43:	; post call
153:		fstp qword [bp + 38]
154:		fld qword [bp + 30]
155:		fld qword [bp + 22]
156:		fld qword [bp + 14]
157:		fld qword [bp + 38]
159:	

atan$44:	; £temporary730 = return_value
161:	

atan$45:	; £temporary731 = 1 + £temporary730
162:		fadd
164:	

atan$46:	; £temporary732 = x / £temporary731
165:		fdiv
167:	

atan$47:	; parameter £temporary732, offset 6
168:		fstp qword [bp + 28]
170:	

atan$48:	; call function noellipse-noellipse atan
171:		mov word [bp + 22], atan$49
172:		mov [bp + 24], bp
173:		add bp, 22
174:		jmp atan
176:	

atan$49:	; post call
177:		fstp qword [bp + 22]
178:		fld qword [bp + 14]
179:		fld qword [bp + 22]
181:	

atan$50:	; £temporary733 = return_value
183:	

atan$51:	; £temporary734 = 2 * £temporary733
184:		fmul
186:	

atan$52:	; return_value = £temporary734
188:	

atan$53:	; return
189:		mov t403, [bp]
190:		mov di, [bp + 4]
191:		mov bp, [bp + 2]
192:		jmp t403
194:	

atan$54:	; push 0
195:		fldz
197:	

atan$55:	; pop float sum
198:		fstp qword [bp + 22]
200:	

atan$56:	; push 1
201:		fld1
203:	

atan$57:	; pop float sign
204:		fstp qword [bp + 30]
206:	

atan$58:	; push 1
207:		fld1
209:	

atan$59:	; pop float denominator
210:		fstp qword [bp + 38]
212:	

atan$60:	; push float x
213:		fld qword [bp + 6]
215:	

atan$61:	; pop float product
216:		fstp qword [bp + 46]
218:	

atan$62:	; push float sign
219:		fld qword [bp + 30]
221:	

atan$63:	; push float product
222:		fld qword [bp + 46]
224:	

atan$64:	; £temporary735 = sign * product
225:		fmul
227:	

atan$65:	; push float denominator
228:		fld qword [bp + 38]
230:	

atan$66:	; £temporary736 = £temporary735 / denominator
231:		fdiv
233:	

atan$67:	; pop float term
234:		fstp qword [bp + 14]
236:	

atan$68:	; push float sum
237:		fld qword [bp + 22]
239:	

atan$69:	; push float term
240:		fld qword [bp + 14]
242:	

atan$70:	; £temporary737 = sum + term
243:		fadd
245:	

atan$71:	; pop float sum
246:		fstp qword [bp + 22]
248:	

atan$72:	; push float sign
249:		fld qword [bp + 30]
251:	

atan$73:	; £temporary738 = -sign
252:		fchs
254:	

atan$74:	; pop float sign
255:		fstp qword [bp + 30]
257:	

atan$75:	; push float product
258:		fld qword [bp + 46]
260:	

atan$76:	; push float x
261:		fld qword [bp + 6]
263:	

atan$77:	; push float x
264:		fld qword [bp + 6]
266:	

atan$78:	; £temporary739 = x * x
267:		fmul
269:	

atan$79:	; £temporary740 = product * £temporary739
270:		fmul
272:	

atan$80:	; pop float product
273:		fstp qword [bp + 46]
275:	

atan$81:	; push float denominator
276:		fld qword [bp + 38]
278:	

atan$82:	; push float 2
279:		fld qword [float8$2#]
281:	

atan$83:	; £temporary741 = denominator + 2
282:		fadd
284:	

atan$84:	; pop float denominator
285:		fstp qword [bp + 38]
287:	

atan$85:	; call header integral zero 0 stack zero 0
289:	

atan$86:	; push float term
290:		fld qword [bp + 14]
292:	

atan$87:	; parameter term, offset 6
293:		fstp qword [bp + 60]
295:	

atan$88:	; call function noellipse-noellipse fabs
296:		mov word [bp + 54], atan$89
297:		mov [bp + 56], bp
298:		add bp, 54
299:		jmp fabs
301:	

atan$89:	; post call
303:	

atan$90:	; £temporary742 = return_value
305:	

atan$91:	; push float 0.000000001
306:		fld qword [float8$0.000000001#]
308:	

atan$92:	; if £temporary742 >= 0.000000001 goto 62
309:		fcompp
310:		fstsw ax
311:		sahf
312:		jbe atan$62
314:	

atan$93:	; push float sum
315:		fld qword [bp + 22]
317:	

atan$94:	; return_value = sum
319:	

atan$95:	; return
320:		mov t404, [bp]
321:		mov di, [bp + 4]
322:		mov bp, [bp + 2]
323:		jmp t404
325:	

atan$96:	; function end atan
1:	

atan2:	; push float y
2:		fld qword [bp + 14]
4:	

atan2$1:	; push 0
5:		fldz
7:	

atan2$2:	; if y == 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		je atan2$13
13:	

atan2$3:	; call header integral zero 0 stack zero 0
15:	

atan2$4:	; push float x
16:		fld qword [bp + 6]
18:	

atan2$5:	; push float y
19:		fld qword [bp + 14]
21:	

atan2$6:	; £temporary750 = x / y
22:		fdiv
24:	

atan2$7:	; parameter £temporary750, offset 6
25:		fstp qword [bp + 28]
27:	

atan2$8:	; call function noellipse-noellipse atan
28:		mov word [bp + 22], atan2$9
29:		mov [bp + 24], bp
30:		add bp, 22
31:		jmp atan
33:	

atan2$9:	; post call
35:	

atan2$10:	; £temporary751 = return_value
37:	

atan2$11:	; return_value = £temporary751
39:	

atan2$12:	; return
40:		mov t405, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t405
45:	

atan2$13:	; errno = 6
46:		mov word [errno], 6
48:	

atan2$14:	; push 0
49:		fldz
51:	

atan2$15:	; return_value = 0
53:	

atan2$16:	; return
54:		mov t406, [bp]
55:		mov di, [bp + 4]
56:		mov bp, [bp + 2]
57:		jmp t406
59:	

atan2$17:	; function end atan2
1:	

sinh:	; call header integral zero 0 stack zero 0
3:	

sinh$1:	; push float x
4:		fld qword [bp + 6]
6:	

sinh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

sinh$3:	; call function noellipse-noellipse exp
10:		mov word [bp + 14], sinh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp exp
15:	

sinh$4:	; post call
17:	

sinh$5:	; £temporary753 = return_value
19:	

sinh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

sinh$7:	; push float x
23:		fld qword [bp + 6]
25:	

sinh$8:	; £temporary754 = -x
26:		fchs
28:	

sinh$9:	; parameter £temporary754, offset 6
29:		fstp qword [bp + 28]
31:	

sinh$10:	; call function noellipse-noellipse exp
32:		mov word [bp + 22], sinh$11
33:		mov [bp + 24], bp
34:		add bp, 22
35:		jmp exp
37:	

sinh$11:	; post call
38:		fstp qword [bp + 22]
39:		fld qword [bp + 14]
40:		fld qword [bp + 22]
42:	

sinh$12:	; £temporary755 = return_value
44:	

sinh$13:	; £temporary756 = £temporary753 - £temporary755
45:		fsub
47:	

sinh$14:	; push float 2
48:		fld qword [float8$2#]
50:	

sinh$15:	; £temporary757 = £temporary756 / 2
51:		fdiv
53:	

sinh$16:	; return_value = £temporary757
55:	

sinh$17:	; return
56:		mov t407, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp t407
61:	

sinh$18:	; function end sinh
1:	

cosh:	; call header integral zero 0 stack zero 0
3:	

cosh$1:	; push float x
4:		fld qword [bp + 6]
6:	

cosh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

cosh$3:	; call function noellipse-noellipse exp
10:		mov word [bp + 14], cosh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp exp
15:	

cosh$4:	; post call
17:	

cosh$5:	; £temporary760 = return_value
19:	

cosh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

cosh$7:	; push float x
23:		fld qword [bp + 6]
25:	

cosh$8:	; £temporary761 = -x
26:		fchs
28:	

cosh$9:	; parameter £temporary761, offset 6
29:		fstp qword [bp + 28]
31:	

cosh$10:	; call function noellipse-noellipse exp
32:		mov word [bp + 22], cosh$11
33:		mov [bp + 24], bp
34:		add bp, 22
35:		jmp exp
37:	

cosh$11:	; post call
38:		fstp qword [bp + 22]
39:		fld qword [bp + 14]
40:		fld qword [bp + 22]
42:	

cosh$12:	; £temporary762 = return_value
44:	

cosh$13:	; £temporary763 = £temporary760 + £temporary762
45:		fadd
47:	

cosh$14:	; push float 2
48:		fld qword [float8$2#]
50:	

cosh$15:	; £temporary764 = £temporary763 / 2
51:		fdiv
53:	

cosh$16:	; return_value = £temporary764
55:	

cosh$17:	; return
56:		mov t408, [bp]
57:		mov di, [bp + 4]
58:		mov bp, [bp + 2]
59:		jmp t408
61:	

cosh$18:	; function end cosh
1:	

tanh:	; call header integral zero 0 stack zero 0
3:	

tanh$1:	; push float x
4:		fld qword [bp + 6]
6:	

tanh$2:	; parameter x, offset 6
7:		fstp qword [bp + 20]
9:	

tanh$3:	; call function noellipse-noellipse sinh
10:		mov word [bp + 14], tanh$4
11:		mov [bp + 16], bp
12:		add bp, 14
13:		jmp sinh
15:	

tanh$4:	; post call
17:	

tanh$5:	; £temporary767 = return_value
19:	

tanh$6:	; call header integral zero 0 stack no zero 1
20:		fstp qword [bp + 14]
22:	

tanh$7:	; push float x
23:		fld qword [bp + 6]
25:	

tanh$8:	; parameter x, offset 6
26:		fstp qword [bp + 28]
28:	

tanh$9:	; call function noellipse-noellipse cosh
29:		mov word [bp + 22], tanh$10
30:		mov [bp + 24], bp
31:		add bp, 22
32:		jmp cosh
34:	

tanh$10:	; post call
35:		fstp qword [bp + 22]
36:		fld qword [bp + 14]
37:		fld qword [bp + 22]
39:	

tanh$11:	; £temporary768 = return_value
41:	

tanh$12:	; £temporary769 = £temporary767 / £temporary768
42:		fdiv
44:	

tanh$13:	; return_value = £temporary769
46:	

tanh$14:	; return
47:		mov t409, [bp]
48:		mov di, [bp + 4]
49:		mov bp, [bp + 2]
50:		jmp t409
52:	

tanh$15:	; function end tanh
1:	

floor:	; push float x
2:		fld qword [bp + 6]
4:	

floor$1:	; push 0
5:		fldz
7:	

floor$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe floor$13
13:	

floor$3:	; call header integral zero 0 stack zero 0
15:	

floor$4:	; push float x
16:		fld qword [bp + 6]
18:	

floor$5:	; £temporary773 = -x
19:		fchs
21:	

floor$6:	; parameter £temporary773, offset 6
22:		fstp qword [bp + 20]
24:	

floor$7:	; call function noellipse-noellipse ceil
25:		mov word [bp + 14], floor$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp ceil
30:	

floor$8:	; post call
32:	

floor$9:	; £temporary774 = return_value
34:	

floor$10:	; £temporary775 = -£temporary774
35:		fchs
37:	

floor$11:	; return_value = £temporary775
39:	

floor$12:	; return
40:		mov t410, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t410
45:	

floor$13:	; push float x
46:		fld qword [bp + 6]
48:	

floor$14:	; £temporary776 = float_to_int x (Double -> Signed_Long_Int)
49:		fistp dword [container4bytes#]
50:		mov t411, [container4bytes#]
52:	

floor$15:	; £temporary777 = int_to_float £temporary776 (Signed_Long_Int -> Double)
53:		mov [container4bytes#], t411
54:		fild dword [container4bytes#]
56:	

floor$16:	; return_value = £temporary777
58:	

floor$17:	; return
59:		mov t412, [bp]
60:		mov di, [bp + 4]
61:		mov bp, [bp + 2]
62:		jmp t412
64:	

floor$18:	; function end floor
1:	

ceil:	; push float x
2:		fld qword [bp + 6]
4:	

ceil$1:	; push 0
5:		fldz
7:	

ceil$2:	; if x >= 0 goto 13
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe ceil$13
13:	

ceil$3:	; call header integral zero 0 stack zero 0
15:	

ceil$4:	; push float x
16:		fld qword [bp + 6]
18:	

ceil$5:	; £temporary780 = -x
19:		fchs
21:	

ceil$6:	; parameter £temporary780, offset 6
22:		fstp qword [bp + 20]
24:	

ceil$7:	; call function noellipse-noellipse floor
25:		mov word [bp + 14], ceil$8
26:		mov [bp + 16], bp
27:		add bp, 14
28:		jmp floor
30:	

ceil$8:	; post call
32:	

ceil$9:	; £temporary781 = return_value
34:	

ceil$10:	; £temporary782 = -£temporary781
35:		fchs
37:	

ceil$11:	; return_value = £temporary782
39:	

ceil$12:	; return
40:		mov t413, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp t413
45:	

ceil$13:	; push float x
46:		fld qword [bp + 6]
48:	

ceil$14:	; push float 0.999999999999
49:		fld qword [float8$0.999999999999#]
51:	

ceil$15:	; £temporary783 = x + 0.999999999999
52:		fadd
54:	

ceil$16:	; £temporary784 = float_to_int £temporary783 (Double -> Signed_Long_Int)
55:		fistp dword [container4bytes#]
56:		mov t414, [container4bytes#]
58:	

ceil$17:	; £temporary785 = int_to_float £temporary784 (Signed_Long_Int -> Double)
59:		mov [container4bytes#], t414
60:		fild dword [container4bytes#]
62:	

ceil$18:	; return_value = £temporary785
64:	

ceil$19:	; return
65:		mov t415, [bp]
66:		mov di, [bp + 4]
67:		mov bp, [bp + 2]
68:		jmp t415
70:	

ceil$20:	; function end ceil
1:	

round:	; push float x
2:		fld qword [bp + 6]
4:	

round$1:	; push 0
5:		fldz
7:	

round$2:	; if x >= 0 goto 8
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe round$8
13:	

round$3:	; push float x
14:		fld qword [bp + 6]
16:	

round$4:	; push float 0.5
17:		fld qword [float8$0.5#]
19:	

round$5:	; £temporary788 = x - 0.5
20:		fsub
22:	

round$6:	; decrease stack
24:	

round$7:	; goto 11
25:		jmp round$11
27:	

round$8:	; push float x
28:		fld qword [bp + 6]
30:	

round$9:	; push float 0.5
31:		fld qword [float8$0.5#]
33:	

round$10:	; £temporary789 = x + 0.5
34:		fadd
36:	

round$11:	; £temporary794 = float_to_int £temporary793 (Double -> Signed_Long_Int)
37:		fistp dword [container4bytes#]
38:		mov t416, [container4bytes#]
40:	

round$12:	; £temporary795 = int_to_float £temporary794 (Signed_Long_Int -> Double)
41:		mov [container4bytes#], t416
42:		fild dword [container4bytes#]
44:	

round$13:	; return_value = £temporary795
46:	

round$14:	; return
47:		mov t417, [bp]
48:		mov di, [bp + 4]
49:		mov bp, [bp + 2]
50:		jmp t417
52:	

round$15:	; function end round
1:	

fabs:	; push float x
2:		fld qword [bp + 6]
4:	

fabs$1:	; push 0
5:		fldz
7:	

fabs$2:	; if x >= 0 goto 7
8:		fcompp
9:		fstsw ax
10:		sahf
11:		jbe fabs$7
13:	

fabs$3:	; push float x
14:		fld qword [bp + 6]
16:	

fabs$4:	; £temporary797 = -x
17:		fchs
19:	

fabs$5:	; decrease stack
21:	

fabs$6:	; goto 8
22:		jmp fabs$8
24:	

fabs$7:	; push float x
25:		fld qword [bp + 6]
27:	

fabs$8:	; return_value = £temporary801
29:	

fabs$9:	; return
30:		mov t418, [bp]
31:		mov di, [bp + 4]
32:		mov bp, [bp + 2]
33:		jmp t418
35:	

fabs$10:	; function end fabs
