1:	

scanChar:	; c = 0
2:		mov byte [bp + 6], 0
4:	

scanChar$1:	; case g_inStatus == 0 goto 5
5:		mov ax, [g_inStatus]
6:		cmp ax, 0
7:		je scanChar$5
9:	

scanChar$2:	; case g_inStatus == 1 goto 18
10:		cmp ax, 1
11:		je scanChar$18
13:	

scanChar$3:	; case end g_inStatus
15:	

scanChar$4:	; goto 26
16:		jmp scanChar$26
18:	

scanChar$5:	; £temporary1235 = int_to_int g_inDevice (Pointer -> Pointer)
19:		mov ax, [g_inDevice]
22:	

scanChar$6:	; stream = £temporary1235
23:		mov [bp + 7], ax
25:	

scanChar$7:	; £temporary1236 -> stream = *stream, offset 2
26:		mov si, [bp + 7]
28:	

scanChar$8:	; handle = £temporary1236 -> stream
29:		mov ax, [si + 2]
30:		mov [bp + 9], ax
32:	

scanChar$9:	; ah = 63
33:		mov ah, 63
35:	

scanChar$10:	; bx = handle
36:		mov bx, [bp + 9]
38:	

scanChar$11:	; cx = 1
39:		mov cx, 1
41:	

scanChar$12:	; £temporary1241 = &c
42:		mov dx, bp
43:		add dx, 6
45:	

scanChar$13:	; dx = £temporary1241
47:	

scanChar$14:	; interrupt 33
48:		int 33
50:	

scanChar$15:	; ++g_inChars
51:		inc word [g_inChars]
53:	

scanChar$16:	; return_value = c
54:		mov bl, [bp + 6]
56:	

scanChar$17:	; return
57:		mov ax, [bp]
58:		mov di, [bp + 4]
59:		mov bp, [bp + 2]
60:		jmp ax
62:	

scanChar$18:	; £temporary1243 = int_to_int g_inDevice (Pointer -> Pointer)
63:		mov ax, [g_inDevice]
66:	

scanChar$19:	; inString = £temporary1243
67:		mov [bp + 11], ax
69:	

scanChar$20:	; £temporary1244 = g_inChars
70:		mov ax, [g_inChars]
72:	

scanChar$21:	; ++g_inChars
73:		inc word [g_inChars]
75:	

scanChar$22:	; £temporary1246 = inString + £temporary1244
76:		mov si, [bp + 11]
77:		add si, ax
79:	

scanChar$23:	; £temporary1245 -> £temporary1246 = *£temporary1246
81:	

scanChar$24:	; return_value = £temporary1245 -> £temporary1246
82:		mov bl, [si]
84:	

scanChar$25:	; return
85:		mov ax, [bp]
86:		mov di, [bp + 4]
87:		mov bp, [bp + 2]
88:		jmp ax
90:	

scanChar$26:	; return_value = 0
91:		mov bl, 0
93:	

scanChar$27:	; return
94:		mov ax, [bp]
95:		mov di, [bp + 4]
96:		mov bp, [bp + 2]
97:		jmp ax
99:	

scanChar$28:	; function end scanChar
1:	

unscanChar:	; case g_inStatus == 0 goto 4
2:		mov ax, [g_inStatus]
3:		cmp ax, 0
4:		je unscanChar$4
6:	

unscanChar$1:	; case g_inStatus == 1 goto 6
7:		cmp ax, 1
8:		je unscanChar$6
10:	

unscanChar$2:	; case end g_inStatus
12:	

unscanChar$3:	; goto 7
13:		jmp unscanChar$7
15:	

unscanChar$4:	; --g_inChars
16:		dec word [g_inChars]
18:	

unscanChar$5:	; goto 7
19:		jmp unscanChar$7
21:	

unscanChar$6:	; --g_inChars
22:		dec word [g_inChars]
24:	

unscanChar$7:	; return
25:		mov ax, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp ax
30:	

unscanChar$8:	; function end unscanChar
1:	

scanPattern:	; index = 0
2:		mov word [bp + 12], 0
4:	

scanPattern$1:	; call header integral zero 0 stack zero 0
6:	

scanPattern$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 14], scanPattern$3
8:		mov [bp + 16], bp
9:		add bp, 14
10:		jmp scanChar
12:	

scanPattern$3:	; post call
14:	

scanPattern$4:	; £temporary1250 = return_value
19:	

scanPattern$5:	; input = £temporary1250
20:		mov [bp + 14], bl
22:	

scanPattern$6:	; call header integral zero 0 stack zero 0
24:	

scanPattern$7:	; £temporary1251 = int_to_int input (Signed_Char -> Signed_Int)
25:		mov al, [bp + 14]
27:		and ax, 255
29:		cmp al, 0
30:		jge scanPattern$8
31:		neg al
33:		neg ax
35:	

scanPattern$8:	; parameter £temporary1251, offset 6
36:		mov [bp + 21], ax
38:	

scanPattern$9:	; call function noellipse-noellipse isspace
39:		mov word [bp + 15], scanPattern$10
40:		mov [bp + 17], bp
41:		add bp, 15
42:		jmp isspace
44:	

scanPattern$10:	; post call
46:	

scanPattern$11:	; £temporary1252 = return_value
51:	

scanPattern$12:	; if £temporary1252 == 0 goto 19
52:		cmp bx, 0
53:		je scanPattern$19
55:	

scanPattern$13:	; call header integral zero 0 stack zero 0
57:	

scanPattern$14:	; call function noellipse-noellipse scanChar
58:		mov word [bp + 15], scanPattern$15
59:		mov [bp + 17], bp
60:		add bp, 15
61:		jmp scanChar
63:	

scanPattern$15:	; post call
65:	

scanPattern$16:	; £temporary1253 = return_value
70:	

scanPattern$17:	; input = £temporary1253
71:		mov [bp + 14], bl
73:	

scanPattern$18:	; goto 6
74:		jmp scanPattern$6
76:	

scanPattern$19:	; if string == 0 goto 53
77:		cmp word [bp + 6], 0
78:		je scanPattern$53
80:	

scanPattern$20:	; if not != 0 goto 29
81:		cmp word [bp + 10], 0
82:		jne scanPattern$29
84:	

scanPattern$21:	; call header integral zero 0 stack zero 0
86:	

scanPattern$22:	; parameter pattern, offset 6
87:		mov ax, [bp + 8]
88:		mov [bp + 21], ax
90:	

scanPattern$23:	; £temporary1258 = int_to_int input (Signed_Char -> Signed_Int)
91:		mov al, [bp + 14]
93:		and ax, 255
95:		cmp al, 0
96:		jge scanPattern$24
97:		neg al
99:		neg ax
101:	

scanPattern$24:	; parameter £temporary1258, offset 8
102:		mov [bp + 23], ax
104:	

scanPattern$25:	; call function noellipse-noellipse strchr
105:		mov word [bp + 15], scanPattern$26
106:		mov [bp + 17], bp
107:		add bp, 15
108:		jmp strchr
110:	

scanPattern$26:	; post call
112:	

scanPattern$27:	; £temporary1259 = return_value
117:	

scanPattern$28:	; if £temporary1259 != 0 goto 38
118:		cmp bx, 0
119:		jne scanPattern$38
121:	

scanPattern$29:	; if not == 0 goto 49
122:		cmp word [bp + 10], 0
123:		je scanPattern$49
125:	

scanPattern$30:	; call header integral zero 0 stack zero 0
127:	

scanPattern$31:	; parameter pattern, offset 6
128:		mov ax, [bp + 8]
129:		mov [bp + 21], ax
131:	

scanPattern$32:	; £temporary1262 = int_to_int input (Signed_Char -> Signed_Int)
132:		mov al, [bp + 14]
134:		and ax, 255
136:		cmp al, 0
137:		jge scanPattern$33
138:		neg al
140:		neg ax
142:	

scanPattern$33:	; parameter £temporary1262, offset 8
143:		mov [bp + 23], ax
145:	

scanPattern$34:	; call function noellipse-noellipse strchr
146:		mov word [bp + 15], scanPattern$35
147:		mov [bp + 17], bp
148:		add bp, 15
149:		jmp strchr
151:	

scanPattern$35:	; post call
153:	

scanPattern$36:	; £temporary1263 = return_value
158:	

scanPattern$37:	; if £temporary1263 != 0 goto 49
159:		cmp bx, 0
160:		jne scanPattern$49
162:	

scanPattern$38:	; £temporary1269 = index
163:		mov ax, [bp + 12]
165:	

scanPattern$39:	; ++index
166:		inc word [bp + 12]
168:	

scanPattern$40:	; £temporary1271 = string + £temporary1269
169:		mov si, [bp + 6]
170:		add si, ax
172:	

scanPattern$41:	; £temporary1270 -> £temporary1271 = *£temporary1271
174:	

scanPattern$42:	; £temporary1270 -> £temporary1271 = input
175:		mov al, [bp + 14]
176:		mov [si], al
178:	

scanPattern$43:	; call header integral zero 0 stack zero 0
180:	

scanPattern$44:	; call function noellipse-noellipse scanChar
181:		mov word [bp + 15], scanPattern$45
182:		mov [bp + 17], bp
183:		add bp, 15
184:		jmp scanChar
186:	

scanPattern$45:	; post call
188:	

scanPattern$46:	; £temporary1272 = return_value
193:	

scanPattern$47:	; input = £temporary1272
194:		mov [bp + 14], bl
196:	

scanPattern$48:	; goto 20
197:		jmp scanPattern$20
199:	

scanPattern$49:	; £temporary1274 = string + index
200:		mov si, [bp + 6]
201:		add si, [bp + 12]
203:	

scanPattern$50:	; £temporary1273 -> £temporary1274 = *£temporary1274
205:	

scanPattern$51:	; £temporary1273 -> £temporary1274 = 0
206:		mov byte [si], 0
208:	

scanPattern$52:	; goto 77
209:		jmp scanPattern$77
211:	

scanPattern$53:	; if not != 0 goto 62
212:		cmp word [bp + 10], 0
213:		jne scanPattern$62
215:	

scanPattern$54:	; call header integral zero 0 stack zero 0
217:	

scanPattern$55:	; parameter pattern, offset 6
218:		mov ax, [bp + 8]
219:		mov [bp + 21], ax
221:	

scanPattern$56:	; £temporary1277 = int_to_int input (Signed_Char -> Signed_Int)
222:		mov al, [bp + 14]
224:		and ax, 255
226:		cmp al, 0
227:		jge scanPattern$57
228:		neg al
230:		neg ax
232:	

scanPattern$57:	; parameter £temporary1277, offset 8
233:		mov [bp + 23], ax
235:	

scanPattern$58:	; call function noellipse-noellipse strchr
236:		mov word [bp + 15], scanPattern$59
237:		mov [bp + 17], bp
238:		add bp, 15
239:		jmp strchr
241:	

scanPattern$59:	; post call
243:	

scanPattern$60:	; £temporary1278 = return_value
248:	

scanPattern$61:	; if £temporary1278 != 0 goto 71
249:		cmp bx, 0
250:		jne scanPattern$71
252:	

scanPattern$62:	; if not == 0 goto 77
253:		cmp word [bp + 10], 0
254:		je scanPattern$77
256:	

scanPattern$63:	; call header integral zero 0 stack zero 0
258:	

scanPattern$64:	; parameter pattern, offset 6
259:		mov ax, [bp + 8]
260:		mov [bp + 21], ax
262:	

scanPattern$65:	; £temporary1281 = int_to_int input (Signed_Char -> Signed_Int)
263:		mov al, [bp + 14]
265:		and ax, 255
267:		cmp al, 0
268:		jge scanPattern$66
269:		neg al
271:		neg ax
273:	

scanPattern$66:	; parameter £temporary1281, offset 8
274:		mov [bp + 23], ax
276:	

scanPattern$67:	; call function noellipse-noellipse strchr
277:		mov word [bp + 15], scanPattern$68
278:		mov [bp + 17], bp
279:		add bp, 15
280:		jmp strchr
282:	

scanPattern$68:	; post call
284:	

scanPattern$69:	; £temporary1282 = return_value
289:	

scanPattern$70:	; if £temporary1282 != 0 goto 77
290:		cmp bx, 0
291:		jne scanPattern$77
293:	

scanPattern$71:	; call header integral zero 0 stack zero 0
295:	

scanPattern$72:	; call function noellipse-noellipse scanChar
296:		mov word [bp + 15], scanPattern$73
297:		mov [bp + 17], bp
298:		add bp, 15
299:		jmp scanChar
301:	

scanPattern$73:	; post call
303:	

scanPattern$74:	; £temporary1288 = return_value
308:	

scanPattern$75:	; input = £temporary1288
309:		mov [bp + 14], bl
311:	

scanPattern$76:	; goto 53
312:		jmp scanPattern$53
314:	

scanPattern$77:	; return
315:		mov ax, [bp]
316:		mov di, [bp + 4]
317:		mov bp, [bp + 2]
318:		jmp ax
320:	

scanPattern$78:	; function end scanPattern
1:	

scanString:	; index = 0
2:		mov word [bp + 10], 0
4:	

scanString$1:	; call header integral zero 0 stack zero 0
6:	

scanString$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 12], scanString$3
8:		mov [bp + 14], bp
9:		add bp, 12
10:		jmp scanChar
12:	

scanString$3:	; post call
14:	

scanString$4:	; £temporary1298 = return_value
19:	

scanString$5:	; input = £temporary1298
20:		mov [bp + 12], bl
22:	

scanString$6:	; found = 0
23:		mov word [bp + 13], 0
25:	

scanString$7:	; call header integral zero 0 stack zero 0
27:	

scanString$8:	; £temporary1299 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 12]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanString$9
34:		neg al
36:		neg ax
38:	

scanString$9:	; parameter £temporary1299, offset 6
39:		mov [bp + 21], ax
41:	

scanString$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 15], scanString$11
43:		mov [bp + 17], bp
44:		add bp, 15
45:		jmp isspace
47:	

scanString$11:	; post call
49:	

scanString$12:	; £temporary1300 = return_value
54:	

scanString$13:	; if £temporary1300 == 0 goto 20
55:		cmp bx, 0
56:		je scanString$20
58:	

scanString$14:	; call header integral zero 0 stack zero 0
60:	

scanString$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 15], scanString$16
62:		mov [bp + 17], bp
63:		add bp, 15
64:		jmp scanChar
66:	

scanString$16:	; post call
68:	

scanString$17:	; £temporary1301 = return_value
73:	

scanString$18:	; input = £temporary1301
74:		mov [bp + 12], bl
76:	

scanString$19:	; goto 7
77:		jmp scanString$7
79:	

scanString$20:	; if string == 0 goto 82
80:		cmp word [bp + 6], 0
81:		je scanString$82
83:	

scanString$21:	; if precision != 0 goto 50
84:		cmp word [bp + 8], 0
85:		jne scanString$50
87:	

scanString$22:	; call header integral zero 0 stack zero 0
89:	

scanString$23:	; £temporary1305 = int_to_int input (Signed_Char -> Signed_Int)
90:		mov al, [bp + 12]
92:		and ax, 255
94:		cmp al, 0
95:		jge scanString$24
96:		neg al
98:		neg ax
100:	

scanString$24:	; parameter £temporary1305, offset 6
101:		mov [bp + 21], ax
103:	

scanString$25:	; call function noellipse-noellipse isspace
104:		mov word [bp + 15], scanString$26
105:		mov [bp + 17], bp
106:		add bp, 15
107:		jmp isspace
109:	

scanString$26:	; post call
111:	

scanString$27:	; £temporary1306 = return_value
116:	

scanString$28:	; if £temporary1306 != 0 goto 45
117:		cmp bx, 0
118:		jne scanString$45
120:	

scanString$29:	; £temporary1309 = int_to_int input (Signed_Char -> Signed_Int)
121:		mov al, [bp + 12]
123:		and ax, 255
125:		cmp al, 0
126:		jge scanString$30
127:		neg al
129:		neg ax
131:	

scanString$30:	; if £temporary1309 == -1 goto 45
132:		cmp ax, -1
133:		je scanString$45
135:	

scanString$31:	; if input == 10 goto 45
136:		cmp byte [bp + 12], 10
137:		je scanString$45
139:	

scanString$32:	; £temporary1314 = index
140:		mov ax, [bp + 10]
142:	

scanString$33:	; ++index
143:		inc word [bp + 10]
145:	

scanString$34:	; £temporary1316 = string + £temporary1314
146:		mov si, [bp + 6]
147:		add si, ax
149:	

scanString$35:	; £temporary1315 -> £temporary1316 = *£temporary1316
151:	

scanString$36:	; £temporary1315 -> £temporary1316 = input
152:		mov al, [bp + 12]
153:		mov [si], al
155:	

scanString$37:	; call header integral zero 0 stack zero 0
157:	

scanString$38:	; call function noellipse-noellipse scanChar
158:		mov word [bp + 15], scanString$39
159:		mov [bp + 17], bp
160:		add bp, 15
161:		jmp scanChar
163:	

scanString$39:	; post call
165:	

scanString$40:	; £temporary1317 = return_value
170:	

scanString$41:	; input = £temporary1317
171:		mov [bp + 12], bl
173:	

scanString$42:	; found = 1
174:		mov word [bp + 13], 1
176:	

scanString$43:	; ++g_inChars
177:		inc word [g_inChars]
179:	

scanString$44:	; goto 22
180:		jmp scanString$22
182:	

scanString$45:	; £temporary1320 = string + index
183:		mov si, [bp + 6]
184:		add si, [bp + 10]
186:	

scanString$46:	; £temporary1319 -> £temporary1320 = *£temporary1320
188:	

scanString$47:	; £temporary1319 -> £temporary1320 = 0
189:		mov byte [si], 0
191:	

scanString$48:	; ++g_inChars
192:		inc word [g_inChars]
194:	

scanString$49:	; goto 126
195:		jmp scanString$126
197:	

scanString$50:	; £temporary1322 = precision
198:		mov ax, [bp + 8]
200:	

scanString$51:	; --precision
201:		dec word [bp + 8]
203:	

scanString$52:	; if £temporary1322 <= 0 goto 76
204:		cmp ax, 0
205:		jle scanString$76
207:	

scanString$53:	; call header integral zero 0 stack zero 0
209:	

scanString$54:	; £temporary1324 = int_to_int input (Signed_Char -> Signed_Int)
210:		mov al, [bp + 12]
212:		and ax, 255
214:		cmp al, 0
215:		jge scanString$55
216:		neg al
218:		neg ax
220:	

scanString$55:	; parameter £temporary1324, offset 6
221:		mov [bp + 21], ax
223:	

scanString$56:	; call function noellipse-noellipse isspace
224:		mov word [bp + 15], scanString$57
225:		mov [bp + 17], bp
226:		add bp, 15
227:		jmp isspace
229:	

scanString$57:	; post call
231:	

scanString$58:	; £temporary1325 = return_value
236:	

scanString$59:	; if £temporary1325 != 0 goto 76
237:		cmp bx, 0
238:		jne scanString$76
240:	

scanString$60:	; £temporary1328 = int_to_int input (Signed_Char -> Signed_Int)
241:		mov al, [bp + 12]
243:		and ax, 255
245:		cmp al, 0
246:		jge scanString$61
247:		neg al
249:		neg ax
251:	

scanString$61:	; if £temporary1328 == -1 goto 76
252:		cmp ax, -1
253:		je scanString$76
255:	

scanString$62:	; if input == 10 goto 76
256:		cmp byte [bp + 12], 10
257:		je scanString$76
259:	

scanString$63:	; £temporary1334 = index
260:		mov ax, [bp + 10]
262:	

scanString$64:	; ++index
263:		inc word [bp + 10]
265:	

scanString$65:	; £temporary1336 = string + £temporary1334
266:		mov si, [bp + 6]
267:		add si, ax
269:	

scanString$66:	; £temporary1335 -> £temporary1336 = *£temporary1336
271:	

scanString$67:	; £temporary1335 -> £temporary1336 = input
272:		mov al, [bp + 12]
273:		mov [si], al
275:	

scanString$68:	; call header integral zero 0 stack zero 0
277:	

scanString$69:	; call function noellipse-noellipse scanChar
278:		mov word [bp + 15], scanString$70
279:		mov [bp + 17], bp
280:		add bp, 15
281:		jmp scanChar
283:	

scanString$70:	; post call
285:	

scanString$71:	; £temporary1337 = return_value
290:	

scanString$72:	; input = £temporary1337
291:		mov [bp + 12], bl
293:	

scanString$73:	; found = 1
294:		mov word [bp + 13], 1
296:	

scanString$74:	; ++g_inChars
297:		inc word [g_inChars]
299:	

scanString$75:	; goto 50
300:		jmp scanString$50
302:	

scanString$76:	; if precision <= 0 goto 126
303:		cmp word [bp + 8], 0
304:		jle scanString$126
306:	

scanString$77:	; £temporary1341 = string + index
307:		mov si, [bp + 6]
308:		add si, [bp + 10]
310:	

scanString$78:	; £temporary1340 -> £temporary1341 = *£temporary1341
312:	

scanString$79:	; £temporary1340 -> £temporary1341 = 0
313:		mov byte [si], 0
315:	

scanString$80:	; ++g_inChars
316:		inc word [g_inChars]
318:	

scanString$81:	; goto 126
319:		jmp scanString$126
321:	

scanString$82:	; if precision != 0 goto 103
322:		cmp word [bp + 8], 0
323:		jne scanString$103
325:	

scanString$83:	; call header integral zero 0 stack zero 0
327:	

scanString$84:	; £temporary1344 = int_to_int input (Signed_Char -> Signed_Int)
328:		mov al, [bp + 12]
330:		and ax, 255
332:		cmp al, 0
333:		jge scanString$85
334:		neg al
336:		neg ax
338:	

scanString$85:	; parameter £temporary1344, offset 6
339:		mov [bp + 21], ax
341:	

scanString$86:	; call function noellipse-noellipse isspace
342:		mov word [bp + 15], scanString$87
343:		mov [bp + 17], bp
344:		add bp, 15
345:		jmp isspace
347:	

scanString$87:	; post call
349:	

scanString$88:	; £temporary1345 = return_value
354:	

scanString$89:	; if £temporary1345 != 0 goto 101
355:		cmp bx, 0
356:		jne scanString$101
358:	

scanString$90:	; £temporary1348 = int_to_int input (Signed_Char -> Signed_Int)
359:		mov al, [bp + 12]
361:		and ax, 255
363:		cmp al, 0
364:		jge scanString$91
365:		neg al
367:		neg ax
369:	

scanString$91:	; if £temporary1348 == -1 goto 101
370:		cmp ax, -1
371:		je scanString$101
373:	

scanString$92:	; if input == 10 goto 101
374:		cmp byte [bp + 12], 10
375:		je scanString$101
377:	

scanString$93:	; call header integral zero 0 stack zero 0
379:	

scanString$94:	; call function noellipse-noellipse scanChar
380:		mov word [bp + 15], scanString$95
381:		mov [bp + 17], bp
382:		add bp, 15
383:		jmp scanChar
385:	

scanString$95:	; post call
387:	

scanString$96:	; £temporary1353 = return_value
392:	

scanString$97:	; input = £temporary1353
393:		mov [bp + 12], bl
395:	

scanString$98:	; found = 1
396:		mov word [bp + 13], 1
398:	

scanString$99:	; ++g_inChars
399:		inc word [g_inChars]
401:	

scanString$100:	; goto 83
402:		jmp scanString$83
404:	

scanString$101:	; ++g_inChars
405:		inc word [g_inChars]
407:	

scanString$102:	; goto 126
408:		jmp scanString$126
410:	

scanString$103:	; £temporary1356 = precision
411:		mov ax, [bp + 8]
413:	

scanString$104:	; --precision
414:		dec word [bp + 8]
416:	

scanString$105:	; if £temporary1356 <= 0 goto 124
417:		cmp ax, 0
418:		jle scanString$124
420:	

scanString$106:	; call header integral zero 0 stack zero 0
422:	

scanString$107:	; £temporary1358 = int_to_int input (Signed_Char -> Signed_Int)
423:		mov al, [bp + 12]
425:		and ax, 255
427:		cmp al, 0
428:		jge scanString$108
429:		neg al
431:		neg ax
433:	

scanString$108:	; parameter £temporary1358, offset 6
434:		mov [bp + 21], ax
436:	

scanString$109:	; call function noellipse-noellipse isspace
437:		mov word [bp + 15], scanString$110
438:		mov [bp + 17], bp
439:		add bp, 15
440:		jmp isspace
442:	

scanString$110:	; post call
444:	

scanString$111:	; £temporary1359 = return_value
449:	

scanString$112:	; if £temporary1359 != 0 goto 124
450:		cmp bx, 0
451:		jne scanString$124
453:	

scanString$113:	; £temporary1362 = int_to_int input (Signed_Char -> Signed_Int)
454:		mov al, [bp + 12]
456:		and ax, 255
458:		cmp al, 0
459:		jge scanString$114
460:		neg al
462:		neg ax
464:	

scanString$114:	; if £temporary1362 == -1 goto 124
465:		cmp ax, -1
466:		je scanString$124
468:	

scanString$115:	; if input == 10 goto 124
469:		cmp byte [bp + 12], 10
470:		je scanString$124
472:	

scanString$116:	; call header integral zero 0 stack zero 0
474:	

scanString$117:	; call function noellipse-noellipse scanChar
475:		mov word [bp + 15], scanString$118
476:		mov [bp + 17], bp
477:		add bp, 15
478:		jmp scanChar
480:	

scanString$118:	; post call
482:	

scanString$119:	; £temporary1368 = return_value
487:	

scanString$120:	; input = £temporary1368
488:		mov [bp + 12], bl
490:	

scanString$121:	; found = 1
491:		mov word [bp + 13], 1
493:	

scanString$122:	; ++g_inChars
494:		inc word [g_inChars]
496:	

scanString$123:	; goto 103
497:		jmp scanString$103
499:	

scanString$124:	; if precision <= 0 goto 126
500:		cmp word [bp + 8], 0
501:		jle scanString$126
503:	

scanString$125:	; ++g_inChars
504:		inc word [g_inChars]
506:	

scanString$126:	; if found == 0 goto 128
507:		cmp word [bp + 13], 0
508:		je scanString$128
510:	

scanString$127:	; ++g_inCount
511:		inc word [g_inCount]
513:	

scanString$128:	; return
514:		mov ax, [bp]
515:		mov di, [bp + 4]
516:		mov bp, [bp + 2]
517:		jmp ax
519:	

scanString$129:	; function end scanString
1:	

@24$isDigitInBase:	; call header integral zero 0 stack zero 0
3:	

@24$isDigitInBase$1:	; £temporary1379 = int_to_int c (Signed_Char -> Signed_Int)
4:		mov al, [bp + 6]
6:		and ax, 255
8:		cmp al, 0
9:		jge @24$isDigitInBase$2
10:		neg al
12:		neg ax
14:	

@24$isDigitInBase$2:	; parameter £temporary1379, offset 6
15:		mov [bp + 15], ax
17:	

@24$isDigitInBase$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 9], @24$isDigitInBase$4
19:		mov [bp + 11], bp
20:		add bp, 9
21:		jmp isdigit
23:	

@24$isDigitInBase$4:	; post call
25:	

@24$isDigitInBase$5:	; £temporary1380 = return_value
30:	

@24$isDigitInBase$6:	; if £temporary1380 == 0 goto 17
31:		cmp bx, 0
32:		je @24$isDigitInBase$17
34:	

@24$isDigitInBase$7:	; £temporary1381 = c - 48
35:		mov al, [bp + 6]
36:		sub al, 48
38:	

@24$isDigitInBase$8:	; £temporary1382 = int_to_int £temporary1381 (Signed_Char -> Signed_Int)
40:		and ax, 255
42:		cmp al, 0
43:		jge @24$isDigitInBase$9
44:		neg al
46:		neg ax
48:	

@24$isDigitInBase$9:	; value = £temporary1382
49:		mov [bp + 9], ax
51:	

@24$isDigitInBase$10:	; if value < 0 goto 14
52:		cmp word [bp + 9], 0
53:		jl @24$isDigitInBase$14
55:	

@24$isDigitInBase$11:	; if value >= base goto 14
56:		mov ax, [bp + 7]
57:		cmp [bp + 9], ax
58:		jge @24$isDigitInBase$14
60:	

@24$isDigitInBase$12:	; £temporary1386 = 1
61:		mov bx, 1
63:	

@24$isDigitInBase$13:	; goto 15
64:		jmp @24$isDigitInBase$15
66:	

@24$isDigitInBase$14:	; £temporary1386 = 0
67:		mov bx, 0
69:	

@24$isDigitInBase$15:	; return_value = £temporary1386
71:	

@24$isDigitInBase$16:	; return
72:		mov ax, [bp]
73:		mov di, [bp + 4]
74:		mov bp, [bp + 2]
75:		jmp ax
77:	

@24$isDigitInBase$17:	; call header integral zero 0 stack zero 0
79:	

@24$isDigitInBase$18:	; £temporary1387 = int_to_int c (Signed_Char -> Signed_Int)
80:		mov al, [bp + 6]
82:		and ax, 255
84:		cmp al, 0
85:		jge @24$isDigitInBase$19
86:		neg al
88:		neg ax
90:	

@24$isDigitInBase$19:	; parameter £temporary1387, offset 6
91:		mov [bp + 15], ax
93:	

@24$isDigitInBase$20:	; call function noellipse-noellipse islower
94:		mov word [bp + 9], @24$isDigitInBase$21
95:		mov [bp + 11], bp
96:		add bp, 9
97:		jmp islower
99:	

@24$isDigitInBase$21:	; post call
101:	

@24$isDigitInBase$22:	; £temporary1388 = return_value
106:	

@24$isDigitInBase$23:	; if £temporary1388 == 0 goto 34
107:		cmp bx, 0
108:		je @24$isDigitInBase$34
110:	

@24$isDigitInBase$24:	; £temporary1389 = c - 97
111:		mov al, [bp + 6]
112:		sub al, 97
114:	

@24$isDigitInBase$25:	; £temporary1390 = int_to_int £temporary1389 (Signed_Char -> Signed_Int)
116:		and ax, 255
118:		cmp al, 0
119:		jge @24$isDigitInBase$26
120:		neg al
122:		neg ax
124:	

@24$isDigitInBase$26:	; value = £temporary1390 + 10
125:		add ax, 10
126:		mov [bp + 9], ax
128:	

@24$isDigitInBase$27:	; if value < 0 goto 31
129:		cmp word [bp + 9], 0
130:		jl @24$isDigitInBase$31
132:	

@24$isDigitInBase$28:	; if value >= base goto 31
133:		mov ax, [bp + 7]
134:		cmp [bp + 9], ax
135:		jge @24$isDigitInBase$31
137:	

@24$isDigitInBase$29:	; £temporary1395 = 1
138:		mov bx, 1
140:	

@24$isDigitInBase$30:	; goto 32
141:		jmp @24$isDigitInBase$32
143:	

@24$isDigitInBase$31:	; £temporary1395 = 0
144:		mov bx, 0
146:	

@24$isDigitInBase$32:	; return_value = £temporary1395
148:	

@24$isDigitInBase$33:	; return
149:		mov ax, [bp]
150:		mov di, [bp + 4]
151:		mov bp, [bp + 2]
152:		jmp ax
154:	

@24$isDigitInBase$34:	; call header integral zero 0 stack zero 0
156:	

@24$isDigitInBase$35:	; £temporary1396 = int_to_int c (Signed_Char -> Signed_Int)
157:		mov al, [bp + 6]
159:		and ax, 255
161:		cmp al, 0
162:		jge @24$isDigitInBase$36
163:		neg al
165:		neg ax
167:	

@24$isDigitInBase$36:	; parameter £temporary1396, offset 6
168:		mov [bp + 15], ax
170:	

@24$isDigitInBase$37:	; call function noellipse-noellipse isupper
171:		mov word [bp + 9], @24$isDigitInBase$38
172:		mov [bp + 11], bp
173:		add bp, 9
174:		jmp isupper
176:	

@24$isDigitInBase$38:	; post call
178:	

@24$isDigitInBase$39:	; £temporary1397 = return_value
183:	

@24$isDigitInBase$40:	; if £temporary1397 == 0 goto 51
184:		cmp bx, 0
185:		je @24$isDigitInBase$51
187:	

@24$isDigitInBase$41:	; £temporary1398 = c - 65
188:		mov al, [bp + 6]
189:		sub al, 65
191:	

@24$isDigitInBase$42:	; £temporary1399 = int_to_int £temporary1398 (Signed_Char -> Signed_Int)
193:		and ax, 255
195:		cmp al, 0
196:		jge @24$isDigitInBase$43
197:		neg al
199:		neg ax
201:	

@24$isDigitInBase$43:	; value = £temporary1399 + 10
202:		add ax, 10
203:		mov [bp + 9], ax
205:	

@24$isDigitInBase$44:	; if value < 0 goto 48
206:		cmp word [bp + 9], 0
207:		jl @24$isDigitInBase$48
209:	

@24$isDigitInBase$45:	; if value >= base goto 48
210:		mov ax, [bp + 7]
211:		cmp [bp + 9], ax
212:		jge @24$isDigitInBase$48
214:	

@24$isDigitInBase$46:	; £temporary1404 = 1
215:		mov bx, 1
217:	

@24$isDigitInBase$47:	; goto 49
218:		jmp @24$isDigitInBase$49
220:	

@24$isDigitInBase$48:	; £temporary1404 = 0
221:		mov bx, 0
223:	

@24$isDigitInBase$49:	; return_value = £temporary1404
225:	

@24$isDigitInBase$50:	; return
226:		mov ax, [bp]
227:		mov di, [bp + 4]
228:		mov bp, [bp + 2]
229:		jmp ax
231:	

@24$isDigitInBase$51:	; return_value = 0
232:		mov bx, 0
234:	

@24$isDigitInBase$52:	; return
235:		mov ax, [bp]
236:		mov di, [bp + 4]
237:		mov bp, [bp + 2]
238:		jmp ax
240:	

@24$isDigitInBase$53:	; function end isDigitInBase
1:	

@25$digitToValue:	; call header integral zero 0 stack zero 0
3:	

@25$digitToValue$1:	; £temporary1411 = int_to_int c (Signed_Char -> Signed_Int)
4:		mov al, [bp + 6]
6:		and ax, 255
8:		cmp al, 0
9:		jge @25$digitToValue$2
10:		neg al
12:		neg ax
14:	

@25$digitToValue$2:	; parameter £temporary1411, offset 6
15:		mov [bp + 13], ax
17:	

@25$digitToValue$3:	; call function noellipse-noellipse isdigit
18:		mov word [bp + 7], @25$digitToValue$4
19:		mov [bp + 9], bp
20:		add bp, 7
21:		jmp isdigit
23:	

@25$digitToValue$4:	; post call
25:	

@25$digitToValue$5:	; £temporary1412 = return_value
30:	

@25$digitToValue$6:	; if £temporary1412 == 0 goto 11
31:		cmp bx, 0
32:		je @25$digitToValue$11
34:	

@25$digitToValue$7:	; £temporary1413 = c - 48
35:		mov bl, [bp + 6]
36:		sub bl, 48
38:	

@25$digitToValue$8:	; £temporary1414 = int_to_int £temporary1413 (Signed_Char -> Signed_Int)
40:		and bx, 255
42:		cmp bl, 0
43:		jge @25$digitToValue$9
44:		neg bl
46:		neg bx
48:	

@25$digitToValue$9:	; return_value = £temporary1414
50:	

@25$digitToValue$10:	; return
51:		mov ax, [bp]
52:		mov di, [bp + 4]
53:		mov bp, [bp + 2]
54:		jmp ax
56:	

@25$digitToValue$11:	; call header integral zero 0 stack zero 0
58:	

@25$digitToValue$12:	; £temporary1415 = int_to_int c (Signed_Char -> Signed_Int)
59:		mov al, [bp + 6]
61:		and ax, 255
63:		cmp al, 0
64:		jge @25$digitToValue$13
65:		neg al
67:		neg ax
69:	

@25$digitToValue$13:	; parameter £temporary1415, offset 6
70:		mov [bp + 13], ax
72:	

@25$digitToValue$14:	; call function noellipse-noellipse islower
73:		mov word [bp + 7], @25$digitToValue$15
74:		mov [bp + 9], bp
75:		add bp, 7
76:		jmp islower
78:	

@25$digitToValue$15:	; post call
80:	

@25$digitToValue$16:	; £temporary1416 = return_value
85:	

@25$digitToValue$17:	; if £temporary1416 == 0 goto 23
86:		cmp bx, 0
87:		je @25$digitToValue$23
89:	

@25$digitToValue$18:	; £temporary1417 = c - 97
90:		mov bl, [bp + 6]
91:		sub bl, 97
93:	

@25$digitToValue$19:	; £temporary1418 = int_to_int £temporary1417 (Signed_Char -> Signed_Int)
95:		and bx, 255
97:		cmp bl, 0
98:		jge @25$digitToValue$20
99:		neg bl
101:		neg bx
103:	

@25$digitToValue$20:	; £temporary1419 = £temporary1418 + 10
104:		add bx, 10
106:	

@25$digitToValue$21:	; return_value = £temporary1419
108:	

@25$digitToValue$22:	; return
109:		mov ax, [bp]
110:		mov di, [bp + 4]
111:		mov bp, [bp + 2]
112:		jmp ax
114:	

@25$digitToValue$23:	; call header integral zero 0 stack zero 0
116:	

@25$digitToValue$24:	; £temporary1420 = int_to_int c (Signed_Char -> Signed_Int)
117:		mov al, [bp + 6]
119:		and ax, 255
121:		cmp al, 0
122:		jge @25$digitToValue$25
123:		neg al
125:		neg ax
127:	

@25$digitToValue$25:	; parameter £temporary1420, offset 6
128:		mov [bp + 13], ax
130:	

@25$digitToValue$26:	; call function noellipse-noellipse isupper
131:		mov word [bp + 7], @25$digitToValue$27
132:		mov [bp + 9], bp
133:		add bp, 7
134:		jmp isupper
136:	

@25$digitToValue$27:	; post call
138:	

@25$digitToValue$28:	; £temporary1421 = return_value
143:	

@25$digitToValue$29:	; if £temporary1421 == 0 goto 35
144:		cmp bx, 0
145:		je @25$digitToValue$35
147:	

@25$digitToValue$30:	; £temporary1422 = c - 65
148:		mov bl, [bp + 6]
149:		sub bl, 65
151:	

@25$digitToValue$31:	; £temporary1423 = int_to_int £temporary1422 (Signed_Char -> Signed_Int)
153:		and bx, 255
155:		cmp bl, 0
156:		jge @25$digitToValue$32
157:		neg bl
159:		neg bx
161:	

@25$digitToValue$32:	; £temporary1424 = £temporary1423 + 10
162:		add bx, 10
164:	

@25$digitToValue$33:	; return_value = £temporary1424
166:	

@25$digitToValue$34:	; return
167:		mov ax, [bp]
168:		mov di, [bp + 4]
169:		mov bp, [bp + 2]
170:		jmp ax
172:	

@25$digitToValue$35:	; return_value = 0
173:		mov bx, 0
175:	

@25$digitToValue$36:	; return
176:		mov ax, [bp]
177:		mov di, [bp + 4]
178:		mov bp, [bp + 2]
179:		jmp ax
181:	

@25$digitToValue$37:	; function end digitToValue
1:	

scanLongInt:	; longValue = 0
2:		mov dword [bp + 8], 0
4:	

scanLongInt$1:	; minus = 0
5:		mov word [bp + 12], 0
7:	

scanLongInt$2:	; found = 0
8:		mov word [bp + 14], 0
10:	

scanLongInt$3:	; call header integral zero 0 stack zero 0
12:	

scanLongInt$4:	; call function noellipse-noellipse scanChar
13:		mov word [bp + 16], scanLongInt$5
14:		mov [bp + 18], bp
15:		add bp, 16
16:		jmp scanChar
18:	

scanLongInt$5:	; post call
20:	

scanLongInt$6:	; £temporary1431 = return_value
25:	

scanLongInt$7:	; input = £temporary1431
26:		mov [bp + 16], bl
28:	

scanLongInt$8:	; call header integral zero 0 stack zero 0
30:	

scanLongInt$9:	; £temporary1432 = int_to_int input (Signed_Char -> Signed_Int)
31:		mov al, [bp + 16]
33:		and ax, 255
35:		cmp al, 0
36:		jge scanLongInt$10
37:		neg al
39:		neg ax
41:	

scanLongInt$10:	; parameter £temporary1432, offset 6
42:		mov [bp + 23], ax
44:	

scanLongInt$11:	; call function noellipse-noellipse isspace
45:		mov word [bp + 17], scanLongInt$12
46:		mov [bp + 19], bp
47:		add bp, 17
48:		jmp isspace
50:	

scanLongInt$12:	; post call
52:	

scanLongInt$13:	; £temporary1433 = return_value
57:	

scanLongInt$14:	; if £temporary1433 == 0 goto 21
58:		cmp bx, 0
59:		je scanLongInt$21
61:	

scanLongInt$15:	; call header integral zero 0 stack zero 0
63:	

scanLongInt$16:	; call function noellipse-noellipse scanChar
64:		mov word [bp + 17], scanLongInt$17
65:		mov [bp + 19], bp
66:		add bp, 17
67:		jmp scanChar
69:	

scanLongInt$17:	; post call
71:	

scanLongInt$18:	; £temporary1434 = return_value
76:	

scanLongInt$19:	; input = £temporary1434
77:		mov [bp + 16], bl
79:	

scanLongInt$20:	; goto 8
80:		jmp scanLongInt$8
82:	

scanLongInt$21:	; if input != 43 goto 28
83:		cmp byte [bp + 16], 43
84:		jne scanLongInt$28
86:	

scanLongInt$22:	; call header integral zero 0 stack zero 0
88:	

scanLongInt$23:	; call function noellipse-noellipse scanChar
89:		mov word [bp + 17], scanLongInt$24
90:		mov [bp + 19], bp
91:		add bp, 17
92:		jmp scanChar
94:	

scanLongInt$24:	; post call
96:	

scanLongInt$25:	; £temporary1437 = return_value
101:	

scanLongInt$26:	; input = £temporary1437
102:		mov [bp + 16], bl
104:	

scanLongInt$27:	; goto 35
105:		jmp scanLongInt$35
107:	

scanLongInt$28:	; if input != 45 goto 35
108:		cmp byte [bp + 16], 45
109:		jne scanLongInt$35
111:	

scanLongInt$29:	; minus = 1
112:		mov word [bp + 12], 1
114:	

scanLongInt$30:	; call header integral zero 0 stack zero 0
116:	

scanLongInt$31:	; call function noellipse-noellipse scanChar
117:		mov word [bp + 17], scanLongInt$32
118:		mov [bp + 19], bp
119:		add bp, 17
120:		jmp scanChar
122:	

scanLongInt$32:	; post call
124:	

scanLongInt$33:	; £temporary1439 = return_value
129:	

scanLongInt$34:	; input = £temporary1439
130:		mov [bp + 16], bl
132:	

scanLongInt$35:	; if base != 0 goto 59
133:		cmp word [bp + 6], 0
134:		jne scanLongInt$59
136:	

scanLongInt$36:	; if input != 48 goto 58
137:		cmp byte [bp + 16], 48
138:		jne scanLongInt$58
140:	

scanLongInt$37:	; call header integral zero 0 stack zero 0
142:	

scanLongInt$38:	; call function noellipse-noellipse scanChar
143:		mov word [bp + 17], scanLongInt$39
144:		mov [bp + 19], bp
145:		add bp, 17
146:		jmp scanChar
148:	

scanLongInt$39:	; post call
150:	

scanLongInt$40:	; £temporary1442 = return_value
155:	

scanLongInt$41:	; input = £temporary1442
156:		mov [bp + 16], bl
158:	

scanLongInt$42:	; call header integral zero 0 stack zero 0
160:	

scanLongInt$43:	; £temporary1443 = int_to_int input (Signed_Char -> Signed_Int)
161:		mov al, [bp + 16]
163:		and ax, 255
165:		cmp al, 0
166:		jge scanLongInt$44
167:		neg al
169:		neg ax
171:	

scanLongInt$44:	; parameter £temporary1443, offset 6
172:		mov [bp + 23], ax
174:	

scanLongInt$45:	; call function noellipse-noellipse tolower
175:		mov word [bp + 17], scanLongInt$46
176:		mov [bp + 19], bp
177:		add bp, 17
178:		jmp tolower
180:	

scanLongInt$46:	; post call
182:	

scanLongInt$47:	; £temporary1444 = return_value
187:	

scanLongInt$48:	; if £temporary1444 != 120 goto 56
188:		cmp bx, 120
189:		jne scanLongInt$56
191:	

scanLongInt$49:	; base = 16
192:		mov word [bp + 6], 16
194:	

scanLongInt$50:	; call header integral zero 0 stack zero 0
196:	

scanLongInt$51:	; call function noellipse-noellipse scanChar
197:		mov word [bp + 17], scanLongInt$52
198:		mov [bp + 19], bp
199:		add bp, 17
200:		jmp scanChar
202:	

scanLongInt$52:	; post call
204:	

scanLongInt$53:	; £temporary1446 = return_value
209:	

scanLongInt$54:	; input = £temporary1446
210:		mov [bp + 16], bl
212:	

scanLongInt$55:	; goto 59
213:		jmp scanLongInt$59
215:	

scanLongInt$56:	; base = 8
216:		mov word [bp + 6], 8
218:	

scanLongInt$57:	; goto 59
219:		jmp scanLongInt$59
221:	

scanLongInt$58:	; base = 10
222:		mov word [bp + 6], 10
224:	

scanLongInt$59:	; call header integral zero 0 stack zero 0
226:	

scanLongInt$60:	; parameter input, offset 6
227:		mov al, [bp + 16]
228:		mov [bp + 23], al
230:	

scanLongInt$61:	; parameter base, offset 7
231:		mov ax, [bp + 6]
232:		mov [bp + 24], ax
234:	

scanLongInt$62:	; call function noellipse-noellipse isDigitInBase
235:		mov word [bp + 17], scanLongInt$63
236:		mov [bp + 19], bp
237:		add bp, 17
238:		jmp @24$isDigitInBase
240:	

scanLongInt$63:	; post call
242:	

scanLongInt$64:	; £temporary1447 = return_value
247:	

scanLongInt$65:	; if £temporary1447 == 0 goto 82
248:		cmp bx, 0
249:		je scanLongInt$82
251:	

scanLongInt$66:	; £temporary1448 = int_to_int base (Signed_Int -> Signed_Long_Int)
252:		mov bx, [bp + 6]
254:		and ebx, 65535
256:		cmp bx, 0
257:		jge scanLongInt$67
258:		neg bx
260:		neg ebx
262:	

scanLongInt$67:	; longValue = longValue * £temporary1448
263:		mov eax, [bp + 8]
265:		xor edx, edx
266:		imul ebx
267:		mov [bp + 8], eax
269:	

scanLongInt$68:	; call header integral zero 0 stack zero 0
271:	

scanLongInt$69:	; parameter input, offset 6
272:		mov al, [bp + 16]
273:		mov [bp + 23], al
275:	

scanLongInt$70:	; call function noellipse-noellipse digitToValue
276:		mov word [bp + 17], scanLongInt$71
277:		mov [bp + 19], bp
278:		add bp, 17
279:		jmp @25$digitToValue
281:	

scanLongInt$71:	; post call
283:	

scanLongInt$72:	; £temporary1450 = return_value
288:	

scanLongInt$73:	; £temporary1451 = int_to_int £temporary1450 (Signed_Int -> Signed_Long_Int)
290:		and ebx, 65535
292:		cmp bx, 0
293:		jge scanLongInt$74
294:		neg bx
296:		neg ebx
298:	

scanLongInt$74:	; longValue = longValue + £temporary1451
299:		add [bp + 8], ebx
301:	

scanLongInt$75:	; call header integral zero 0 stack zero 0
303:	

scanLongInt$76:	; call function noellipse-noellipse scanChar
304:		mov word [bp + 17], scanLongInt$77
305:		mov [bp + 19], bp
306:		add bp, 17
307:		jmp scanChar
309:	

scanLongInt$77:	; post call
311:	

scanLongInt$78:	; £temporary1453 = return_value
316:	

scanLongInt$79:	; input = £temporary1453
317:		mov [bp + 16], bl
319:	

scanLongInt$80:	; found = 1
320:		mov word [bp + 14], 1
322:	

scanLongInt$81:	; goto 59
323:		jmp scanLongInt$59
325:	

scanLongInt$82:	; if minus == 0 goto 85
326:		cmp word [bp + 12], 0
327:		je scanLongInt$85
329:	

scanLongInt$83:	; £temporary1455 = -longValue
330:		mov eax, [bp + 8]
331:		neg eax
333:	

scanLongInt$84:	; longValue = £temporary1455
334:		mov [bp + 8], eax
336:	

scanLongInt$85:	; if found == 0 goto 87
337:		cmp word [bp + 14], 0
338:		je scanLongInt$87
340:	

scanLongInt$86:	; ++g_inCount
341:		inc word [g_inCount]
343:	

scanLongInt$87:	; call header integral zero 0 stack zero 0
345:	

scanLongInt$88:	; parameter input, offset 6
346:		mov al, [bp + 16]
347:		mov [bp + 23], al
349:	

scanLongInt$89:	; call function noellipse-noellipse unscanChar
350:		mov word [bp + 17], scanLongInt$90
351:		mov [bp + 19], bp
352:		add bp, 17
353:		jmp unscanChar
355:	

scanLongInt$90:	; post call
357:	

scanLongInt$91:	; return_value = longValue
358:		mov ebx, [bp + 8]
360:	

scanLongInt$92:	; return
361:		mov ax, [bp]
362:		mov di, [bp + 4]
363:		mov bp, [bp + 2]
364:		jmp ax
366:	

scanLongInt$93:	; function end scanLongInt
1:	

scanUnsignedLongInt:	; unsignedLongValue = 0
2:		mov dword [bp + 8], 0
4:	

scanUnsignedLongInt$1:	; call header integral zero 0 stack zero 0
6:	

scanUnsignedLongInt$2:	; call function noellipse-noellipse scanChar
7:		mov word [bp + 16], scanUnsignedLongInt$3
8:		mov [bp + 18], bp
9:		add bp, 16
10:		jmp scanChar
12:	

scanUnsignedLongInt$3:	; post call
14:	

scanUnsignedLongInt$4:	; £temporary1466 = return_value
19:	

scanUnsignedLongInt$5:	; input = £temporary1466
20:		mov [bp + 16], bl
22:	

scanUnsignedLongInt$6:	; found = 1
23:		mov word [bp + 17], 1
25:	

scanUnsignedLongInt$7:	; call header integral zero 0 stack zero 0
27:	

scanUnsignedLongInt$8:	; £temporary1467 = int_to_int input (Signed_Char -> Signed_Int)
28:		mov al, [bp + 16]
30:		and ax, 255
32:		cmp al, 0
33:		jge scanUnsignedLongInt$9
34:		neg al
36:		neg ax
38:	

scanUnsignedLongInt$9:	; parameter £temporary1467, offset 6
39:		mov [bp + 25], ax
41:	

scanUnsignedLongInt$10:	; call function noellipse-noellipse isspace
42:		mov word [bp + 19], scanUnsignedLongInt$11
43:		mov [bp + 21], bp
44:		add bp, 19
45:		jmp isspace
47:	

scanUnsignedLongInt$11:	; post call
49:	

scanUnsignedLongInt$12:	; £temporary1468 = return_value
54:	

scanUnsignedLongInt$13:	; if £temporary1468 == 0 goto 20
55:		cmp bx, 0
56:		je scanUnsignedLongInt$20
58:	

scanUnsignedLongInt$14:	; call header integral zero 0 stack zero 0
60:	

scanUnsignedLongInt$15:	; call function noellipse-noellipse scanChar
61:		mov word [bp + 19], scanUnsignedLongInt$16
62:		mov [bp + 21], bp
63:		add bp, 19
64:		jmp scanChar
66:	

scanUnsignedLongInt$16:	; post call
68:	

scanUnsignedLongInt$17:	; £temporary1469 = return_value
73:	

scanUnsignedLongInt$18:	; input = £temporary1469
74:		mov [bp + 16], bl
76:	

scanUnsignedLongInt$19:	; goto 7
77:		jmp scanUnsignedLongInt$7
79:	

scanUnsignedLongInt$20:	; if input != 43 goto 26
80:		cmp byte [bp + 16], 43
81:		jne scanUnsignedLongInt$26
83:	

scanUnsignedLongInt$21:	; call header integral zero 0 stack zero 0
85:	

scanUnsignedLongInt$22:	; call function noellipse-noellipse scanChar
86:		mov word [bp + 19], scanUnsignedLongInt$23
87:		mov [bp + 21], bp
88:		add bp, 19
89:		jmp scanChar
91:	

scanUnsignedLongInt$23:	; post call
93:	

scanUnsignedLongInt$24:	; £temporary1472 = return_value
98:	

scanUnsignedLongInt$25:	; input = £temporary1472
99:		mov [bp + 16], bl
101:	

scanUnsignedLongInt$26:	; if base != 0 goto 50
102:		cmp word [bp + 6], 0
103:		jne scanUnsignedLongInt$50
105:	

scanUnsignedLongInt$27:	; if input != 48 goto 49
106:		cmp byte [bp + 16], 48
107:		jne scanUnsignedLongInt$49
109:	

scanUnsignedLongInt$28:	; call header integral zero 0 stack zero 0
111:	

scanUnsignedLongInt$29:	; call function noellipse-noellipse scanChar
112:		mov word [bp + 19], scanUnsignedLongInt$30
113:		mov [bp + 21], bp
114:		add bp, 19
115:		jmp scanChar
117:	

scanUnsignedLongInt$30:	; post call
119:	

scanUnsignedLongInt$31:	; £temporary1475 = return_value
124:	

scanUnsignedLongInt$32:	; input = £temporary1475
125:		mov [bp + 16], bl
127:	

scanUnsignedLongInt$33:	; call header integral zero 0 stack zero 0
129:	

scanUnsignedLongInt$34:	; £temporary1476 = int_to_int input (Signed_Char -> Signed_Int)
130:		mov al, [bp + 16]
132:		and ax, 255
134:		cmp al, 0
135:		jge scanUnsignedLongInt$35
136:		neg al
138:		neg ax
140:	

scanUnsignedLongInt$35:	; parameter £temporary1476, offset 6
141:		mov [bp + 25], ax
143:	

scanUnsignedLongInt$36:	; call function noellipse-noellipse tolower
144:		mov word [bp + 19], scanUnsignedLongInt$37
145:		mov [bp + 21], bp
146:		add bp, 19
147:		jmp tolower
149:	

scanUnsignedLongInt$37:	; post call
151:	

scanUnsignedLongInt$38:	; £temporary1477 = return_value
156:	

scanUnsignedLongInt$39:	; if £temporary1477 != 120 goto 47
157:		cmp bx, 120
158:		jne scanUnsignedLongInt$47
160:	

scanUnsignedLongInt$40:	; base = 16
161:		mov word [bp + 6], 16
163:	

scanUnsignedLongInt$41:	; call header integral zero 0 stack zero 0
165:	

scanUnsignedLongInt$42:	; call function noellipse-noellipse scanChar
166:		mov word [bp + 19], scanUnsignedLongInt$43
167:		mov [bp + 21], bp
168:		add bp, 19
169:		jmp scanChar
171:	

scanUnsignedLongInt$43:	; post call
173:	

scanUnsignedLongInt$44:	; £temporary1479 = return_value
178:	

scanUnsignedLongInt$45:	; input = £temporary1479
179:		mov [bp + 16], bl
181:	

scanUnsignedLongInt$46:	; goto 50
182:		jmp scanUnsignedLongInt$50
184:	

scanUnsignedLongInt$47:	; base = 8
185:		mov word [bp + 6], 8
187:	

scanUnsignedLongInt$48:	; goto 50
188:		jmp scanUnsignedLongInt$50
190:	

scanUnsignedLongInt$49:	; base = 10
191:		mov word [bp + 6], 10
193:	

scanUnsignedLongInt$50:	; call header integral zero 0 stack zero 0
195:	

scanUnsignedLongInt$51:	; parameter input, offset 6
196:		mov al, [bp + 16]
197:		mov [bp + 25], al
199:	

scanUnsignedLongInt$52:	; parameter base, offset 7
200:		mov ax, [bp + 6]
201:		mov [bp + 26], ax
203:	

scanUnsignedLongInt$53:	; call function noellipse-noellipse isDigitInBase
204:		mov word [bp + 19], scanUnsignedLongInt$54
205:		mov [bp + 21], bp
206:		add bp, 19
207:		jmp @24$isDigitInBase
209:	

scanUnsignedLongInt$54:	; post call
211:	

scanUnsignedLongInt$55:	; £temporary1480 = return_value
216:	

scanUnsignedLongInt$56:	; if £temporary1480 == 0 goto 73
217:		cmp bx, 0
218:		je scanUnsignedLongInt$73
220:	

scanUnsignedLongInt$57:	; £temporary1481 = int_to_int base (Signed_Int -> Unsigned_Long_Int)
221:		mov bx, [bp + 6]
223:		and ebx, 65535
225:	

scanUnsignedLongInt$58:	; unsignedLongValue = unsignedLongValue * £temporary1481
226:		mov eax, [bp + 8]
228:		xor edx, edx
229:		mul ebx
230:		mov [bp + 8], eax
232:	

scanUnsignedLongInt$59:	; call header integral zero 0 stack zero 0
234:	

scanUnsignedLongInt$60:	; parameter input, offset 6
235:		mov al, [bp + 16]
236:		mov [bp + 25], al
238:	

scanUnsignedLongInt$61:	; call function noellipse-noellipse digitToValue
239:		mov word [bp + 19], scanUnsignedLongInt$62
240:		mov [bp + 21], bp
241:		add bp, 19
242:		jmp @25$digitToValue
244:	

scanUnsignedLongInt$62:	; post call
246:	

scanUnsignedLongInt$63:	; £temporary1483 = return_value
251:	

scanUnsignedLongInt$64:	; £temporary1484 = int_to_int £temporary1483 (Signed_Int -> Unsigned_Long_Int)
253:		and ebx, 65535
255:	

scanUnsignedLongInt$65:	; unsignedLongValue = unsignedLongValue + £temporary1484
256:		add [bp + 8], ebx
258:	

scanUnsignedLongInt$66:	; found = 1
259:		mov word [bp + 17], 1
261:	

scanUnsignedLongInt$67:	; call header integral zero 0 stack zero 0
263:	

scanUnsignedLongInt$68:	; call function noellipse-noellipse scanChar
264:		mov word [bp + 19], scanUnsignedLongInt$69
265:		mov [bp + 21], bp
266:		add bp, 19
267:		jmp scanChar
269:	

scanUnsignedLongInt$69:	; post call
271:	

scanUnsignedLongInt$70:	; £temporary1486 = return_value
276:	

scanUnsignedLongInt$71:	; input = £temporary1486
277:		mov [bp + 16], bl
279:	

scanUnsignedLongInt$72:	; goto 50
280:		jmp scanUnsignedLongInt$50
282:	

scanUnsignedLongInt$73:	; if found == 0 goto 75
283:		cmp word [bp + 17], 0
284:		je scanUnsignedLongInt$75
286:	

scanUnsignedLongInt$74:	; ++g_inCount
287:		inc word [g_inCount]
289:	

scanUnsignedLongInt$75:	; call header integral zero 0 stack zero 0
291:	

scanUnsignedLongInt$76:	; parameter input, offset 6
292:		mov al, [bp + 16]
293:		mov [bp + 25], al
295:	

scanUnsignedLongInt$77:	; call function noellipse-noellipse unscanChar
296:		mov word [bp + 19], scanUnsignedLongInt$78
297:		mov [bp + 21], bp
298:		add bp, 19
299:		jmp unscanChar
301:	

scanUnsignedLongInt$78:	; post call
303:	

scanUnsignedLongInt$79:	; return_value = unsignedLongValue
304:		mov ebx, [bp + 8]
306:	

scanUnsignedLongInt$80:	; return
307:		mov ax, [bp]
308:		mov di, [bp + 4]
309:		mov bp, [bp + 2]
310:		jmp ax
312:	

scanUnsignedLongInt$81:	; function end scanUnsignedLongInt
1:	

scanLongDouble:	; minus = 0
2:		mov word [bp + 6], 0
4:	

scanLongDouble$1:	; found = 0
5:		mov word [bp + 8], 0
7:	

scanLongDouble$2:	; push float 0.0
8:		fldz
10:	

scanLongDouble$3:	; pop float value
11:		fstp qword [bp + 10]
13:	

scanLongDouble$4:	; push float 1.0
14:		fld1
16:	

scanLongDouble$5:	; pop float factor
17:		fstp qword [bp + 18]
19:	

scanLongDouble$6:	; call header integral zero 0 stack zero 0
21:	

scanLongDouble$7:	; call function noellipse-noellipse scanChar
22:		mov word [bp + 26], scanLongDouble$8
23:		mov [bp + 28], bp
24:		add bp, 26
25:		jmp scanChar
27:	

scanLongDouble$8:	; post call
29:	

scanLongDouble$9:	; £temporary1497 = return_value
34:	

scanLongDouble$10:	; input = £temporary1497
35:		mov [bp + 26], bl
37:	

scanLongDouble$11:	; call header integral zero 0 stack zero 0
39:	

scanLongDouble$12:	; £temporary1498 = int_to_int input (Signed_Char -> Signed_Int)
40:		mov al, [bp + 26]
42:		and ax, 255
44:		cmp al, 0
45:		jge scanLongDouble$13
46:		neg al
48:		neg ax
50:	

scanLongDouble$13:	; parameter £temporary1498, offset 6
51:		mov [bp + 33], ax
53:	

scanLongDouble$14:	; call function noellipse-noellipse isspace
54:		mov word [bp + 27], scanLongDouble$15
55:		mov [bp + 29], bp
56:		add bp, 27
57:		jmp isspace
59:	

scanLongDouble$15:	; post call
61:	

scanLongDouble$16:	; £temporary1499 = return_value
66:	

scanLongDouble$17:	; if £temporary1499 == 0 goto 24
67:		cmp bx, 0
68:		je scanLongDouble$24
70:	

scanLongDouble$18:	; call header integral zero 0 stack zero 0
72:	

scanLongDouble$19:	; call function noellipse-noellipse scanChar
73:		mov word [bp + 27], scanLongDouble$20
74:		mov [bp + 29], bp
75:		add bp, 27
76:		jmp scanChar
78:	

scanLongDouble$20:	; post call
80:	

scanLongDouble$21:	; £temporary1500 = return_value
85:	

scanLongDouble$22:	; input = £temporary1500
86:		mov [bp + 26], bl
88:	

scanLongDouble$23:	; goto 11
89:		jmp scanLongDouble$11
91:	

scanLongDouble$24:	; if input != 43 goto 31
92:		cmp byte [bp + 26], 43
93:		jne scanLongDouble$31
95:	

scanLongDouble$25:	; call header integral zero 0 stack zero 0
97:	

scanLongDouble$26:	; call function noellipse-noellipse scanChar
98:		mov word [bp + 27], scanLongDouble$27
99:		mov [bp + 29], bp
100:		add bp, 27
101:		jmp scanChar
103:	

scanLongDouble$27:	; post call
105:	

scanLongDouble$28:	; £temporary1503 = return_value
110:	

scanLongDouble$29:	; input = £temporary1503
111:		mov [bp + 26], bl
113:	

scanLongDouble$30:	; goto 38
114:		jmp scanLongDouble$38
116:	

scanLongDouble$31:	; if input != 45 goto 38
117:		cmp byte [bp + 26], 45
118:		jne scanLongDouble$38
120:	

scanLongDouble$32:	; minus = 1
121:		mov word [bp + 6], 1
123:	

scanLongDouble$33:	; call header integral zero 0 stack zero 0
125:	

scanLongDouble$34:	; call function noellipse-noellipse scanChar
126:		mov word [bp + 27], scanLongDouble$35
127:		mov [bp + 29], bp
128:		add bp, 27
129:		jmp scanChar
131:	

scanLongDouble$35:	; post call
133:	

scanLongDouble$36:	; £temporary1505 = return_value
138:	

scanLongDouble$37:	; input = £temporary1505
139:		mov [bp + 26], bl
141:	

scanLongDouble$38:	; call header integral zero 0 stack zero 0
143:	

scanLongDouble$39:	; £temporary1506 = int_to_int input (Signed_Char -> Signed_Int)
144:		mov al, [bp + 26]
146:		and ax, 255
148:		cmp al, 0
149:		jge scanLongDouble$40
150:		neg al
152:		neg ax
154:	

scanLongDouble$40:	; parameter £temporary1506, offset 6
155:		mov [bp + 33], ax
157:	

scanLongDouble$41:	; call function noellipse-noellipse isdigit
158:		mov word [bp + 27], scanLongDouble$42
159:		mov [bp + 29], bp
160:		add bp, 27
161:		jmp isdigit
163:	

scanLongDouble$42:	; post call
165:	

scanLongDouble$43:	; £temporary1507 = return_value
170:	

scanLongDouble$44:	; if £temporary1507 == 0 goto 60
171:		cmp bx, 0
172:		je scanLongDouble$60
174:	

scanLongDouble$45:	; push float 10.0
175:		fld qword [float8$10.0#]
177:	

scanLongDouble$46:	; push float value
178:		fld qword [bp + 10]
180:	

scanLongDouble$47:	; £temporary1508 = 10.0 * value
181:		fmul
183:	

scanLongDouble$48:	; £temporary1509 = input - 48
184:		mov al, [bp + 26]
185:		sub al, 48
187:	

scanLongDouble$49:	; £temporary1511 = int_to_int £temporary1509 (Signed_Char -> Signed_Int)
189:		and ax, 255
191:		cmp al, 0
192:		jge scanLongDouble$50
193:		neg al
195:		neg ax
197:	

scanLongDouble$50:	; £temporary1510 = int_to_float £temporary1511 (Signed_Int -> Long_Double)
198:		mov [container2bytes#], ax
199:		fild word [container2bytes#]
201:	

scanLongDouble$51:	; £temporary1512 = £temporary1508 + £temporary1510
202:		fadd
204:	

scanLongDouble$52:	; pop float value
205:		fstp qword [bp + 10]
207:	

scanLongDouble$53:	; call header integral zero 0 stack zero 0
209:	

scanLongDouble$54:	; call function noellipse-noellipse scanChar
210:		mov word [bp + 27], scanLongDouble$55
211:		mov [bp + 29], bp
212:		add bp, 27
213:		jmp scanChar
215:	

scanLongDouble$55:	; post call
217:	

scanLongDouble$56:	; £temporary1513 = return_value
222:	

scanLongDouble$57:	; input = £temporary1513
223:		mov [bp + 26], bl
225:	

scanLongDouble$58:	; found = 1
226:		mov word [bp + 8], 1
228:	

scanLongDouble$59:	; goto 38
229:		jmp scanLongDouble$38
231:	

scanLongDouble$60:	; if input != 46 goto 92
232:		cmp byte [bp + 26], 46
233:		jne scanLongDouble$92
235:	

scanLongDouble$61:	; call header integral zero 0 stack zero 0
237:	

scanLongDouble$62:	; call function noellipse-noellipse scanChar
238:		mov word [bp + 27], scanLongDouble$63
239:		mov [bp + 29], bp
240:		add bp, 27
241:		jmp scanChar
243:	

scanLongDouble$63:	; post call
245:	

scanLongDouble$64:	; £temporary1516 = return_value
250:	

scanLongDouble$65:	; input = £temporary1516
251:		mov [bp + 26], bl
253:	

scanLongDouble$66:	; call header integral zero 0 stack zero 0
255:	

scanLongDouble$67:	; £temporary1517 = int_to_int input (Signed_Char -> Signed_Int)
256:		mov al, [bp + 26]
258:		and ax, 255
260:		cmp al, 0
261:		jge scanLongDouble$68
262:		neg al
264:		neg ax
266:	

scanLongDouble$68:	; parameter £temporary1517, offset 6
267:		mov [bp + 33], ax
269:	

scanLongDouble$69:	; call function noellipse-noellipse isdigit
270:		mov word [bp + 27], scanLongDouble$70
271:		mov [bp + 29], bp
272:		add bp, 27
273:		jmp isdigit
275:	

scanLongDouble$70:	; post call
277:	

scanLongDouble$71:	; £temporary1518 = return_value
282:	

scanLongDouble$72:	; if £temporary1518 == 0 goto 92
283:		cmp bx, 0
284:		je scanLongDouble$92
286:	

scanLongDouble$73:	; push float factor
287:		fld qword [bp + 18]
289:	

scanLongDouble$74:	; push float 10.0
290:		fld qword [float8$10.0#]
292:	

scanLongDouble$75:	; £temporary1519 = factor / 10.0
293:		fdiv
295:	

scanLongDouble$76:	; pop float factor
296:		fstp qword [bp + 18]
298:	

scanLongDouble$77:	; push float value
299:		fld qword [bp + 10]
301:	

scanLongDouble$78:	; push float factor
302:		fld qword [bp + 18]
304:	

scanLongDouble$79:	; £temporary1520 = input - 48
305:		mov al, [bp + 26]
306:		sub al, 48
308:	

scanLongDouble$80:	; £temporary1522 = int_to_int £temporary1520 (Signed_Char -> Signed_Int)
310:		and ax, 255
312:		cmp al, 0
313:		jge scanLongDouble$81
314:		neg al
316:		neg ax
318:	

scanLongDouble$81:	; £temporary1521 = int_to_float £temporary1522 (Signed_Int -> Long_Double)
319:		mov [container2bytes#], ax
320:		fild word [container2bytes#]
322:	

scanLongDouble$82:	; £temporary1523 = factor * £temporary1521
323:		fmul
325:	

scanLongDouble$83:	; £temporary1524 = value + £temporary1523
326:		fadd
328:	

scanLongDouble$84:	; pop float value
329:		fstp qword [bp + 10]
331:	

scanLongDouble$85:	; call header integral zero 0 stack zero 0
333:	

scanLongDouble$86:	; call function noellipse-noellipse scanChar
334:		mov word [bp + 27], scanLongDouble$87
335:		mov [bp + 29], bp
336:		add bp, 27
337:		jmp scanChar
339:	

scanLongDouble$87:	; post call
341:	

scanLongDouble$88:	; £temporary1525 = return_value
346:	

scanLongDouble$89:	; input = £temporary1525
347:		mov [bp + 26], bl
349:	

scanLongDouble$90:	; found = 1
350:		mov word [bp + 8], 1
352:	

scanLongDouble$91:	; goto 66
353:		jmp scanLongDouble$66
355:	

scanLongDouble$92:	; call header integral zero 0 stack zero 0
357:	

scanLongDouble$93:	; £temporary1527 = int_to_int input (Signed_Char -> Signed_Int)
358:		mov al, [bp + 26]
360:		and ax, 255
362:		cmp al, 0
363:		jge scanLongDouble$94
364:		neg al
366:		neg ax
368:	

scanLongDouble$94:	; parameter £temporary1527, offset 6
369:		mov [bp + 33], ax
371:	

scanLongDouble$95:	; call function noellipse-noellipse tolower
372:		mov word [bp + 27], scanLongDouble$96
373:		mov [bp + 29], bp
374:		add bp, 27
375:		jmp tolower
377:	

scanLongDouble$96:	; post call
379:	

scanLongDouble$97:	; £temporary1528 = return_value
384:	

scanLongDouble$98:	; if £temporary1528 != 101 goto 118
385:		cmp bx, 101
386:		jne scanLongDouble$118
388:	

scanLongDouble$99:	; call header integral zero 0 stack zero 0
390:	

scanLongDouble$100:	; parameter 10, offset 6
391:		mov word [bp + 33], 10
393:	

scanLongDouble$101:	; call function noellipse-noellipse scanLongInt
394:		mov word [bp + 27], scanLongDouble$102
395:		mov [bp + 29], bp
396:		add bp, 27
397:		jmp scanLongInt
399:	

scanLongDouble$102:	; post call
401:	

scanLongDouble$103:	; £temporary1530 = return_value
406:	

scanLongDouble$104:	; £temporary1531 = int_to_float £temporary1530 (Signed_Long_Int -> Double)
407:		mov [container4bytes#], ebx
408:		fild dword [container4bytes#]
410:	

scanLongDouble$105:	; pop float exponent
411:		fstp qword [bp + 27]
413:	

scanLongDouble$106:	; push float value
414:		fld qword [bp + 10]
416:	

scanLongDouble$107:	; call header integral zero 0 stack no zero 1
417:		fstp qword [bp + 35]
419:	

scanLongDouble$108:	; push float 10.0
420:		fld qword [float8$10.0#]
422:	

scanLongDouble$109:	; parameter 10.0, offset 6
423:		fstp qword [bp + 49]
425:	

scanLongDouble$110:	; push float exponent
426:		fld qword [bp + 27]
428:	

scanLongDouble$111:	; parameter exponent, offset 14
429:		fstp qword [bp + 57]
431:	

scanLongDouble$112:	; call function noellipse-noellipse pow
432:		mov word [bp + 43], scanLongDouble$113
433:		mov [bp + 45], bp
434:		add bp, 43
435:		jmp pow
437:	

scanLongDouble$113:	; post call
438:		fstp qword [bp + 43]
439:		fld qword [bp + 35]
440:		fld qword [bp + 43]
442:	

scanLongDouble$114:	; £temporary1532 = return_value
444:	

scanLongDouble$115:	; £temporary1533 = value * £temporary1532
445:		fmul
447:	

scanLongDouble$116:	; pop float value
448:		fstp qword [bp + 10]
450:	

scanLongDouble$117:	; goto 122
451:		jmp scanLongDouble$122
453:	

scanLongDouble$118:	; call header integral zero 0 stack zero 0
455:	

scanLongDouble$119:	; parameter input, offset 6
456:		mov al, [bp + 26]
457:		mov [bp + 33], al
459:	

scanLongDouble$120:	; call function noellipse-noellipse unscanChar
460:		mov word [bp + 27], scanLongDouble$121
461:		mov [bp + 29], bp
462:		add bp, 27
463:		jmp unscanChar
465:	

scanLongDouble$121:	; post call
467:	

scanLongDouble$122:	; if minus == 0 goto 126
468:		cmp word [bp + 6], 0
469:		je scanLongDouble$126
471:	

scanLongDouble$123:	; push float value
472:		fld qword [bp + 10]
474:	

scanLongDouble$124:	; £temporary1535 = -value
475:		fchs
477:	

scanLongDouble$125:	; pop float value
478:		fstp qword [bp + 10]
480:	

scanLongDouble$126:	; if found == 0 goto 128
481:		cmp word [bp + 8], 0
482:		je scanLongDouble$128
484:	

scanLongDouble$127:	; ++g_inCount
485:		inc word [g_inCount]
487:	

scanLongDouble$128:	; push float value
488:		fld qword [bp + 10]
490:	

scanLongDouble$129:	; return_value = value
492:	

scanLongDouble$130:	; return
493:		mov ax, [bp]
494:		mov di, [bp + 4]
495:		mov bp, [bp + 2]
496:		jmp ax
498:	

scanLongDouble$131:	; function end scanLongDouble
1:	

scanFormat:	; percent = 0
2:		mov word [bp + 13], 0
4:	

scanFormat$1:	; shortInt = 0
5:		mov word [bp + 15], 0
7:	

scanFormat$2:	; longIntOrDouble = 0
8:		mov word [bp + 17], 0
10:	

scanFormat$3:	; longDouble = 0
11:		mov word [bp + 19], 0
13:	

scanFormat$4:	; star = 0
14:		mov word [bp + 21], 0
16:	

scanFormat$5:	; g_inCount = 0
17:		mov word [g_inCount], 0
19:	

scanFormat$6:	; g_inChars = 0
20:		mov word [g_inChars], 0
22:	

scanFormat$7:	; index = 0
23:		mov word [bp + 31], 0
25:	

scanFormat$8:	; £temporary1548 = format + index
26:		mov si, [bp + 6]
27:		add si, [bp + 31]
29:	

scanFormat$9:	; £temporary1547 -> £temporary1548 = *£temporary1548
31:	

scanFormat$10:	; if £temporary1547 -> £temporary1548 == 0 goto 326
32:		cmp byte [si], 0
33:		je scanFormat$326
35:	

scanFormat$11:	; £temporary1552 = format + index
36:		mov si, [bp + 6]
37:		add si, [bp + 31]
39:	

scanFormat$12:	; £temporary1551 -> £temporary1552 = *£temporary1552
41:	

scanFormat$13:	; c = £temporary1551 -> £temporary1552
42:		mov al, [si]
43:		mov [bp + 10], al
45:	

scanFormat$14:	; £temporary1553 = int_to_int c (Signed_Char -> Signed_Int)
46:		mov al, [bp + 10]
48:		and ax, 255
50:		cmp al, 0
51:		jge scanFormat$15
52:		neg al
54:		neg ax
56:	

scanFormat$15:	; d = £temporary1553 + 1
57:		add ax, 1
58:		mov [bp + 55], ax
60:	

scanFormat$16:	; if percent == 0 goto 318
61:		cmp word [bp + 13], 0
62:		je scanFormat$318
64:	

scanFormat$17:	; £temporary1555 = d - 1
65:		mov ax, [bp + 55]
66:		sub ax, 1
68:	

scanFormat$18:	; case £temporary1555 == 104 goto 36
69:		cmp ax, 104
70:		je scanFormat$36
72:	

scanFormat$19:	; case £temporary1555 == 108 goto 38
73:		cmp ax, 108
74:		je scanFormat$38
76:	

scanFormat$20:	; case £temporary1555 == 76 goto 40
77:		cmp ax, 76
78:		je scanFormat$40
80:	

scanFormat$21:	; case £temporary1555 == 42 goto 42
81:		cmp ax, 42
82:		je scanFormat$42
84:	

scanFormat$22:	; case £temporary1555 == 99 goto 44
85:		cmp ax, 99
86:		je scanFormat$44
88:	

scanFormat$23:	; case £temporary1555 == 115 goto 62
89:		cmp ax, 115
90:		je scanFormat$62
92:	

scanFormat$24:	; case £temporary1555 == 100 goto 81
93:		cmp ax, 100
94:		je scanFormat$81
96:	

scanFormat$25:	; case £temporary1555 == 105 goto 81
97:		cmp ax, 105
98:		je scanFormat$81
100:	

scanFormat$26:	; case £temporary1555 == 111 goto 117
101:		cmp ax, 111
102:		je scanFormat$117
104:	

scanFormat$27:	; case £temporary1555 == 120 goto 153
105:		cmp ax, 120
106:		je scanFormat$153
108:	

scanFormat$28:	; case £temporary1555 == 117 goto 189
109:		cmp ax, 117
110:		je scanFormat$189
112:	

scanFormat$29:	; case £temporary1555 == 103 goto 225
113:		cmp ax, 103
114:		je scanFormat$225
116:	

scanFormat$30:	; case £temporary1555 == 102 goto 225
117:		cmp ax, 102
118:		je scanFormat$225
120:	

scanFormat$31:	; case £temporary1555 == 101 goto 225
121:		cmp ax, 101
122:		je scanFormat$225
124:	

scanFormat$32:	; case £temporary1555 == 91 goto 261
125:		cmp ax, 91
126:		je scanFormat$261
128:	

scanFormat$33:	; case £temporary1555 == 110 goto 302
129:		cmp ax, 110
130:		je scanFormat$302
132:	

scanFormat$34:	; case end £temporary1555
134:	

scanFormat$35:	; goto 311
135:		jmp scanFormat$311
137:	

scanFormat$36:	; shortInt = 1
138:		mov word [bp + 15], 1
140:	

scanFormat$37:	; goto 324
141:		jmp scanFormat$324
143:	

scanFormat$38:	; longIntOrDouble = 1
144:		mov word [bp + 17], 1
146:	

scanFormat$39:	; goto 324
147:		jmp scanFormat$324
149:	

scanFormat$40:	; longDouble = 1
150:		mov word [bp + 19], 1
152:	

scanFormat$41:	; goto 324
153:		jmp scanFormat$324
155:	

scanFormat$42:	; star = 1
156:		mov word [bp + 21], 1
158:	

scanFormat$43:	; goto 324
159:		jmp scanFormat$324
161:	

scanFormat$44:	; call header integral zero 0 stack zero 0
163:	

scanFormat$45:	; call function noellipse-noellipse scanChar
164:		mov word [bp + 57], scanFormat$46
165:		mov [bp + 59], bp
166:		add bp, 57
167:		jmp scanChar
169:	

scanFormat$46:	; post call
171:	

scanFormat$47:	; £temporary1556 = return_value
176:	

scanFormat$48:	; charValue = £temporary1556
177:		mov [bp + 57], bl
179:	

scanFormat$49:	; if star != 0 goto 57
180:		cmp word [bp + 21], 0
181:		jne scanFormat$57
183:	

scanFormat$50:	; arg_list = arg_list + 2
184:		add word [bp + 8], 2
186:	

scanFormat$51:	; £temporary1560 = arg_list - 2
187:		mov si, [bp + 8]
188:		sub si, 2
190:	

scanFormat$52:	; £temporary1561 = int_to_int £temporary1560 (Signed_Int -> Pointer)
193:	

scanFormat$53:	; £temporary1562 -> £temporary1561 = *£temporary1561
195:	

scanFormat$54:	; charPtr = £temporary1562 -> £temporary1561
196:		mov ax, [si]
197:		mov [bp + 11], ax
199:	

scanFormat$55:	; £temporary1563 -> charPtr = *charPtr
200:		mov si, [bp + 11]
202:	

scanFormat$56:	; £temporary1563 -> charPtr = charValue
203:		mov al, [bp + 57]
204:		mov [si], al
206:	

scanFormat$57:	; percent = 0
207:		mov word [bp + 13], 0
209:	

scanFormat$58:	; £temporary1564 = int_to_int charValue (Signed_Char -> Signed_Int)
210:		mov al, [bp + 57]
212:		and ax, 255
214:		cmp al, 0
215:		jge scanFormat$59
216:		neg al
218:		neg ax
220:	

scanFormat$59:	; if £temporary1564 == -1 goto 324
221:		cmp ax, -1
222:		je scanFormat$324
224:	

scanFormat$60:	; ++g_inCount
225:		inc word [g_inCount]
227:	

scanFormat$61:	; goto 324
228:		jmp scanFormat$324
230:	

scanFormat$62:	; if star != 0 goto 74
231:		cmp word [bp + 21], 0
232:		jne scanFormat$74
234:	

scanFormat$63:	; arg_list = arg_list + 2
235:		add word [bp + 8], 2
237:	

scanFormat$64:	; £temporary1570 = arg_list - 2
238:		mov si, [bp + 8]
239:		sub si, 2
241:	

scanFormat$65:	; £temporary1571 = int_to_int £temporary1570 (Signed_Int -> Pointer)
244:	

scanFormat$66:	; £temporary1572 -> £temporary1571 = *£temporary1571
246:	

scanFormat$67:	; charPtr = £temporary1572 -> £temporary1571
247:		mov ax, [si]
248:		mov [bp + 11], ax
250:	

scanFormat$68:	; call header integral zero 0 stack zero 0
252:	

scanFormat$69:	; parameter charPtr, offset 6
253:		mov ax, [bp + 11]
254:		mov [bp + 63], ax
256:	

scanFormat$70:	; parameter 0, offset 8
257:		mov word [bp + 65], 0
259:	

scanFormat$71:	; call function noellipse-noellipse scanString
260:		mov word [bp + 57], scanFormat$72
261:		mov [bp + 59], bp
262:		add bp, 57
263:		jmp scanString
265:	

scanFormat$72:	; post call
267:	

scanFormat$73:	; goto 79
268:		jmp scanFormat$79
270:	

scanFormat$74:	; call header integral zero 0 stack zero 0
272:	

scanFormat$75:	; parameter 0, offset 6
273:		mov word [bp + 63], 0
275:	

scanFormat$76:	; parameter 0, offset 8
276:		mov word [bp + 65], 0
278:	

scanFormat$77:	; call function noellipse-noellipse scanString
279:		mov word [bp + 57], scanFormat$78
280:		mov [bp + 59], bp
281:		add bp, 57
282:		jmp scanString
284:	

scanFormat$78:	; post call
286:	

scanFormat$79:	; percent = 0
287:		mov word [bp + 13], 0
289:	

scanFormat$80:	; goto 324
290:		jmp scanFormat$324
292:	

scanFormat$81:	; call header integral zero 0 stack zero 0
294:	

scanFormat$82:	; parameter 10, offset 6
295:		mov word [bp + 63], 10
297:	

scanFormat$83:	; call function noellipse-noellipse scanLongInt
298:		mov word [bp + 57], scanFormat$84
299:		mov [bp + 59], bp
300:		add bp, 57
301:		jmp scanLongInt
303:	

scanFormat$84:	; post call
305:	

scanFormat$85:	; £temporary1575 = return_value
310:	

scanFormat$86:	; longValue = £temporary1575
311:		mov [bp + 23], ebx
313:	

scanFormat$87:	; if star != 0 goto 115
314:		cmp word [bp + 21], 0
315:		jne scanFormat$115
317:	

scanFormat$88:	; if shortInt == 0 goto 98
318:		cmp word [bp + 15], 0
319:		je scanFormat$98
321:	

scanFormat$89:	; arg_list = arg_list + 2
322:		add word [bp + 8], 2
324:	

scanFormat$90:	; £temporary1579 = arg_list - 2
325:		mov si, [bp + 8]
326:		sub si, 2
328:	

scanFormat$91:	; £temporary1580 = int_to_int £temporary1579 (Signed_Int -> Pointer)
331:	

scanFormat$92:	; £temporary1581 -> £temporary1580 = *£temporary1580
333:	

scanFormat$93:	; shortPtr = £temporary1581 -> £temporary1580
334:		mov ax, [si]
335:		mov [bp + 29], ax
337:	

scanFormat$94:	; £temporary1582 -> shortPtr = *shortPtr
338:		mov si, [bp + 29]
340:	

scanFormat$95:	; £temporary1583 = int_to_int longValue (Signed_Long_Int -> Signed_Short_Int)
341:		mov eax, [bp + 23]
344:		cmp eax, 0
345:		jge scanFormat$96
346:		neg eax
348:		neg al
350:	

scanFormat$96:	; £temporary1582 -> shortPtr = £temporary1583
351:		mov [si], al
353:	

scanFormat$97:	; goto 115
354:		jmp scanFormat$115
356:	

scanFormat$98:	; if longIntOrDouble != 0 goto 108
357:		cmp word [bp + 17], 0
358:		jne scanFormat$108
360:	

scanFormat$99:	; arg_list = arg_list + 2
361:		add word [bp + 8], 2
363:	

scanFormat$100:	; £temporary1587 = arg_list - 2
364:		mov si, [bp + 8]
365:		sub si, 2
367:	

scanFormat$101:	; £temporary1588 = int_to_int £temporary1587 (Signed_Int -> Pointer)
370:	

scanFormat$102:	; £temporary1589 -> £temporary1588 = *£temporary1588
372:	

scanFormat$103:	; intPtr = £temporary1589 -> £temporary1588
373:		mov ax, [si]
374:		mov [bp + 33], ax
376:	

scanFormat$104:	; £temporary1590 -> intPtr = *intPtr
377:		mov si, [bp + 33]
379:	

scanFormat$105:	; £temporary1591 = int_to_int longValue (Signed_Long_Int -> Signed_Int)
380:		mov eax, [bp + 23]
383:		cmp eax, 0
384:		jge scanFormat$106
385:		neg eax
387:		neg ax
389:	

scanFormat$106:	; £temporary1590 -> intPtr = £temporary1591
390:		mov [si], ax
392:	

scanFormat$107:	; goto 115
393:		jmp scanFormat$115
395:	

scanFormat$108:	; arg_list = arg_list + 2
396:		add word [bp + 8], 2
398:	

scanFormat$109:	; £temporary1593 = arg_list - 2
399:		mov si, [bp + 8]
400:		sub si, 2
402:	

scanFormat$110:	; £temporary1594 = int_to_int £temporary1593 (Signed_Int -> Pointer)
405:	

scanFormat$111:	; £temporary1595 -> £temporary1594 = *£temporary1594
407:	

scanFormat$112:	; longPtr = £temporary1595 -> £temporary1594
408:		mov ax, [si]
409:		mov [bp + 27], ax
411:	

scanFormat$113:	; £temporary1596 -> longPtr = *longPtr
412:		mov si, [bp + 27]
414:	

scanFormat$114:	; £temporary1596 -> longPtr = longValue
415:		mov eax, [bp + 23]
416:		mov [si], eax
418:	

scanFormat$115:	; percent = 0
419:		mov word [bp + 13], 0
421:	

scanFormat$116:	; goto 324
422:		jmp scanFormat$324
424:	

scanFormat$117:	; call header integral zero 0 stack zero 0
426:	

scanFormat$118:	; parameter 8, offset 6
427:		mov word [bp + 63], 8
429:	

scanFormat$119:	; call function noellipse-noellipse scanUnsignedLongInt
430:		mov word [bp + 57], scanFormat$120
431:		mov [bp + 59], bp
432:		add bp, 57
433:		jmp scanUnsignedLongInt
435:	

scanFormat$120:	; post call
437:	

scanFormat$121:	; £temporary1598 = return_value
442:	

scanFormat$122:	; unsignedLongValue = £temporary1598
443:		mov [bp + 37], ebx
445:	

scanFormat$123:	; if star != 0 goto 151
446:		cmp word [bp + 21], 0
447:		jne scanFormat$151
449:	

scanFormat$124:	; if shortInt == 0 goto 134
450:		cmp word [bp + 15], 0
451:		je scanFormat$134
453:	

scanFormat$125:	; arg_list = arg_list + 2
454:		add word [bp + 8], 2
456:	

scanFormat$126:	; £temporary1602 = arg_list - 2
457:		mov si, [bp + 8]
458:		sub si, 2
460:	

scanFormat$127:	; £temporary1603 = int_to_int £temporary1602 (Signed_Int -> Pointer)
463:	

scanFormat$128:	; £temporary1604 -> £temporary1603 = *£temporary1603
465:	

scanFormat$129:	; unsignedShortPtr = £temporary1604 -> £temporary1603
466:		mov ax, [si]
467:		mov [bp + 43], ax
469:	

scanFormat$130:	; £temporary1605 -> unsignedShortPtr = *unsignedShortPtr
470:		mov si, [bp + 43]
472:	

scanFormat$131:	; £temporary1606 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
473:		mov eax, [bp + 37]
476:	

scanFormat$132:	; £temporary1605 -> unsignedShortPtr = £temporary1606
477:		mov [si], al
479:	

scanFormat$133:	; goto 151
480:		jmp scanFormat$151
482:	

scanFormat$134:	; if longIntOrDouble != 0 goto 144
483:		cmp word [bp + 17], 0
484:		jne scanFormat$144
486:	

scanFormat$135:	; arg_list = arg_list + 2
487:		add word [bp + 8], 2
489:	

scanFormat$136:	; £temporary1610 = arg_list - 2
490:		mov si, [bp + 8]
491:		sub si, 2
493:	

scanFormat$137:	; £temporary1611 = int_to_int £temporary1610 (Signed_Int -> Pointer)
496:	

scanFormat$138:	; £temporary1612 -> £temporary1611 = *£temporary1611
498:	

scanFormat$139:	; unsignedIntPtr = £temporary1612 -> £temporary1611
499:		mov ax, [si]
500:		mov [bp + 45], ax
502:	

scanFormat$140:	; £temporary1613 -> unsignedIntPtr = *unsignedIntPtr
503:		mov si, [bp + 45]
505:	

scanFormat$141:	; £temporary1614 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
506:		mov eax, [bp + 37]
509:	

scanFormat$142:	; £temporary1613 -> unsignedIntPtr = £temporary1614
510:		mov [si], ax
512:	

scanFormat$143:	; goto 151
513:		jmp scanFormat$151
515:	

scanFormat$144:	; arg_list = arg_list + 2
516:		add word [bp + 8], 2
518:	

scanFormat$145:	; £temporary1616 = arg_list - 2
519:		mov si, [bp + 8]
520:		sub si, 2
522:	

scanFormat$146:	; £temporary1617 = int_to_int £temporary1616 (Signed_Int -> Pointer)
525:	

scanFormat$147:	; £temporary1618 -> £temporary1617 = *£temporary1617
527:	

scanFormat$148:	; unsignedLongPtr = £temporary1618 -> £temporary1617
528:		mov ax, [si]
529:		mov [bp + 41], ax
531:	

scanFormat$149:	; £temporary1619 -> unsignedLongPtr = *unsignedLongPtr
532:		mov si, [bp + 41]
534:	

scanFormat$150:	; £temporary1619 -> unsignedLongPtr = unsignedLongValue
535:		mov eax, [bp + 37]
536:		mov [si], eax
538:	

scanFormat$151:	; percent = 0
539:		mov word [bp + 13], 0
541:	

scanFormat$152:	; goto 324
542:		jmp scanFormat$324
544:	

scanFormat$153:	; call header integral zero 0 stack zero 0
546:	

scanFormat$154:	; parameter 16, offset 6
547:		mov word [bp + 63], 16
549:	

scanFormat$155:	; call function noellipse-noellipse scanUnsignedLongInt
550:		mov word [bp + 57], scanFormat$156
551:		mov [bp + 59], bp
552:		add bp, 57
553:		jmp scanUnsignedLongInt
555:	

scanFormat$156:	; post call
557:	

scanFormat$157:	; £temporary1621 = return_value
562:	

scanFormat$158:	; unsignedLongValue = £temporary1621
563:		mov [bp + 37], ebx
565:	

scanFormat$159:	; if star != 0 goto 187
566:		cmp word [bp + 21], 0
567:		jne scanFormat$187
569:	

scanFormat$160:	; if shortInt == 0 goto 170
570:		cmp word [bp + 15], 0
571:		je scanFormat$170
573:	

scanFormat$161:	; arg_list = arg_list + 2
574:		add word [bp + 8], 2
576:	

scanFormat$162:	; £temporary1625 = arg_list - 2
577:		mov si, [bp + 8]
578:		sub si, 2
580:	

scanFormat$163:	; £temporary1626 = int_to_int £temporary1625 (Signed_Int -> Pointer)
583:	

scanFormat$164:	; £temporary1627 -> £temporary1626 = *£temporary1626
585:	

scanFormat$165:	; unsignedShortPtr = £temporary1627 -> £temporary1626
586:		mov ax, [si]
587:		mov [bp + 43], ax
589:	

scanFormat$166:	; £temporary1628 -> unsignedShortPtr = *unsignedShortPtr
590:		mov si, [bp + 43]
592:	

scanFormat$167:	; £temporary1629 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
593:		mov eax, [bp + 37]
596:	

scanFormat$168:	; £temporary1628 -> unsignedShortPtr = £temporary1629
597:		mov [si], al
599:	

scanFormat$169:	; goto 187
600:		jmp scanFormat$187
602:	

scanFormat$170:	; if longIntOrDouble != 0 goto 180
603:		cmp word [bp + 17], 0
604:		jne scanFormat$180
606:	

scanFormat$171:	; arg_list = arg_list + 2
607:		add word [bp + 8], 2
609:	

scanFormat$172:	; £temporary1633 = arg_list - 2
610:		mov si, [bp + 8]
611:		sub si, 2
613:	

scanFormat$173:	; £temporary1634 = int_to_int £temporary1633 (Signed_Int -> Pointer)
616:	

scanFormat$174:	; £temporary1635 -> £temporary1634 = *£temporary1634
618:	

scanFormat$175:	; unsignedIntPtr = £temporary1635 -> £temporary1634
619:		mov ax, [si]
620:		mov [bp + 45], ax
622:	

scanFormat$176:	; £temporary1636 -> unsignedIntPtr = *unsignedIntPtr
623:		mov si, [bp + 45]
625:	

scanFormat$177:	; £temporary1637 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
626:		mov eax, [bp + 37]
629:	

scanFormat$178:	; £temporary1636 -> unsignedIntPtr = £temporary1637
630:		mov [si], ax
632:	

scanFormat$179:	; goto 187
633:		jmp scanFormat$187
635:	

scanFormat$180:	; arg_list = arg_list + 2
636:		add word [bp + 8], 2
638:	

scanFormat$181:	; £temporary1639 = arg_list - 2
639:		mov si, [bp + 8]
640:		sub si, 2
642:	

scanFormat$182:	; £temporary1640 = int_to_int £temporary1639 (Signed_Int -> Pointer)
645:	

scanFormat$183:	; £temporary1641 -> £temporary1640 = *£temporary1640
647:	

scanFormat$184:	; unsignedLongPtr = £temporary1641 -> £temporary1640
648:		mov ax, [si]
649:		mov [bp + 41], ax
651:	

scanFormat$185:	; £temporary1642 -> unsignedLongPtr = *unsignedLongPtr
652:		mov si, [bp + 41]
654:	

scanFormat$186:	; £temporary1642 -> unsignedLongPtr = unsignedLongValue
655:		mov eax, [bp + 37]
656:		mov [si], eax
658:	

scanFormat$187:	; percent = 0
659:		mov word [bp + 13], 0
661:	

scanFormat$188:	; goto 324
662:		jmp scanFormat$324
664:	

scanFormat$189:	; call header integral zero 0 stack zero 0
666:	

scanFormat$190:	; parameter 0, offset 6
667:		mov word [bp + 63], 0
669:	

scanFormat$191:	; call function noellipse-noellipse scanUnsignedLongInt
670:		mov word [bp + 57], scanFormat$192
671:		mov [bp + 59], bp
672:		add bp, 57
673:		jmp scanUnsignedLongInt
675:	

scanFormat$192:	; post call
677:	

scanFormat$193:	; £temporary1644 = return_value
682:	

scanFormat$194:	; unsignedLongValue = £temporary1644
683:		mov [bp + 37], ebx
685:	

scanFormat$195:	; if star != 0 goto 223
686:		cmp word [bp + 21], 0
687:		jne scanFormat$223
689:	

scanFormat$196:	; if shortInt == 0 goto 206
690:		cmp word [bp + 15], 0
691:		je scanFormat$206
693:	

scanFormat$197:	; arg_list = arg_list + 2
694:		add word [bp + 8], 2
696:	

scanFormat$198:	; £temporary1648 = arg_list - 2
697:		mov si, [bp + 8]
698:		sub si, 2
700:	

scanFormat$199:	; £temporary1649 = int_to_int £temporary1648 (Signed_Int -> Pointer)
703:	

scanFormat$200:	; £temporary1650 -> £temporary1649 = *£temporary1649
705:	

scanFormat$201:	; unsignedShortPtr = £temporary1650 -> £temporary1649
706:		mov ax, [si]
707:		mov [bp + 43], ax
709:	

scanFormat$202:	; £temporary1651 -> unsignedShortPtr = *unsignedShortPtr
710:		mov si, [bp + 43]
712:	

scanFormat$203:	; £temporary1652 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Short_Int)
713:		mov eax, [bp + 37]
716:	

scanFormat$204:	; £temporary1651 -> unsignedShortPtr = £temporary1652
717:		mov [si], al
719:	

scanFormat$205:	; goto 223
720:		jmp scanFormat$223
722:	

scanFormat$206:	; if longIntOrDouble != 0 goto 216
723:		cmp word [bp + 17], 0
724:		jne scanFormat$216
726:	

scanFormat$207:	; arg_list = arg_list + 2
727:		add word [bp + 8], 2
729:	

scanFormat$208:	; £temporary1656 = arg_list - 2
730:		mov si, [bp + 8]
731:		sub si, 2
733:	

scanFormat$209:	; £temporary1657 = int_to_int £temporary1656 (Signed_Int -> Pointer)
736:	

scanFormat$210:	; £temporary1658 -> £temporary1657 = *£temporary1657
738:	

scanFormat$211:	; unsignedIntPtr = £temporary1658 -> £temporary1657
739:		mov ax, [si]
740:		mov [bp + 45], ax
742:	

scanFormat$212:	; £temporary1659 -> unsignedIntPtr = *unsignedIntPtr
743:		mov si, [bp + 45]
745:	

scanFormat$213:	; £temporary1660 = int_to_int unsignedLongValue (Unsigned_Long_Int -> Signed_Int)
746:		mov eax, [bp + 37]
749:	

scanFormat$214:	; £temporary1659 -> unsignedIntPtr = £temporary1660
750:		mov [si], ax
752:	

scanFormat$215:	; goto 223
753:		jmp scanFormat$223
755:	

scanFormat$216:	; arg_list = arg_list + 2
756:		add word [bp + 8], 2
758:	

scanFormat$217:	; £temporary1662 = arg_list - 2
759:		mov si, [bp + 8]
760:		sub si, 2
762:	

scanFormat$218:	; £temporary1663 = int_to_int £temporary1662 (Signed_Int -> Pointer)
765:	

scanFormat$219:	; £temporary1664 -> £temporary1663 = *£temporary1663
767:	

scanFormat$220:	; unsignedLongPtr = £temporary1664 -> £temporary1663
768:		mov ax, [si]
769:		mov [bp + 41], ax
771:	

scanFormat$221:	; £temporary1665 -> unsignedLongPtr = *unsignedLongPtr
772:		mov si, [bp + 41]
774:	

scanFormat$222:	; £temporary1665 -> unsignedLongPtr = unsignedLongValue
775:		mov eax, [bp + 37]
776:		mov [si], eax
778:	

scanFormat$223:	; percent = 0
779:		mov word [bp + 13], 0
781:	

scanFormat$224:	; goto 324
782:		jmp scanFormat$324
784:	

scanFormat$225:	; call header integral zero 0 stack zero 0
786:	

scanFormat$226:	; call function noellipse-noellipse scanLongDouble
787:		mov word [bp + 57], scanFormat$227
788:		mov [bp + 59], bp
789:		add bp, 57
790:		jmp scanLongDouble
792:	

scanFormat$227:	; post call
794:	

scanFormat$228:	; £temporary1667 = return_value
796:	

scanFormat$229:	; pop float longDoubleValue
797:		fstp qword [bp + 47]
799:	

scanFormat$230:	; if star != 0 goto 259
800:		cmp word [bp + 21], 0
801:		jne scanFormat$259
803:	

scanFormat$231:	; if longIntOrDouble == 0 goto 241
804:		cmp word [bp + 17], 0
805:		je scanFormat$241
807:	

scanFormat$232:	; arg_list = arg_list + 2
808:		add word [bp + 8], 2
810:	

scanFormat$233:	; £temporary1671 = arg_list - 2
811:		mov si, [bp + 8]
812:		sub si, 2
814:	

scanFormat$234:	; £temporary1672 = int_to_int £temporary1671 (Signed_Int -> Pointer)
817:	

scanFormat$235:	; £temporary1673 -> £temporary1672 = *£temporary1672
819:	

scanFormat$236:	; doublePtr = £temporary1673 -> £temporary1672
820:		mov ax, [si]
821:		mov [bp + 57], ax
823:	

scanFormat$237:	; £temporary1674 -> doublePtr = *doublePtr
824:		mov si, [bp + 57]
826:	

scanFormat$238:	; push float longDoubleValue
827:		fld qword [bp + 47]
829:	

scanFormat$239:	; pop float £temporary1674 -> doublePtr
830:		fstp qword [si]
832:	

scanFormat$240:	; goto 259
833:		jmp scanFormat$259
835:	

scanFormat$241:	; if longDouble == 0 goto 251
836:		cmp word [bp + 19], 0
837:		je scanFormat$251
839:	

scanFormat$242:	; arg_list = arg_list + 2
840:		add word [bp + 8], 2
842:	

scanFormat$243:	; £temporary1677 = arg_list - 2
843:		mov si, [bp + 8]
844:		sub si, 2
846:	

scanFormat$244:	; £temporary1678 = int_to_int £temporary1677 (Signed_Int -> Pointer)
849:	

scanFormat$245:	; £temporary1679 -> £temporary1678 = *£temporary1678
851:	

scanFormat$246:	; longDoublePtr = £temporary1679 -> £temporary1678
852:		mov ax, [si]
853:		mov [bp + 57], ax
855:	

scanFormat$247:	; £temporary1680 -> longDoublePtr = *longDoublePtr
856:		mov si, [bp + 57]
858:	

scanFormat$248:	; push float longDoubleValue
859:		fld qword [bp + 47]
861:	

scanFormat$249:	; pop float £temporary1680 -> longDoublePtr
862:		fstp qword [si]
864:	

scanFormat$250:	; goto 259
865:		jmp scanFormat$259
867:	

scanFormat$251:	; arg_list = arg_list + 2
868:		add word [bp + 8], 2
870:	

scanFormat$252:	; £temporary1682 = arg_list - 2
871:		mov si, [bp + 8]
872:		sub si, 2
874:	

scanFormat$253:	; £temporary1683 = int_to_int £temporary1682 (Signed_Int -> Pointer)
877:	

scanFormat$254:	; £temporary1684 -> £temporary1683 = *£temporary1683
879:	

scanFormat$255:	; floatPtr = £temporary1684 -> £temporary1683
880:		mov ax, [si]
881:		mov [bp + 57], ax
883:	

scanFormat$256:	; £temporary1685 -> floatPtr = *floatPtr
884:		mov si, [bp + 57]
886:	

scanFormat$257:	; push float longDoubleValue
887:		fld qword [bp + 47]
889:	

scanFormat$258:	; pop float £temporary1685 -> floatPtr
890:		fstp dword [si]
892:	

scanFormat$259:	; percent = 0
893:		mov word [bp + 13], 0
895:	

scanFormat$260:	; goto 324
896:		jmp scanFormat$324
898:	

scanFormat$261:	; not = 0
899:		mov word [bp + 57], 0
901:	

scanFormat$262:	; ++index
902:		inc word [bp + 31]
904:	

scanFormat$263:	; £temporary1691 = format + index
905:		mov si, [bp + 6]
906:		add si, [bp + 31]
908:	

scanFormat$264:	; £temporary1690 -> £temporary1691 = *£temporary1691
910:	

scanFormat$265:	; if £temporary1690 -> £temporary1691 != 94 goto 268
911:		cmp byte [si], 94
912:		jne scanFormat$268
914:	

scanFormat$266:	; not = 1
915:		mov word [bp + 57], 1
917:	

scanFormat$267:	; startIndex = index + 1
918:		mov ax, [bp + 31]
919:		add ax, 1
920:		mov [bp + 59], ax
922:	

scanFormat$268:	; £temporary1695 = format + index
923:		mov si, [bp + 6]
924:		add si, [bp + 31]
926:	

scanFormat$269:	; £temporary1694 -> £temporary1695 = *£temporary1695
928:	

scanFormat$270:	; if £temporary1694 -> £temporary1695 == 93 goto 273
929:		cmp byte [si], 93
930:		je scanFormat$273
932:	

scanFormat$271:	; ++index
933:		inc word [bp + 31]
935:	

scanFormat$272:	; goto 268
936:		jmp scanFormat$268
938:	

scanFormat$273:	; £temporary1699 = format + index
939:		mov si, [bp + 6]
940:		add si, [bp + 31]
942:	

scanFormat$274:	; £temporary1698 -> £temporary1699 = *£temporary1699
944:	

scanFormat$275:	; £temporary1698 -> £temporary1699 = 0
945:		mov byte [si], 0
947:	

scanFormat$276:	; if star != 0 goto 292
948:		cmp word [bp + 21], 0
949:		jne scanFormat$292
951:	

scanFormat$277:	; arg_list = arg_list + 2
952:		add word [bp + 8], 2
954:	

scanFormat$278:	; £temporary1703 = arg_list - 2
955:		mov si, [bp + 8]
956:		sub si, 2
958:	

scanFormat$279:	; £temporary1704 = int_to_int £temporary1703 (Signed_Int -> Pointer)
961:	

scanFormat$280:	; £temporary1705 -> £temporary1704 = *£temporary1704
963:	

scanFormat$281:	; string = £temporary1705 -> £temporary1704
964:		mov ax, [si]
965:		mov [bp + 61], ax
967:	

scanFormat$282:	; call header integral zero 0 stack zero 0
969:	

scanFormat$283:	; parameter string, offset 6
970:		mov ax, [bp + 61]
971:		mov [bp + 69], ax
973:	

scanFormat$284:	; £temporary1707 = format + startIndex
974:		mov si, [bp + 6]
975:		add si, [bp + 59]
977:	

scanFormat$285:	; £temporary1706 -> £temporary1707 = *£temporary1707
979:	

scanFormat$286:	; £temporary1708 = &£temporary1706 -> £temporary1707
981:	

scanFormat$287:	; parameter £temporary1708, offset 8
982:		mov [bp + 71], si
984:	

scanFormat$288:	; parameter not, offset 10
985:		mov ax, [bp + 57]
986:		mov [bp + 73], ax
988:	

scanFormat$289:	; call function noellipse-noellipse scanPattern
989:		mov word [bp + 63], scanFormat$290
990:		mov [bp + 65], bp
991:		add bp, 63
992:		jmp scanPattern
994:	

scanFormat$290:	; post call
996:	

scanFormat$291:	; goto 324
997:		jmp scanFormat$324
999:	

scanFormat$292:	; call header integral zero 0 stack zero 0
1001:	

scanFormat$293:	; parameter 0, offset 6
1002:		mov word [bp + 67], 0
1004:	

scanFormat$294:	; £temporary1711 = format + startIndex
1005:		mov si, [bp + 6]
1006:		add si, [bp + 59]
1008:	

scanFormat$295:	; £temporary1710 -> £temporary1711 = *£temporary1711
1010:	

scanFormat$296:	; £temporary1712 = &£temporary1710 -> £temporary1711
1012:	

scanFormat$297:	; parameter £temporary1712, offset 8
1013:		mov [bp + 69], si
1015:	

scanFormat$298:	; parameter not, offset 10
1016:		mov ax, [bp + 57]
1017:		mov [bp + 71], ax
1019:	

scanFormat$299:	; call function noellipse-noellipse scanPattern
1020:		mov word [bp + 61], scanFormat$300
1021:		mov [bp + 63], bp
1022:		add bp, 61
1023:		jmp scanPattern
1025:	

scanFormat$300:	; post call
1027:	

scanFormat$301:	; goto 324
1028:		jmp scanFormat$324
1030:	

scanFormat$302:	; arg_list = arg_list + 2
1031:		add word [bp + 8], 2
1033:	

scanFormat$303:	; £temporary1715 = arg_list - 2
1034:		mov si, [bp + 8]
1035:		sub si, 2
1037:	

scanFormat$304:	; £temporary1716 = int_to_int £temporary1715 (Signed_Int -> Pointer)
1040:	

scanFormat$305:	; £temporary1717 -> £temporary1716 = *£temporary1716
1042:	

scanFormat$306:	; charsPtr = £temporary1717 -> £temporary1716
1043:		mov ax, [si]
1044:		mov [bp + 35], ax
1046:	

scanFormat$307:	; £temporary1718 -> charsPtr = *charsPtr
1047:		mov si, [bp + 35]
1049:	

scanFormat$308:	; £temporary1718 -> charsPtr = g_inChars
1050:		mov ax, [g_inChars]
1051:		mov [si], ax
1053:	

scanFormat$309:	; percent = 0
1054:		mov word [bp + 13], 0
1056:	

scanFormat$310:	; goto 324
1057:		jmp scanFormat$324
1059:	

scanFormat$311:	; call header integral zero 0 stack zero 0
1061:	

scanFormat$312:	; parameter string_scanFormat20c203D202725c270A#, offset 6
1062:		mov word [bp + 63], string_scanFormat20c203D202725c270A#
1064:	

scanFormat$313:	; £temporary1719 = int_to_int c (Signed_Char -> Signed_Int)
1065:		mov al, [bp + 10]
1067:		and ax, 255
1069:		cmp al, 0
1070:		jge scanFormat$314
1071:		neg al
1073:		neg ax
1075:	

scanFormat$314:	; parameter £temporary1719, offset 8
1076:		mov [bp + 65], ax
1078:	

scanFormat$315:	; call function noellipse-ellipse printf, extra 0
1079:		mov word [bp + 57], scanFormat$316
1080:		mov [bp + 59], bp
1081:		add bp, 57
1082:		mov di, bp
1083:		add di, 2
1084:		jmp printf
1086:	

scanFormat$316:	; post call
1088:	

scanFormat$317:	; goto 324
1089:		jmp scanFormat$324
1091:	

scanFormat$318:	; if c != 37 goto 324
1092:		cmp byte [bp + 10], 37
1093:		jne scanFormat$324
1095:	

scanFormat$319:	; percent = 1
1096:		mov word [bp + 13], 1
1098:	

scanFormat$320:	; shortInt = 0
1099:		mov word [bp + 15], 0
1101:	

scanFormat$321:	; longIntOrDouble = 0
1102:		mov word [bp + 17], 0
1104:	

scanFormat$322:	; longDouble = 0
1105:		mov word [bp + 19], 0
1107:	

scanFormat$323:	; star = 0
1108:		mov word [bp + 21], 0
1110:	

scanFormat$324:	; ++index
1111:		inc word [bp + 31]
1113:	

scanFormat$325:	; goto 8
1114:		jmp scanFormat$8
1116:	

scanFormat$326:	; return_value = g_inCount
1117:		mov bx, [g_inCount]
1119:	

scanFormat$327:	; return
1120:		mov ax, [bp]
1121:		mov di, [bp + 4]
1122:		mov bp, [bp + 2]
1123:		jmp ax
1125:	

scanFormat$328:	; function end scanFormat
1:	

scanf:	; £temporary1739 = &format
2:		mov si, bp
3:		add si, 6
5:	

scanf$1:	; £temporary1740 = int_to_int £temporary1739 (Pointer -> Pointer)
8:	

scanf$2:	; arg_list = £temporary1740 + 2
9:		add si, 2
10:		mov [di + 8], si
12:	

scanf$3:	; call header integral zero 0 stack zero 0
14:	

scanf$4:	; parameter format, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 16], ax
18:	

scanf$5:	; parameter arg_list, offset 8
19:		mov ax, [di + 8]
20:		mov [di + 18], ax
22:	

scanf$6:	; call function ellipse-noellipse vscanf
23:		mov word [di + 10], scanf$7
24:		mov [di + 12], bp
25:		mov [di + 14], di
26:		add di, 10
27:		mov bp, di
28:		jmp vscanf
30:	

scanf$7:	; post call
32:	

scanf$8:	; £temporary1742 = return_value
37:	

scanf$9:	; return_value = £temporary1742
39:	

scanf$10:	; return
40:		mov ax, [bp]
41:		mov di, [bp + 4]
42:		mov bp, [bp + 2]
43:		jmp ax
45:	

scanf$11:	; function end scanf
1:	

vscanf:	; call header integral zero 0 stack zero 0
3:	

vscanf$1:	; parameter stdin, offset 6
4:		mov ax, [stdin]
5:		mov [bp + 16], ax
7:	

vscanf$2:	; parameter format, offset 8
8:		mov ax, [bp + 6]
9:		mov [bp + 18], ax
11:	

vscanf$3:	; parameter arg_list, offset 10
12:		mov ax, [bp + 8]
13:		mov [bp + 20], ax
15:	

vscanf$4:	; call function noellipse-noellipse vfscanf
16:		mov word [bp + 10], vscanf$5
17:		mov [bp + 12], bp
18:		add bp, 10
19:		jmp vfscanf
21:	

vscanf$5:	; post call
23:	

vscanf$6:	; £temporary1746 = return_value
28:	

vscanf$7:	; return_value = £temporary1746
30:	

vscanf$8:	; return
31:		mov ax, [bp]
32:		mov di, [bp + 4]
33:		mov bp, [bp + 2]
34:		jmp ax
36:	

vscanf$9:	; function end vscanf
1:	

fscanf:	; £temporary1750 = &format
2:		mov si, bp
3:		add si, 8
5:	

fscanf$1:	; £temporary1751 = int_to_int £temporary1750 (Pointer -> Pointer)
8:	

fscanf$2:	; arg_list = £temporary1751 + 2
9:		add si, 2
10:		mov [di + 10], si
12:	

fscanf$3:	; call header integral zero 0 stack zero 0
14:	

fscanf$4:	; parameter inStream, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 18], ax
18:	

fscanf$5:	; parameter format, offset 8
19:		mov ax, [bp + 8]
20:		mov [di + 20], ax
22:	

fscanf$6:	; parameter arg_list, offset 10
23:		mov ax, [di + 10]
24:		mov [di + 22], ax
26:	

fscanf$7:	; call function ellipse-noellipse vfscanf
27:		mov word [di + 12], fscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vfscanf
34:	

fscanf$8:	; post call
36:	

fscanf$9:	; £temporary1753 = return_value
41:	

fscanf$10:	; return_value = £temporary1753
43:	

fscanf$11:	; return
44:		mov ax, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp ax
49:	

fscanf$12:	; function end fscanf
1:	

vfscanf:	; g_inStatus = 0
2:		mov word [g_inStatus], 0
4:	

vfscanf$1:	; £temporary1758 = int_to_int inStream (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vfscanf$2:	; g_inDevice = £temporary1758
9:		mov [g_inDevice], ax
11:	

vfscanf$3:	; call header integral zero 0 stack zero 0
13:	

vfscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vfscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vfscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vfscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vfscanf$7:	; post call
29:	

vfscanf$8:	; £temporary1759 = return_value
34:	

vfscanf$9:	; return_value = £temporary1759
36:	

vfscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vfscanf$11:	; function end vfscanf
1:	

sscanf:	; £temporary1762 = &format
2:		mov si, bp
3:		add si, 8
5:	

sscanf$1:	; £temporary1763 = int_to_int £temporary1762 (Pointer -> Pointer)
8:	

sscanf$2:	; arg_list = £temporary1763 + 2
9:		add si, 2
10:		mov [di + 10], si
12:	

sscanf$3:	; call header integral zero 0 stack zero 0
14:	

sscanf$4:	; parameter inString, offset 6
15:		mov ax, [bp + 6]
16:		mov [di + 18], ax
18:	

sscanf$5:	; parameter format, offset 8
19:		mov ax, [bp + 8]
20:		mov [di + 20], ax
22:	

sscanf$6:	; parameter arg_list, offset 10
23:		mov ax, [di + 10]
24:		mov [di + 22], ax
26:	

sscanf$7:	; call function ellipse-noellipse vsscanf
27:		mov word [di + 12], sscanf$8
28:		mov [di + 14], bp
29:		mov [di + 16], di
30:		add di, 12
31:		mov bp, di
32:		jmp vsscanf
34:	

sscanf$8:	; post call
36:	

sscanf$9:	; £temporary1765 = return_value
41:	

sscanf$10:	; return_value = £temporary1765
43:	

sscanf$11:	; return
44:		mov ax, [bp]
45:		mov di, [bp + 4]
46:		mov bp, [bp + 2]
47:		jmp ax
49:	

sscanf$12:	; function end sscanf
1:	

vsscanf:	; g_inStatus = 1
2:		mov word [g_inStatus], 1
4:	

vsscanf$1:	; £temporary1770 = int_to_int inString (Pointer -> Pointer)
5:		mov ax, [bp + 6]
8:	

vsscanf$2:	; g_inDevice = £temporary1770
9:		mov [g_inDevice], ax
11:	

vsscanf$3:	; call header integral zero 0 stack zero 0
13:	

vsscanf$4:	; parameter format, offset 6
14:		mov ax, [bp + 8]
15:		mov [bp + 18], ax
17:	

vsscanf$5:	; parameter arg_list, offset 8
18:		mov ax, [bp + 10]
19:		mov [bp + 20], ax
21:	

vsscanf$6:	; call function noellipse-noellipse scanFormat
22:		mov word [bp + 12], vsscanf$7
23:		mov [bp + 14], bp
24:		add bp, 12
25:		jmp scanFormat
27:	

vsscanf$7:	; post call
29:	

vsscanf$8:	; £temporary1771 = return_value
34:	

vsscanf$9:	; return_value = £temporary1771
36:	

vsscanf$10:	; return
37:		mov ax, [bp]
38:		mov di, [bp + 4]
39:		mov bp, [bp + 2]
40:		jmp ax
42:	

vsscanf$11:	; function end vsscanf
