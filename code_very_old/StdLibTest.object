1:	

compare:	; £temporary5942 = int_to_int valuePtr1 (Pointer -> Pointer)
2:		mov si, [bp + 6]
5:	

compare$1:	; £temporary5943 -> £temporary5942 = *£temporary5942
7:	

compare$2:	; intValue1 = £temporary5943 -> £temporary5942
8:		mov ax, [si]
9:		mov [bp + 10], ax
11:	

compare$3:	; £temporary5944 = int_to_int valuePtr2 (Pointer -> Pointer)
12:		mov si, [bp + 8]
15:	

compare$4:	; £temporary5945 -> £temporary5944 = *£temporary5944
17:	

compare$5:	; intValue2 = £temporary5945 -> £temporary5944
18:		mov ax, [si]
19:		mov [bp + 12], ax
21:	

compare$6:	; if intValue1 >= intValue2 goto 9
22:		mov ax, [bp + 12]
23:		cmp [bp + 10], ax
24:		jge compare$9
26:	

compare$7:	; £temporary5955 = -1
27:		mov bx, -1
29:	

compare$8:	; goto 14
30:		jmp compare$14
32:	

compare$9:	; if intValue1 != intValue2 goto 12
33:		mov ax, [bp + 12]
34:		cmp [bp + 10], ax
35:		jne compare$12
37:	

compare$10:	; £temporary5951 = 0
38:		mov bx, 0
40:	

compare$11:	; goto 13
41:		jmp compare$13
43:	

compare$12:	; £temporary5951 = 1
44:		mov bx, 1
46:	

compare$13:	; £temporary5955 = £temporary5951
48:	

compare$14:	; return_value = £temporary5955
50:	

compare$15:	; return
51:		mov ax, [bp]
52:		mov di, [bp + 4]
53:		mov bp, [bp + 2]
54:		jmp ax
56:	

compare$16:	; function end compare
1:	

reverse_compare:	; £temporary5956 = int_to_int valuePtr1 (Pointer -> Pointer)
2:		mov si, [bp + 6]
5:	

reverse_compare$1:	; £temporary5957 -> £temporary5956 = *£temporary5956
7:	

reverse_compare$2:	; intValue1 = £temporary5957 -> £temporary5956
8:		mov ax, [si]
9:		mov [bp + 10], ax
11:	

reverse_compare$3:	; £temporary5958 = int_to_int valuePtr2 (Pointer -> Pointer)
12:		mov si, [bp + 8]
15:	

reverse_compare$4:	; £temporary5959 -> £temporary5958 = *£temporary5958
17:	

reverse_compare$5:	; intValue2 = £temporary5959 -> £temporary5958
18:		mov ax, [si]
19:		mov [bp + 12], ax
21:	

reverse_compare$6:	; if intValue1 >= intValue2 goto 9
22:		mov ax, [bp + 12]
23:		cmp [bp + 10], ax
24:		jge reverse_compare$9
26:	

reverse_compare$7:	; £temporary5969 = 1
27:		mov bx, 1
29:	

reverse_compare$8:	; goto 14
30:		jmp reverse_compare$14
32:	

reverse_compare$9:	; if intValue1 != intValue2 goto 12
33:		mov ax, [bp + 12]
34:		cmp [bp + 10], ax
35:		jne reverse_compare$12
37:	

reverse_compare$10:	; £temporary5965 = 0
38:		mov bx, 0
40:	

reverse_compare$11:	; goto 13
41:		jmp reverse_compare$13
43:	

reverse_compare$12:	; £temporary5965 = -1
44:		mov bx, -1
46:	

reverse_compare$13:	; £temporary5969 = £temporary5965
48:	

reverse_compare$14:	; return_value = £temporary5969
50:	

reverse_compare$15:	; return
51:		mov ax, [bp]
52:		mov di, [bp + 4]
53:		mov bp, [bp + 2]
54:		jmp ax
56:	

reverse_compare$16:	; function end reverse_compare
1:	

print_div:	; call header integral zero 0 stack zero 0
3:	

print_div$1:	; parameter string_div_t20quot2025i20rem2025i0A#, offset 6
4:		mov word [bp + 16], string_div_t20quot2025i20rem2025i0A#
6:	

print_div$2:	; parameter d$quot, offset 8
7:		mov ax, [bp + 6]
8:		mov [bp + 18], ax
10:	

print_div$3:	; parameter d$rem, offset 10
11:		mov ax, [bp + 8]
12:		mov [bp + 20], ax
14:	

print_div$4:	; call function noellipse-ellipse printf, extra 0
15:		mov word [bp + 10], print_div$5
16:		mov [bp + 12], bp
17:		add bp, 10
18:		mov di, bp
19:		add di, 4
20:		jmp printf
22:	

print_div$5:	; post call
24:	

print_div$6:	; return
25:		mov ax, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp ax
30:	

print_div$7:	; function end print_div
1:	

print_ldiv:	; call header integral zero 0 stack zero 0
3:	

print_ldiv$1:	; parameter string_ldiv_t20quot2025li20rem2025li0A#, offset 6
4:		mov word [bp + 20], string_ldiv_t20quot2025li20rem2025li0A#
6:	

print_ldiv$2:	; parameter ld$quot, offset 8
7:		mov eax, [bp + 6]
8:		mov [bp + 22], eax
10:	

print_ldiv$3:	; parameter ld$rem, offset 12
11:		mov eax, [bp + 10]
12:		mov [bp + 26], eax
14:	

print_ldiv$4:	; call function noellipse-ellipse printf, extra 0
15:		mov word [bp + 14], print_ldiv$5
16:		mov [bp + 16], bp
17:		add bp, 14
18:		mov di, bp
19:		add di, 8
20:		jmp printf
22:	

print_ldiv$5:	; post call
24:	

print_ldiv$6:	; return
25:		mov ax, [bp]
26:		mov di, [bp + 4]
27:		mov bp, [bp + 2]
28:		jmp ax
30:	

print_ldiv$7:	; function end print_ldiv
1:	

exit_handle1x:	; call header integral zero 0 stack zero 0
3:	

exit_handle1x$1:	; parameter string_exit10A#, offset 6
4:		mov word [bp + 12], string_exit10A#
6:	

exit_handle1x$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 6], exit_handle1x$3
8:		mov [bp + 8], bp
9:		add bp, 6
10:		mov di, bp
11:		jmp printf
13:	

exit_handle1x$3:	; post call
15:	

exit_handle1x$4:	; return
16:		mov ax, [bp]
17:		mov di, [bp + 4]
18:		mov bp, [bp + 2]
19:		jmp ax
21:	

exit_handle1x$5:	; function end exit_handle1x
1:	

exit_handle2x:	; call header integral zero 0 stack zero 0
3:	

exit_handle2x$1:	; parameter string_exit20A#, offset 6
4:		mov word [bp + 12], string_exit20A#
6:	

exit_handle2x$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 6], exit_handle2x$3
8:		mov [bp + 8], bp
9:		add bp, 6
10:		mov di, bp
11:		jmp printf
13:	

exit_handle2x$3:	; post call
15:	

exit_handle2x$4:	; return
16:		mov ax, [bp]
17:		mov di, [bp + 4]
18:		mov bp, [bp + 2]
19:		jmp ax
21:	

exit_handle2x$5:	; function end exit_handle2x
1:	

exit_handle3x:	; call header integral zero 0 stack zero 0
3:	

exit_handle3x$1:	; parameter string_exit30A#, offset 6
4:		mov word [bp + 12], string_exit30A#
6:	

exit_handle3x$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 6], exit_handle3x$3
8:		mov [bp + 8], bp
9:		add bp, 6
10:		mov di, bp
11:		jmp printf
13:	

exit_handle3x$3:	; post call
15:	

exit_handle3x$4:	; return
16:		mov ax, [bp]
17:		mov di, [bp + 4]
18:		mov bp, [bp + 2]
19:		jmp ax
21:	

exit_handle3x$5:	; function end exit_handle3x
1:	

hello:	; call header integral zero 0 stack zero 0
3:	

hello$1:	; parameter string_HelloFFF#, offset 6
4:		mov word [bp + 12], string_HelloFFF#
6:	

hello$2:	; call function noellipse-ellipse printf, extra 0
7:		mov word [bp + 6], hello$3
8:		mov [bp + 8], bp
9:		add bp, 6
10:		mov di, bp
11:		jmp printf
13:	

hello$3:	; post call
15:	

hello$4:	; return
16:		mov ax, [bp]
17:		mov di, [bp + 4]
18:		mov bp, [bp + 2]
19:		jmp ax
21:	

hello$5:	; function end hello
1:	

qtest:	; call header integral zero 0 stack zero 0
3:	

qtest$1:	; parameter string_f3A2025u0A#, offset 6
4:		mov word [bp + 14], string_f3A2025u0A#
6:	

qtest$2:	; £temporary5990 = int_to_int f (Pointer -> Unsigned_Int)
7:		mov ax, [bp + 6]
10:	

qtest$3:	; parameter £temporary5990, offset 8
11:		mov [bp + 16], ax
13:	

qtest$4:	; call function noellipse-ellipse printf, extra 0
14:		mov word [bp + 8], qtest$5
15:		mov [bp + 10], bp
16:		add bp, 8
17:		mov di, bp
18:		add di, 2
19:		jmp printf
21:	

qtest$5:	; post call
23:	

qtest$6:	; call header integral zero 0 stack zero 0
25:	

qtest$7:	; call function noellipse-noellipse f
26:		mov word [bp + 8], qtest$8
27:		mov [bp + 10], bp
28:		mov ax, [bp + 6]
29:		add bp, 8
30:		jmp ax
32:	

qtest$8:	; post call
34:	

qtest$9:	; return
35:		mov ax, [bp]
36:		mov di, [bp + 4]
37:		mov bp, [bp + 2]
38:		jmp ax
40:	

qtest$10:	; function end qtest
1:	

stdlib_testZ:	; call header integral zero 0 stack zero 0
3:	

stdlib_testZ$1:	; parameter string_hello3A2025u0A#, offset 6
4:		mov word [bp + 12], string_hello3A2025u0A#
6:	

stdlib_testZ$2:	; £temporary5995 = int_to_int hello (Function -> Unsigned_Int)
7:		mov ax, hello
10:	

stdlib_testZ$3:	; parameter £temporary5995, offset 8
11:		mov [bp + 14], ax
13:	

stdlib_testZ$4:	; call function noellipse-ellipse printf, extra 0
14:		mov word [bp + 6], stdlib_testZ$5
15:		mov [bp + 8], bp
16:		add bp, 6
17:		mov di, bp
18:		add di, 2
19:		jmp printf
21:	

stdlib_testZ$5:	; post call
23:	

stdlib_testZ$6:	; call header integral zero 0 stack zero 0
25:	

stdlib_testZ$7:	; parameter hello, offset 6
26:		mov word [bp + 12], hello
28:	

stdlib_testZ$8:	; call function noellipse-noellipse qtest
29:		mov word [bp + 6], stdlib_testZ$9
30:		mov [bp + 8], bp
31:		add bp, 6
32:		jmp qtest
34:	

stdlib_testZ$9:	; post call
36:	

stdlib_testZ$10:	; call header integral zero 0 stack zero 0
38:	

stdlib_testZ$11:	; parameter string_Y#, offset 6
39:		mov word [bp + 12], string_Y#
41:	

stdlib_testZ$12:	; call function noellipse-ellipse printf, extra 0
42:		mov word [bp + 6], stdlib_testZ$13
43:		mov [bp + 8], bp
44:		add bp, 6
45:		mov di, bp
46:		jmp printf
48:	

stdlib_testZ$13:	; post call
50:	

stdlib_testZ$14:	; return
51:		mov ax, [bp]
52:		mov di, [bp + 4]
53:		mov bp, [bp + 2]
54:		jmp ax
56:	

stdlib_testZ$15:	; function end stdlib_testZ
1:	

stdlib_test:	; call header integral zero 0 stack zero 0
3:	

stdlib_test$1:	; parameter string_atof28221232E4562229203D2025f0A#, offset 6
4:		mov word [bp + 14], string_atof28221232E4562229203D2025f0A#
6:	

stdlib_test$2:	; call header integral zero 0 stack zero 0
8:	

stdlib_test$3:	; parameter string_1232E456#, offset 14
9:		mov word [bp + 22], string_1232E456#
11:	

stdlib_test$4:	; call function noellipse-noellipse atof
12:		mov word [bp + 16], stdlib_test$5
13:		mov [bp + 18], bp
14:		add bp, 16
15:		jmp atof
17:	

stdlib_test$5:	; post call
19:	

stdlib_test$6:	; £temporary6003 = return_value
21:	

stdlib_test$7:	; parameter £temporary6003, offset 8
22:		fstp qword [bp + 16]
24:	

stdlib_test$8:	; call function noellipse-ellipse printf, extra 0
25:		mov word [bp + 8], stdlib_test$9
26:		mov [bp + 10], bp
27:		add bp, 8
28:		mov di, bp
29:		add di, 8
30:		jmp printf
32:	

stdlib_test$9:	; post call
34:	

stdlib_test$10:	; call header integral zero 0 stack zero 0
36:	

stdlib_test$11:	; parameter string_strtod28221232E456789abc222C2026p29203D202825f2C2025s290A#, offset 6
37:		mov word [bp + 14], string_strtod28221232E456789abc222C2026p29203D202825f2C2025s290A#
39:	

stdlib_test$12:	; call header integral zero 0 stack zero 0
41:	

stdlib_test$13:	; parameter string_1232E456789abc#, offset 14
42:		mov word [bp + 22], string_1232E456789abc#
44:	

stdlib_test$14:	; £temporary6005 = &p
45:		mov si, bp
46:		add si, 6
48:	

stdlib_test$15:	; parameter £temporary6005, offset 16
49:		mov [bp + 24], si
51:	

stdlib_test$16:	; call function noellipse-noellipse strtod
52:		mov word [bp + 16], stdlib_test$17
53:		mov [bp + 18], bp
54:		add bp, 16
55:		jmp strtod
57:	

stdlib_test$17:	; post call
59:	

stdlib_test$18:	; £temporary6006 = return_value
61:	

stdlib_test$19:	; parameter £temporary6006, offset 8
62:		fstp qword [bp + 16]
64:	

stdlib_test$20:	; parameter p, offset 16
65:		mov ax, [bp + 6]
66:		mov [bp + 24], ax
68:	

stdlib_test$21:	; call function noellipse-ellipse printf, extra 0
69:		mov word [bp + 8], stdlib_test$22
70:		mov [bp + 10], bp
71:		add bp, 8
72:		mov di, bp
73:		add di, 10
74:		jmp printf
76:	

stdlib_test$22:	; post call
78:	

stdlib_test$23:	; call header integral zero 0 stack zero 0
80:	

stdlib_test$24:	; parameter string_0Agetenv2822path2229203D2025s0A#, offset 6
81:		mov word [bp + 12], string_0Agetenv2822path2229203D2025s0A#
83:	

stdlib_test$25:	; call header integral zero 0 stack zero 0
85:	

stdlib_test$26:	; parameter string_path#, offset 14
86:		mov word [bp + 20], string_path#
88:	

stdlib_test$27:	; call function noellipse-noellipse getenv
89:		mov word [bp + 14], stdlib_test$28
90:		mov [bp + 16], bp
91:		add bp, 14
92:		jmp getenv
94:	

stdlib_test$28:	; post call
96:	

stdlib_test$29:	; £temporary6008 = return_value
101:	

stdlib_test$30:	; parameter £temporary6008, offset 8
102:		mov [bp + 14], bx
104:	

stdlib_test$31:	; call function noellipse-ellipse printf, extra 0
105:		mov word [bp + 6], stdlib_test$32
106:		mov [bp + 8], bp
107:		add bp, 6
108:		mov di, bp
109:		add di, 2
110:		jmp printf
112:	

stdlib_test$32:	; post call
114:	

stdlib_test$33:	; call header integral zero 0 stack zero 0
116:	

stdlib_test$34:	; parameter string_system2822dir22290A#, offset 6
117:		mov word [bp + 12], string_system2822dir22290A#
119:	

stdlib_test$35:	; call function noellipse-ellipse printf, extra 0
120:		mov word [bp + 6], stdlib_test$36
121:		mov [bp + 8], bp
122:		add bp, 6
123:		mov di, bp
124:		jmp printf
126:	

stdlib_test$36:	; post call
128:	

stdlib_test$37:	; call header integral zero 0 stack zero 0
130:	

stdlib_test$38:	; parameter string_dir#, offset 6
131:		mov word [bp + 12], string_dir#
133:	

stdlib_test$39:	; call function noellipse-noellipse system
134:		mov word [bp + 6], stdlib_test$40
135:		mov [bp + 8], bp
136:		add bp, 6
137:		jmp system
139:	

stdlib_test$40:	; post call
141:	

stdlib_test$41:	; call header integral zero 0 stack zero 0
143:	

stdlib_test$42:	; parameter string_0Aabs282D329203D2025i2C20abs28329203D2025i0A#, offset 6
144:		mov word [bp + 12], string_0Aabs282D329203D2025i2C20abs28329203D2025i0A#
146:	

stdlib_test$43:	; call header integral zero 0 stack zero 0
148:	

stdlib_test$44:	; parameter -3, offset 14
149:		mov word [bp + 20], -3
151:	

stdlib_test$45:	; call function noellipse-noellipse _abs
152:		mov word [bp + 14], stdlib_test$46
153:		mov [bp + 16], bp
154:		add bp, 14
155:		jmp _abs
157:	

stdlib_test$46:	; post call
159:	

stdlib_test$47:	; £temporary6012 = return_value
164:	

stdlib_test$48:	; parameter £temporary6012, offset 8
165:		mov [bp + 14], bx
167:	

stdlib_test$49:	; call header integral zero 0 stack zero 0
169:	

stdlib_test$50:	; parameter 3, offset 16
170:		mov word [bp + 22], 3
172:	

stdlib_test$51:	; call function noellipse-noellipse _abs
173:		mov word [bp + 16], stdlib_test$52
174:		mov [bp + 18], bp
175:		add bp, 16
176:		jmp _abs
178:	

stdlib_test$52:	; post call
180:	

stdlib_test$53:	; £temporary6013 = return_value
185:	

stdlib_test$54:	; parameter £temporary6013, offset 10
186:		mov [bp + 16], bx
188:	

stdlib_test$55:	; call function noellipse-ellipse printf, extra 0
189:		mov word [bp + 6], stdlib_test$56
190:		mov [bp + 8], bp
191:		add bp, 6
192:		mov di, bp
193:		add di, 4
194:		jmp printf
196:	

stdlib_test$56:	; post call
198:	

stdlib_test$57:	; call header integral zero 0 stack zero 0
200:	

stdlib_test$58:	; parameter string_labs282D3l29203D2025li2C20labs283l29203D2025li0A0A#, offset 6
201:		mov word [bp + 12], string_labs282D3l29203D2025li2C20labs283l29203D2025li0A0A#
203:	

stdlib_test$59:	; call header integral zero 0 stack zero 0
205:	

stdlib_test$60:	; parameter -3, offset 14
206:		mov dword [bp + 20], -3
208:	

stdlib_test$61:	; call function noellipse-noellipse labs
209:		mov word [bp + 14], stdlib_test$62
210:		mov [bp + 16], bp
211:		add bp, 14
212:		jmp labs
214:	

stdlib_test$62:	; post call
216:	

stdlib_test$63:	; £temporary6015 = return_value
221:	

stdlib_test$64:	; parameter £temporary6015, offset 8
222:		mov [bp + 14], ebx
224:	

stdlib_test$65:	; call header integral zero 0 stack zero 0
226:	

stdlib_test$66:	; parameter 3, offset 18
227:		mov dword [bp + 24], 3
229:	

stdlib_test$67:	; call function noellipse-noellipse labs
230:		mov word [bp + 18], stdlib_test$68
231:		mov [bp + 20], bp
232:		add bp, 18
233:		jmp labs
235:	

stdlib_test$68:	; post call
237:	

stdlib_test$69:	; £temporary6016 = return_value
242:	

stdlib_test$70:	; parameter £temporary6016, offset 12
243:		mov [bp + 18], ebx
245:	

stdlib_test$71:	; call function noellipse-ellipse printf, extra 0
246:		mov word [bp + 6], stdlib_test$72
247:		mov [bp + 8], bp
248:		add bp, 6
249:		mov di, bp
250:		add di, 8
251:		jmp printf
253:	

stdlib_test$72:	; post call
255:	

stdlib_test$73:	; call header integral zero 0 stack zero 0
257:	

stdlib_test$74:	; parameter 10, offset 6
258:		mov word [bp + 12], 10
260:	

stdlib_test$75:	; parameter 3, offset 8
261:		mov word [bp + 14], 3
263:	

stdlib_test$76:	; call function noellipse-noellipse div
264:		mov word [bp + 6], stdlib_test$77
265:		mov [bp + 8], bp
266:		add bp, 6
267:		jmp div
269:	

stdlib_test$77:	; post call
271:	

stdlib_test$78:	; £temporary6018 -> £temporary6019 = return_value
273:	

stdlib_test$79:	; i = £temporary6018 -> £temporary6019
274:		mov si, bp
275:		add si, 6
276:		mov al, 4
277:	

stdlib_test$79$Loop:
278:		mov ah, [bx]
279:		mov [si], ah
280:		inc bx
281:		inc si
282:		dec al
283:		cmp al, 0
284:		jne stdlib_test$79$Loop
286:	

stdlib_test$80:	; call header integral zero 0 stack zero 0
288:	

stdlib_test$81:	; parameter string_div_t28102C20329203D202825i2C2025i292C0A#, offset 6
289:		mov word [bp + 16], string_div_t28102C20329203D202825i2C2025i292C0A#
291:	

stdlib_test$82:	; parameter i$quot, offset 8
292:		mov ax, [bp + 6]
293:		mov [bp + 18], ax
295:	

stdlib_test$83:	; parameter i$rem, offset 10
296:		mov ax, [bp + 8]
297:		mov [bp + 20], ax
299:	

stdlib_test$84:	; call function noellipse-ellipse printf, extra 0
300:		mov word [bp + 10], stdlib_test$85
301:		mov [bp + 12], bp
302:		add bp, 10
303:		mov di, bp
304:		add di, 4
305:		jmp printf
307:	

stdlib_test$85:	; post call
309:	

stdlib_test$86:	; call header integral zero 0 stack zero 0
311:	

stdlib_test$87:	; parameter i, offset 6
312:		mov si, bp
313:		add si, 6
314:		mov di, bp
315:		add di, 16
316:		mov al, 4
317:	

stdlib_test$87$Loop:
318:		mov ah, [si]
319:		mov [di], ah
320:		inc si
321:		inc di
322:		dec al
323:		cmp al, 0
324:		jne stdlib_test$87$Loop
326:	

stdlib_test$88:	; call function noellipse-noellipse print_div
327:		mov word [bp + 10], stdlib_test$89
328:		mov [bp + 12], bp
329:		add bp, 10
330:		jmp print_div
332:	

stdlib_test$89:	; post call
334:	

stdlib_test$90:	; call header integral zero 0 stack zero 0
336:	

stdlib_test$91:	; parameter 10, offset 6
337:		mov dword [bp + 12], 10
339:	

stdlib_test$92:	; parameter 3, offset 10
340:		mov dword [bp + 16], 3
342:	

stdlib_test$93:	; call function noellipse-noellipse ldiv
343:		mov word [bp + 6], stdlib_test$94
344:		mov [bp + 8], bp
345:		add bp, 6
346:		jmp ldiv
348:	

stdlib_test$94:	; post call
350:	

stdlib_test$95:	; £temporary6024 -> £temporary6025 = return_value
352:	

stdlib_test$96:	; li = £temporary6024 -> £temporary6025
353:		mov si, bp
354:		add si, 6
355:		mov al, 8
356:	

stdlib_test$96$Loop:
357:		mov ah, [bx]
358:		mov [si], ah
359:		inc bx
360:		inc si
361:		dec al
362:		cmp al, 0
363:		jne stdlib_test$96$Loop
365:	

stdlib_test$97:	; call header integral zero 0 stack zero 0
367:	

stdlib_test$98:	; parameter string_ldiv_t28102C20329203D202825li2C2025li290A#, offset 6
368:		mov word [bp + 20], string_ldiv_t28102C20329203D202825li2C2025li290A#
370:	

stdlib_test$99:	; parameter li$quot, offset 8
371:		mov eax, [bp + 6]
372:		mov [bp + 22], eax
374:	

stdlib_test$100:	; parameter li$rem, offset 12
375:		mov eax, [bp + 10]
376:		mov [bp + 26], eax
378:	

stdlib_test$101:	; call function noellipse-ellipse printf, extra 0
379:		mov word [bp + 14], stdlib_test$102
380:		mov [bp + 16], bp
381:		add bp, 14
382:		mov di, bp
383:		add di, 8
384:		jmp printf
386:	

stdlib_test$102:	; post call
388:	

stdlib_test$103:	; call header integral zero 0 stack zero 0
390:	

stdlib_test$104:	; parameter li, offset 6
391:		mov si, bp
392:		add si, 6
393:		mov di, bp
394:		add di, 20
395:		mov al, 8
396:	

stdlib_test$104$Loop:
397:		mov ah, [si]
398:		mov [di], ah
399:		inc si
400:		inc di
401:		dec al
402:		cmp al, 0
403:		jne stdlib_test$104$Loop
405:	

stdlib_test$105:	; call function noellipse-noellipse print_ldiv
406:		mov word [bp + 14], stdlib_test$106
407:		mov [bp + 16], bp
408:		add bp, 14
409:		jmp print_ldiv
411:	

stdlib_test$106:	; post call
413:	

stdlib_test$107:	; list[0] = 3
414:		mov word [bp + 6], 3
416:	

stdlib_test$108:	; list[1] = 4
417:		mov word [bp + 8], 4
419:	

stdlib_test$109:	; list[2] = 2
420:		mov word [bp + 10], 2
422:	

stdlib_test$110:	; list[3] = 1
423:		mov word [bp + 12], 1
425:	

stdlib_test$111:	; size = 4
426:		mov word [bp + 14], 4
428:	

stdlib_test$112:	; call header integral zero 0 stack zero 0
430:	

stdlib_test$113:	; parameter string_0AA20List2013A20#, offset 6
431:		mov word [bp + 24], string_0AA20List2013A20#
433:	

stdlib_test$114:	; call function noellipse-ellipse printf, extra 0
434:		mov word [bp + 18], stdlib_test$115
435:		mov [bp + 20], bp
436:		add bp, 18
437:		mov di, bp
438:		jmp printf
440:	

stdlib_test$115:	; post call
442:	

stdlib_test$116:	; index = 0
443:		mov word [bp + 16], 0
445:	

stdlib_test$117:	; if index >= size goto 128
446:		mov ax, [bp + 14]
447:		cmp [bp + 16], ax
448:		jge stdlib_test$128
450:	

stdlib_test$118:	; call header integral zero 0 stack zero 0
452:	

stdlib_test$119:	; parameter string_25i20#, offset 6
453:		mov word [bp + 24], string_25i20#
455:	

stdlib_test$120:	; £temporary6038 = index * 2
456:		mov ax, [bp + 16]
458:		xor dx, dx
459:		mul word [int2$2#]
465:	

stdlib_test$121:	; £temporary6039 = list + £temporary6038
466:		mov si, bp
467:		add si, 6
468:		add si, ax
470:	

stdlib_test$122:	; £temporary6040 -> £temporary6039 = *£temporary6039
472:	

stdlib_test$123:	; parameter £temporary6040 -> £temporary6039, offset 8
473:		mov ax, [si]
474:		mov [bp + 26], ax
476:	

stdlib_test$124:	; call function noellipse-ellipse printf, extra 0
477:		mov word [bp + 18], stdlib_test$125
478:		mov [bp + 20], bp
479:		add bp, 18
480:		mov di, bp
481:		add di, 2
482:		jmp printf
484:	

stdlib_test$125:	; post call
486:	

stdlib_test$126:	; ++index
487:		inc word [bp + 16]
489:	

stdlib_test$127:	; goto 117
490:		jmp stdlib_test$117
492:	

stdlib_test$128:	; call header integral zero 0 stack zero 0
494:	

stdlib_test$129:	; parameter string_0AB20List2023A20#, offset 6
495:		mov word [bp + 24], string_0AB20List2023A20#
497:	

stdlib_test$130:	; call function noellipse-ellipse printf, extra 0
498:		mov word [bp + 18], stdlib_test$131
499:		mov [bp + 20], bp
500:		add bp, 18
501:		mov di, bp
502:		jmp printf
504:	

stdlib_test$131:	; post call
506:	

stdlib_test$132:	; call header integral zero 0 stack zero 0
508:	

stdlib_test$133:	; parameter list, offset 6
509:		mov [bp + 24], bp
510:		add word [bp + 24], 6
512:	

stdlib_test$134:	; parameter size, offset 8
513:		mov ax, [bp + 14]
514:		mov [bp + 26], ax
516:	

stdlib_test$135:	; parameter 2, offset 10
517:		mov word [bp + 28], 2
519:	

stdlib_test$136:	; parameter compare, offset 12
520:		mov word [bp + 30], compare
522:	

stdlib_test$137:	; call function noellipse-ellipse qsort, extra 0
523:		mov word [bp + 18], stdlib_test$138
524:		mov [bp + 20], bp
525:		add bp, 18
526:		mov di, bp
527:		jmp qsort
529:	

stdlib_test$138:	; post call
531:	

stdlib_test$139:	; index = 0
532:		mov word [bp + 16], 0
534:	

stdlib_test$140:	; if index >= size goto 151
535:		mov ax, [bp + 14]
536:		cmp [bp + 16], ax
537:		jge stdlib_test$151
539:	

stdlib_test$141:	; call header integral zero 0 stack zero 0
541:	

stdlib_test$142:	; parameter string_25i20#, offset 6
542:		mov word [bp + 24], string_25i20#
544:	

stdlib_test$143:	; £temporary6047 = index * 2
545:		mov ax, [bp + 16]
547:		xor dx, dx
548:		mul word [int2$2#]
554:	

stdlib_test$144:	; £temporary6048 = list + £temporary6047
555:		mov si, bp
556:		add si, 6
557:		add si, ax
559:	

stdlib_test$145:	; £temporary6049 -> £temporary6048 = *£temporary6048
561:	

stdlib_test$146:	; parameter £temporary6049 -> £temporary6048, offset 8
562:		mov ax, [si]
563:		mov [bp + 26], ax
565:	

stdlib_test$147:	; call function noellipse-ellipse printf, extra 0
566:		mov word [bp + 18], stdlib_test$148
567:		mov [bp + 20], bp
568:		add bp, 18
569:		mov di, bp
570:		add di, 2
571:		jmp printf
573:	

stdlib_test$148:	; post call
575:	

stdlib_test$149:	; ++index
576:		inc word [bp + 16]
578:	

stdlib_test$150:	; goto 140
579:		jmp stdlib_test$140
581:	

stdlib_test$151:	; call header integral zero 0 stack zero 0
583:	

stdlib_test$152:	; parameter string_0AC20List2033A20#, offset 6
584:		mov word [bp + 24], string_0AC20List2033A20#
586:	

stdlib_test$153:	; call function noellipse-ellipse printf, extra 0
587:		mov word [bp + 18], stdlib_test$154
588:		mov [bp + 20], bp
589:		add bp, 18
590:		mov di, bp
591:		jmp printf
593:	

stdlib_test$154:	; post call
595:	

stdlib_test$155:	; call header integral zero 0 stack zero 0
597:	

stdlib_test$156:	; parameter list, offset 6
598:		mov [bp + 24], bp
599:		add word [bp + 24], 6
601:	

stdlib_test$157:	; parameter size, offset 8
602:		mov ax, [bp + 14]
603:		mov [bp + 26], ax
605:	

stdlib_test$158:	; parameter 2, offset 10
606:		mov word [bp + 28], 2
608:	

stdlib_test$159:	; parameter reverse_compare, offset 12
609:		mov word [bp + 30], reverse_compare
611:	

stdlib_test$160:	; call function noellipse-ellipse qsort, extra 0
612:		mov word [bp + 18], stdlib_test$161
613:		mov [bp + 20], bp
614:		add bp, 18
615:		mov di, bp
616:		jmp qsort
618:	

stdlib_test$161:	; post call
620:	

stdlib_test$162:	; index = 0
621:		mov word [bp + 16], 0
623:	

stdlib_test$163:	; if index >= size goto 174
624:		mov ax, [bp + 14]
625:		cmp [bp + 16], ax
626:		jge stdlib_test$174
628:	

stdlib_test$164:	; call header integral zero 0 stack zero 0
630:	

stdlib_test$165:	; parameter string_25i20#, offset 6
631:		mov word [bp + 24], string_25i20#
633:	

stdlib_test$166:	; £temporary6056 = index * 2
634:		mov ax, [bp + 16]
636:		xor dx, dx
637:		mul word [int2$2#]
643:	

stdlib_test$167:	; £temporary6057 = list + £temporary6056
644:		mov si, bp
645:		add si, 6
646:		add si, ax
648:	

stdlib_test$168:	; £temporary6058 -> £temporary6057 = *£temporary6057
650:	

stdlib_test$169:	; parameter £temporary6058 -> £temporary6057, offset 8
651:		mov ax, [si]
652:		mov [bp + 26], ax
654:	

stdlib_test$170:	; call function noellipse-ellipse printf, extra 0
655:		mov word [bp + 18], stdlib_test$171
656:		mov [bp + 20], bp
657:		add bp, 18
658:		mov di, bp
659:		add di, 2
660:		jmp printf
662:	

stdlib_test$171:	; post call
664:	

stdlib_test$172:	; ++index
665:		inc word [bp + 16]
667:	

stdlib_test$173:	; goto 163
668:		jmp stdlib_test$163
670:	

stdlib_test$174:	; call header integral zero 0 stack zero 0
672:	

stdlib_test$175:	; parameter string_0A0ASearch3A0A#, offset 6
673:		mov word [bp + 24], string_0A0ASearch3A0A#
675:	

stdlib_test$176:	; call function noellipse-ellipse printf, extra 0
676:		mov word [bp + 18], stdlib_test$177
677:		mov [bp + 20], bp
678:		add bp, 18
679:		mov di, bp
680:		jmp printf
682:	

stdlib_test$177:	; post call
684:	

stdlib_test$178:	; key = 0
685:		mov word [bp + 16], 0
687:	

stdlib_test$179:	; if key >= 6 goto 206
688:		cmp word [bp + 16], 6
689:		jge stdlib_test$206
691:	

stdlib_test$180:	; call header integral zero 0 stack zero 0
693:	

stdlib_test$181:	; £temporary6063 = &key
694:		mov si, bp
695:		add si, 16
697:	

stdlib_test$182:	; parameter £temporary6063, offset 6
698:		mov [bp + 24], si
700:	

stdlib_test$183:	; parameter list, offset 8
701:		mov [bp + 26], bp
702:		add word [bp + 26], 6
704:	

stdlib_test$184:	; parameter size, offset 10
705:		mov ax, [bp + 14]
706:		mov [bp + 28], ax
708:	

stdlib_test$185:	; parameter 2, offset 12
709:		mov word [bp + 30], 2
711:	

stdlib_test$186:	; parameter compare, offset 14
712:		mov word [bp + 32], compare
714:	

stdlib_test$187:	; call function noellipse-noellipse bsearch
715:		mov word [bp + 18], stdlib_test$188
716:		mov [bp + 20], bp
717:		add bp, 18
718:		jmp bsearch
720:	

stdlib_test$188:	; post call
722:	

stdlib_test$189:	; £temporary6065 = return_value
727:	

stdlib_test$190:	; £temporary6066 = int_to_int £temporary6065 (Pointer -> Pointer)
730:	

stdlib_test$191:	; p = £temporary6066
731:		mov [bp + 18], bx
733:	

stdlib_test$192:	; if p == 0 goto 196
734:		cmp word [bp + 18], 0
735:		je stdlib_test$196
737:	

stdlib_test$193:	; £temporary6068 = p - list
738:		mov ax, [bp + 18]
739:		mov bx, bp
740:		add bx, 6
741:		sub ax, bx
743:	

stdlib_test$194:	; £temporary6073 = £temporary6068 / 2
745:		xor dx, dx
746:		div word [int2$2#]
752:	

stdlib_test$195:	; goto 197
753:		jmp stdlib_test$197
755:	

stdlib_test$196:	; £temporary6073 = -1
756:		mov ax, -1
758:	

stdlib_test$197:	; index = £temporary6073
759:		mov [bp + 20], ax
761:	

stdlib_test$198:	; call header integral zero 0 stack zero 0
763:	

stdlib_test$199:	; parameter string_20202825i2C2025i290A#, offset 6
764:		mov word [bp + 28], string_20202825i2C2025i290A#
766:	

stdlib_test$200:	; parameter key, offset 8
767:		mov ax, [bp + 16]
768:		mov [bp + 30], ax
770:	

stdlib_test$201:	; parameter index, offset 10
771:		mov ax, [bp + 20]
772:		mov [bp + 32], ax
774:	

stdlib_test$202:	; call function noellipse-ellipse printf, extra 0
775:		mov word [bp + 22], stdlib_test$203
776:		mov [bp + 24], bp
777:		add bp, 22
778:		mov di, bp
779:		add di, 4
780:		jmp printf
782:	

stdlib_test$203:	; post call
784:	

stdlib_test$204:	; ++key
785:		inc word [bp + 16]
787:	

stdlib_test$205:	; goto 179
788:		jmp stdlib_test$179
790:	

stdlib_test$206:	; call header integral zero 0 stack zero 0
792:	

stdlib_test$207:	; parameter string_0A#, offset 6
793:		mov word [bp + 24], string_0A#
795:	

stdlib_test$208:	; call function noellipse-ellipse printf, extra 0
796:		mov word [bp + 18], stdlib_test$209
797:		mov [bp + 20], bp
798:		add bp, 18
799:		mov di, bp
800:		jmp printf
802:	

stdlib_test$209:	; post call
804:	

stdlib_test$210:	; return
805:		mov ax, [bp]
806:		mov di, [bp + 4]
807:		mov bp, [bp + 2]
808:		jmp ax
810:	

stdlib_test$211:	; function end stdlib_test
